// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");

function make(param) {
  return {
          activated: false,
          buffer: Buffer$AgdaModeVscode.make(undefined),
          textBeforeActivation: ""
        };
}

function activate(self, text) {
  self.activated = true;
  self.textBeforeActivation = text;
  
}

function init(s) {
  return s.substring(0, s.length - 1 | 0);
}

function last(s) {
  return s.substring(s.length - 1 | 0);
}

function deviseChange(self, input) {
  var inputLength = input.length;
  var bufferSurface = Buffer$AgdaModeVscode.toSurface(self.buffer);
  if (init(input) === self.textBeforeActivation + bufferSurface) {
    return {
            offset: inputLength - 1 | 0,
            insertedText: last(input),
            replacedTextLength: 0
          };
  } else if (input === self.textBeforeActivation || input === self.textBeforeActivation + init(bufferSurface)) {
    return {
            offset: inputLength,
            insertedText: "",
            replacedTextLength: 1
          };
  } else {
    return ;
  }
}

function update(self, input) {
  var change = deviseChange(self, input);
  if (change !== undefined) {
    var match = Buffer$AgdaModeVscode.update(self.buffer, self.textBeforeActivation.length, change);
    var shouldRewrite = match[1];
    var buffer = match[0];
    if (buffer.translation.further) {
      self.buffer = buffer;
      return /* tuple */[
              self.textBeforeActivation + Buffer$AgdaModeVscode.toSurface(buffer),
              /* Update */Caml_chrome_debugger.variant("Update", 1, [
                  Buffer$AgdaModeVscode.toSequence(buffer),
                  buffer.translation,
                  buffer.candidateIndex
                ])
            ];
    } else {
      self.buffer = Buffer$AgdaModeVscode.make(undefined);
      self.activated = false;
      if (shouldRewrite !== undefined) {
        return /* tuple */[
                self.textBeforeActivation + shouldRewrite,
                /* Deactivate */1
              ];
      } else {
        return /* tuple */[
                input,
                /* Deactivate */1
              ];
      }
    }
  }
  self.buffer = Buffer$AgdaModeVscode.make(undefined);
  self.activated = false;
  
}

function insertChar(self, $$char) {
  return update(self, self.textBeforeActivation + (Buffer$AgdaModeVscode.toSurface(self.buffer) + $$char));
}

exports.make = make;
exports.activate = activate;
exports.init = init;
exports.last = last;
exports.deviseChange = deviseChange;
exports.update = update;
exports.insertChar = insertChar;
/* Buffer-AgdaModeVscode Not a pure module */
