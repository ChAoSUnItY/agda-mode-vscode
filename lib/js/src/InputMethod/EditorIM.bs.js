// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");

function make(param) {
  return {
          contents: undefined
        };
}

function isLocked(self) {
  return Belt_Option.isSome(self.contents);
}

function lock(self) {
  var match = $$Promise.pending(undefined);
  self.contents = [
    match[0],
    match[1]
  ];
  
}

function unlock(self) {
  var match = self.contents;
  if (match !== undefined) {
    self.contents = undefined;
    return Curry._1(match[1], undefined);
  }
  
}

function acquire(self) {
  var match = self.contents;
  if (match !== undefined) {
    return match[0];
  } else {
    return $$Promise.resolved(undefined);
  }
}

var Semaphore = {
  make: make,
  isLocked: isLocked,
  lock: lock,
  unlock: unlock,
  acquire: acquire
};

function fromTextEditorSelectionChangeEvent($$event) {
  return {
          TAG: 1,
          _0: Belt_Array.map($$event.selections, (function (prim) {
                  return prim.anchor;
                })),
          [Symbol.for("name")]: "Select"
        };
}

function fromTextDocumentChangeEvent(editor, $$event) {
  var fileName = editor.document.fileName;
  var eventFileName = $$event.document.fileName;
  if (fileName === eventFileName) {
    return {
            TAG: 0,
            _0: Belt_Array.map($$event.contentChanges, (function (change) {
                    return {
                            offset: change.rangeOffset,
                            insertedText: change.text,
                            replacedTextLength: change.rangeLength
                          };
                  })),
            [Symbol.for("name")]: "Change"
          };
  } else {
    return {
            TAG: 0,
            _0: [],
            [Symbol.for("name")]: "Change"
          };
  }
}

var Input = {
  fromTextEditorSelectionChangeEvent: fromTextEditorSelectionChangeEvent,
  fromTextDocumentChangeEvent: fromTextDocumentChangeEvent
};

var Output = {};

function log(param) {
  
}

function toString(self) {
  return "(" + String(self.interval[0]) + ", " + (String(self.interval[1]) + ")");
}

function withIn(instance, offset) {
  var match = instance.interval;
  if (match[0] <= offset) {
    return offset <= match[1];
  } else {
    return false;
  }
}

function destroy(instance) {
  return Belt_Option.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
}

function validateCursorPositions(self, offsets) {
  Curry._1(log, "\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                    return String(prim);
                  }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, toString)))));
  self.instances = Belt_Array.keep(self.instances, (function (instance) {
          var survived = Belt_Array.some(offsets, (function (param) {
                  return withIn(instance, param);
                }));
          if (!survived) {
            destroy(instance);
          }
          return survived;
        }));
  
}

function toRewrites(instances, modify) {
  var accum = {
    contents: 0
  };
  return Belt_Array.keepMap(instances, (function (instance) {
                var match = instance.interval;
                var end_ = match[1];
                var start = match[0];
                instance.interval = [
                  start + accum.contents | 0,
                  end_ + accum.contents | 0
                ];
                return Belt_Option.map(Curry._1(modify, instance), (function (replacement) {
                              var delta = replacement.length - (end_ - start | 0) | 0;
                              accum.contents = accum.contents + delta | 0;
                              instance.interval = [
                                instance.interval[0],
                                instance.interval[1] + delta | 0
                              ];
                              return {
                                      interval: instance.interval,
                                      text: replacement,
                                      instance: instance
                                    };
                            }));
              }));
}

function applyRewrites(self, editor, rewrites) {
  lock(self.semaphore);
  var replacements = Belt_Array.map(rewrites, (function (param) {
          return [
                  param.interval,
                  param.text
                ];
        }));
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  $$Promise.get(match[0], (function (param) {
          Belt_Array.forEach(rewrites, (function (rewrite) {
                  return Belt_Option.forEach(rewrite.instance, (function (instance) {
                                return Belt_Option.forEach(editor, (function (param) {
                                              Belt_Option.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
                                              var $$document = param.document;
                                              var match = instance.interval;
                                              var start = $$document.positionAt(match[0]);
                                              var end_ = $$document.positionAt(match[1]);
                                              var range = new Vscode.Range(start, end_);
                                              instance.decoration = Caml_option.some(Editor$AgdaModeVscode.Decoration.underlineText(param, range));
                                              
                                            }));
                              }));
                }));
          unlock(self.semaphore);
          return Belt_Option.forEach(Belt_Array.get(self.instances, 0), (function (instance) {
                        return Chan$AgdaModeVscode.emit(self.chanLog, {
                                    TAG: 0,
                                    _0: Buffer$AgdaModeVscode.toSequence(instance.buffer),
                                    _1: instance.buffer.translation,
                                    _2: instance.buffer.candidateIndex,
                                    [Symbol.for("name")]: "UpdateView"
                                  });
                      }));
        }));
  var instance = Belt_Array.get(self.instances, 0);
  if (instance !== undefined) {
    return $$Promise.resolved([
                {
                  TAG: 1,
                  _0: replacements,
                  _1: resolve,
                  [Symbol.for("name")]: "Rewrite"
                },
                {
                  TAG: 0,
                  _0: Buffer$AgdaModeVscode.toSequence(instance.buffer),
                  _1: instance.buffer.translation,
                  _2: instance.buffer.candidateIndex,
                  [Symbol.for("name")]: "UpdateView"
                }
              ]);
  } else {
    return $$Promise.resolved([{
                  TAG: 1,
                  _0: replacements,
                  _1: resolve,
                  [Symbol.for("name")]: "Rewrite"
                }]);
  }
}

function groupChangeWithInstances(instances, changes) {
  var changes$1 = changes.sort(function (x, y) {
        return Caml_primitive.caml_int_compare(x.offset, y.offset);
      });
  var go = function (_accum, _x) {
    while(true) {
      var x = _x;
      var accum = _accum;
      var match = x[0];
      if (match) {
        var match$1 = x[1];
        if (!match$1) {
          return /* [] */0;
        }
        var is = match$1.tl;
        var instance = match$1.hd;
        var cs = match.tl;
        var change = match.hd;
        var match$2 = instance.interval;
        var end_ = match$2[1];
        var start = match$2[0];
        var delta = change.insertedText.length - change.replacedTextLength | 0;
        if (withIn(instance, change.offset)) {
          instance.interval = [
            accum + start | 0,
            (accum + end_ | 0) + delta | 0
          ];
          return {
                  hd: [
                    instance,
                    {
                      offset: change.offset + accum | 0,
                      insertedText: change.insertedText,
                      replacedTextLength: change.replacedTextLength
                    }
                  ],
                  tl: go(accum + delta | 0, [
                        cs,
                        is
                      ])
                };
        }
        if (change.offset < instance.interval[0]) {
          _x = [
            cs,
            {
              hd: instance,
              tl: is
            }
          ];
          _accum = accum + delta | 0;
          continue ;
        }
        instance.interval = [
          accum + start | 0,
          accum + end_ | 0
        ];
        return {
                hd: [
                  instance,
                  undefined
                ],
                tl: go(accum, [
                      {
                        hd: change,
                        tl: cs
                      },
                      is
                    ])
              };
      }
      var match$3 = x[1];
      if (match$3) {
        return Belt_List.map({
                    hd: match$3.hd,
                    tl: match$3.tl
                  }, (function (i) {
                      return [
                              i,
                              undefined
                            ];
                    }));
      } else {
        return /* [] */0;
      }
    };
  };
  return Belt_List.toArray(go(0, [
                  Belt_List.fromArray(changes$1),
                  Belt_List.fromArray(instances)
                ]));
}

function updateInstances(instances, changes) {
  var instancesWithChanges = groupChangeWithInstances(instances, changes);
  var rewrites = [];
  var accum = {
    contents: 0
  };
  var instances$1 = Belt_Array.keepMap(instancesWithChanges, (function (param) {
          var change = param[1];
          var instance = param[0];
          if (change === undefined) {
            return instance;
          }
          var match = Buffer$AgdaModeVscode.update(instance.buffer, instance.interval[0], change);
          var buffer = match[0];
          Belt_Option.forEach(match[1], (function (text) {
                  var match = instance.interval;
                  var end_ = match[1];
                  var start = match[0];
                  var delta = text.length - (end_ - start | 0) | 0;
                  instance.interval = [
                    start + accum.contents | 0,
                    (end_ + accum.contents | 0) + delta | 0
                  ];
                  rewrites.push({
                        interval: [
                          start + accum.contents | 0,
                          end_ + accum.contents | 0
                        ],
                        text: text,
                        instance: buffer.translation.further ? instance : undefined
                      });
                  accum.contents = accum.contents + delta | 0;
                  
                }));
          if (buffer.translation.further) {
            instance.buffer = buffer;
            return instance;
          } else {
            destroy(instance);
            return ;
          }
        }));
  return [
          instances$1,
          rewrites
        ];
}

function activate(self, editor, cursors) {
  self.activated = true;
  Chan$AgdaModeVscode.emit(self.chanLog, /* Activate */0);
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", true);
  self.instances = Belt_Array.map(cursors.sort(function (x, y) {
            return Caml_primitive.caml_int_compare(x[0], y[0]);
          }), (function (param) {
          if (editor === undefined) {
            return {
                    interval: param,
                    decoration: undefined,
                    buffer: Buffer$AgdaModeVscode.make(undefined)
                  };
          }
          var editor$1 = Caml_option.valFromOption(editor);
          var $$document = editor$1.document;
          var start = $$document.positionAt(param[0]);
          var end_ = $$document.positionAt(param[1]);
          var range = new Vscode.Range(start, end_);
          return {
                  interval: param,
                  decoration: Caml_option.some(Editor$AgdaModeVscode.Decoration.underlineText(editor$1, range)),
                  buffer: Buffer$AgdaModeVscode.make(undefined)
                };
        }));
  
}

function deactivate(self) {
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", false);
  Chan$AgdaModeVscode.emit(self.chanLog, /* Deactivate */1);
  Belt_Array.forEach(self.instances, destroy);
  self.instances = [];
  self.activated = false;
  
}

function make$1(chanLog) {
  return {
          instances: [],
          activated: false,
          semaphore: {
            contents: undefined
          },
          chanLog: chanLog
        };
}

function isActivated(self) {
  return self.activated;
}

function run(self, editor, input) {
  switch (input.TAG | 0) {
    case /* Change */0 :
        if (!(self.activated && !Belt_Option.isSome(self.semaphore.contents))) {
          return $$Promise.resolved([]);
        }
        var match = updateInstances(self.instances, input._0);
        self.instances = match[0];
        return applyRewrites(self, editor, match[1]);
    case /* Select */1 :
        var positions = input._0;
        if (self.activated) {
          return $$Promise.map(acquire(self.semaphore), (function (param) {
                        if (editor === undefined) {
                          return [];
                        }
                        var $$document = Caml_option.valFromOption(editor).document;
                        var offsets = Belt_Array.map(positions, (function (param) {
                                return $$document.offsetAt(param);
                              }));
                        validateCursorPositions(self, offsets);
                        if (self.instances.length === 0) {
                          deactivate(self);
                          return [/* Deactivate */1];
                        } else {
                          return [];
                        }
                      }));
        } else {
          return $$Promise.resolved([]);
        }
    case /* Candidate */2 :
        var action = input._0;
        var callback;
        if (typeof action === "number") {
          switch (action) {
            case /* BrowseUp */0 :
                callback = (function (instance) {
                    instance.buffer = Buffer$AgdaModeVscode.moveUp(instance.buffer);
                    return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
                  });
                break;
            case /* BrowseDown */1 :
                callback = (function (instance) {
                    instance.buffer = Buffer$AgdaModeVscode.moveDown(instance.buffer);
                    return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
                  });
                break;
            case /* BrowseLeft */2 :
                callback = (function (instance) {
                    instance.buffer = Buffer$AgdaModeVscode.moveLeft(instance.buffer);
                    return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
                  });
                break;
            case /* BrowseRight */3 :
                callback = (function (instance) {
                    instance.buffer = Buffer$AgdaModeVscode.moveRight(instance.buffer);
                    return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
                  });
                break;
            
          }
        } else {
          var symbol = action._0;
          callback = (function (param) {
              return symbol;
            });
        }
        var rewrites = toRewrites(self.instances, callback);
        return applyRewrites(self, editor, rewrites);
    
  }
}

function deviseChange(self, previous, next) {
  return Belt_Option.flatMap(Belt_Array.get(self.instances, 0), (function (instance) {
                var inputLength = next.length;
                var bufferSurface = Buffer$AgdaModeVscode.toSurface(instance.buffer);
                var init = function (s) {
                  return s.substring(0, s.length - 1 | 0);
                };
                var last = function (s) {
                  return s.substring(s.length - 1 | 0);
                };
                if (init(next) === previous + bufferSurface) {
                  return {
                          TAG: 0,
                          _0: [{
                              offset: inputLength - 1 | 0,
                              insertedText: last(next),
                              replacedTextLength: 0
                            }],
                          [Symbol.for("name")]: "Change"
                        };
                } else if (next === previous || next === previous + init(bufferSurface)) {
                  return {
                          TAG: 0,
                          _0: [{
                              offset: inputLength,
                              insertedText: "",
                              replacedTextLength: 1
                            }],
                          [Symbol.for("name")]: "Change"
                        };
                } else {
                  return ;
                }
              }));
}

var Module = {
  make: make$1,
  activate: activate,
  deactivate: deactivate,
  isActivated: isActivated,
  run: run,
  deviseChange: deviseChange
};

exports.Semaphore = Semaphore;
exports.Input = Input;
exports.Output = Output;
exports.Module = Module;
exports.make = make$1;
exports.activate = activate;
exports.deactivate = deactivate;
exports.isActivated = isActivated;
exports.run = run;
exports.deviseChange = deviseChange;
/* vscode Not a pure module */
