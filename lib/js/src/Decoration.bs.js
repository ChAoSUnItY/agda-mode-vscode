// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Common$AgdaModeVscode = require("./Common.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Common$AgdaModeVscode.Interval.toRange($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Common$AgdaModeVscode.Interval.toRange($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function offsetToPoint($$document, utf16indices, eolIndices, offset) {
  var offset$1 = Editor$AgdaModeVscode.Indices.convert(utf16indices, offset);
  var offset$2 = Editor$AgdaModeVscode.Indices.convert(eolIndices, offset$1);
  return $$document.positionAt(offset$2);
}

function offsetToPointSlow($$document, offset) {
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var utf16indices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeUTF16SurrogatePairIndices(text));
  var offset$1 = Editor$AgdaModeVscode.Indices.convert(utf16indices, offset);
  return $$document.positionAt(offset$1);
}

function decorateHighlightings(editor, highlightings) {
  console.time("$$$ Decoration / aspects");
  console.time("$$$ Decoration / aspects / offset conversion");
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var utf16indices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeUTF16SurrogatePairIndices(text));
  var eolIndices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeCRLFIndices(text));
  var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
          var start = offsetToPoint($$document, utf16indices, eolIndices, highlighting.start);
          var end_ = offsetToPoint($$document, utf16indices, eolIndices, highlighting.end_);
          var range = new Vscode.Range(start, end_);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  console.timeEnd("$$$ Decoration / aspects / offset conversion");
  console.time("$$$ Decoration / aspects / scrlocs conversion");
  var srcLocs = Belt_Array.keepMap(highlightings$1, (function (param) {
          var range = param[0];
          return Belt_Option.map(param[2], (function (param) {
                        return {
                                range: range,
                                filepath: param[0],
                                offset: param[1]
                              };
                      }));
        }));
  console.timeEnd("$$$ Decoration / aspects / scrlocs conversion");
  console.time("$$$ Decoration / aspects / dict bundling");
  var backgroundColorDict = {};
  var foregroundColorDict = {};
  var addFaceToDict = function (face, range) {
    if (face.TAG === /* Background */0) {
      var color = face._0;
      var ranges = Js_dict.get(backgroundColorDict, color);
      if (ranges !== undefined) {
        ranges.push(range);
      } else {
        backgroundColorDict[color] = [range];
      }
      return ;
    }
    var color$1 = face._0;
    var ranges$1 = Js_dict.get(foregroundColorDict, color$1);
    if (ranges$1 !== undefined) {
      ranges$1.push(range);
    } else {
      foregroundColorDict[color$1] = [range];
    }
    
  };
  console.timeEnd("$$$ Decoration / aspects / dict bundling");
  console.timeEnd("$$$ Decoration / aspects");
  console.time("$$$ Decoration / dicts");
  Belt_Array.forEach(aspects, (function (param) {
          var range = param[1];
          var style = Highlighting$AgdaModeVscode.Aspect.toStyle(param[0]);
          if (!style) {
            return ;
          }
          var theme = VSCode.ColorTheme.kind(Vscode.window.activeColorTheme);
          if (theme === /* Dark */1) {
            return addFaceToDict(style._1, range);
          } else {
            return addFaceToDict(style._0, range);
          }
        }));
  console.timeEnd("$$$ Decoration / dicts");
  console.time("$$$ Decoration / apply");
  var backgroundDecorations = Belt_Array.map(Js_dict.entries(backgroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.highlightBackgroundWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  var foregroundDecorations = Belt_Array.map(Js_dict.entries(foregroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.decorateTextWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  console.timeEnd("$$$ Decoration / apply");
  return [
          foregroundDecorations.concat(backgroundDecorations),
          srcLocs
        ];
}

function make(param) {
  return {
          tempFilePaths: [],
          highlightings: [],
          decorations: [],
          srcLocs: []
        };
}

function removeAppliedDecorations(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Belt_Array.forEach(self.tempFilePaths, (function (filepath) {
          Fs.unlink(filepath, (function (param) {
                  
                }));
          
        }));
  self.tempFilePaths = [];
  self.highlightings = [];
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function refresh(self, editor) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addDirectly(self, highlightings) {
  self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
  
}

function addIndirectly(self, filepath) {
  self.tempFilePaths.push(filepath);
  
}

var readFile = Util.promisify(function (prim, prim$1) {
      Fs.readFile(prim, prim$1);
      
    });

function readAndParse(filepath) {
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (x) {
                if (x.TAG !== /* Ok */0) {
                  return [];
                }
                var expressions = Parser$AgdaModeVscode.SExpression.parse(x._0.toString());
                Belt_Array.keepMap(expressions, (function (x) {
                        if (x.TAG === /* Ok */0) {
                          return ;
                        } else {
                          return x._0;
                        }
                      }));
                return Belt_Array.concatMany(Belt_Array.keepMap(expressions, (function (x) {
                                  if (x.TAG !== /* Ok */0) {
                                    return ;
                                  }
                                  var xs = x._0;
                                  if (xs.TAG === /* A */0) {
                                    return [];
                                  } else {
                                    return Highlighting$AgdaModeVscode.parseIndirectHighlightings(xs._0);
                                  }
                                })));
              }));
}

function readTempFiles(self) {
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), Belt_Array.concatMany), (function (highlightings) {
                self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
                self.tempFilePaths = [];
                
              }));
}

function applyHighlightings(self, editor) {
  var match = decorateHighlightings(editor, self.highlightings);
  self.highlightings = [];
  self.srcLocs = match[1];
  self.decorations = Belt_Array.concat(self.decorations, match[0]);
  
}

function lookupSrcLoc(self, point) {
  return Belt_Option.map(Caml_option.undefined_to_opt(self.srcLocs.find(function (srcLoc) {
                      return srcLoc.range.contains(point);
                    })), (function (srcLoc) {
                return $$Promise.map(Vscode.workspace.openTextDocument(srcLoc.filepath), (function ($$document) {
                              var point = offsetToPointSlow($$document, srcLoc.offset - 1 | 0);
                              return [[
                                        srcLoc.range,
                                        srcLoc.filepath,
                                        point
                                      ]];
                            }));
              }));
}

var Module = {
  make: make,
  decorateHole: decorateHole,
  addDirectly: addDirectly,
  addIndirectly: addIndirectly,
  removeAppliedDecorations: removeAppliedDecorations,
  readTempFiles: readTempFiles,
  applyHighlightings: applyHighlightings,
  refresh: refresh,
  destroy: destroy,
  lookupSrcLoc: lookupSrcLoc
};

exports.Module = Module;
exports.make = make;
exports.decorateHole = decorateHole;
exports.addDirectly = addDirectly;
exports.addIndirectly = addIndirectly;
exports.removeAppliedDecorations = removeAppliedDecorations;
exports.readTempFiles = readTempFiles;
exports.applyHighlightings = applyHighlightings;
exports.refresh = refresh;
exports.destroy = destroy;
exports.lookupSrcLoc = lookupSrcLoc;
/* readFile Not a pure module */
