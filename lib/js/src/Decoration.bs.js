// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function Impl(Editor) {
  var decorateHole = function (editor, param, index) {
    var end_ = param[1];
    var start = param[0];
    var $$document = Curry._1(Editor.getDocument, editor);
    var backgroundRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, $$document, start), Curry._2(Editor.pointAtOffset, $$document, end_));
    var background = Curry._3(Editor.Decoration.highlightBackground, editor, "editor.selectionHighlightBackground", [backgroundRange]);
    var indexText = String(index);
    var indexRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, $$document, start), Curry._2(Editor.pointAtOffset, $$document, end_ - 2 | 0));
    var index$1 = Curry._4(Editor.Decoration.overlayText, editor, "editorLightBulb.foreground", indexText, indexRange);
    return /* tuple */[
            background,
            index$1
          ];
  };
  var normalize = function ($$document, point) {
    var useCRLF = Curry._1(Editor.lineEndingIsCRLF, $$document);
    if (!useCRLF) {
      return point;
    }
    var skippedCRLF = Curry._1(Editor.Point.line, point);
    return Curry._3(Editor.Point.translate, point, 0, skippedCRLF);
  };
  var offsetToPoint = function ($$document, intervals, offset) {
    var offset$1 = Curry._2(Editor.fromUTF8Offset, intervals, offset);
    var point = Curry._2(Editor.pointAtOffset, $$document, offset$1);
    return normalize($$document, point);
  };
  var offsetToPointSlow = function ($$document, offset) {
    var text = Curry._1(Editor.getText, $$document);
    var intervals = Curry._1(Editor.OffsetIntervals.compile, text);
    var offset$1 = Curry._2(Editor.fromUTF8Offset, intervals, offset);
    var point = Curry._2(Editor.pointAtOffset, $$document, offset$1);
    return normalize($$document, point);
  };
  var decorateHighlightings = function (editor, highlightings) {
    console.time("$$$ Decoration / aspects");
    console.time("$$$ Decoration / aspects / offset conversion");
    var $$document = Curry._1(Editor.getDocument, editor);
    var text = Curry._1(Editor.getText, $$document);
    var intervals = Curry._1(Editor.OffsetIntervals.compile, text);
    var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
            var start = offsetToPoint($$document, intervals, highlighting.start);
            var end_ = offsetToPoint($$document, intervals, highlighting.end_);
            var range = Curry._2(Editor.$$Range.make, start, end_);
            return /* tuple */[
                    range,
                    highlighting.aspects,
                    highlighting.source
                  ];
          }));
    var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
                var range = param[0];
                return Belt_Array.map(param[1], (function (aspect) {
                              return /* tuple */[
                                      aspect,
                                      range
                                    ];
                            }));
              })));
    console.timeEnd("$$$ Decoration / aspects / offset conversion");
    console.time("$$$ Decoration / aspects / scrlocs conversion");
    var srcLocs = Belt_Array.keepMap(highlightings$1, (function (param) {
            var range = param[0];
            return Belt_Option.map(param[2], (function (param) {
                          return {
                                  range: range,
                                  filepath: param[0],
                                  offset: param[1]
                                };
                        }));
          }));
    console.timeEnd("$$$ Decoration / aspects / scrlocs conversion");
    console.time("$$$ Decoration / aspects / dict bundling");
    var backgroundColorDict = { };
    var foregroundColorDict = { };
    var addFaceToDict = function (face, range) {
      if (face.tag) {
        var color = face[0];
        var ranges = Js_dict.get(foregroundColorDict, color);
        if (ranges !== undefined) {
          ranges.push(range);
          return ;
        } else {
          foregroundColorDict[color] = [range];
          return ;
        }
      }
      var color$1 = face[0];
      var ranges$1 = Js_dict.get(backgroundColorDict, color$1);
      if (ranges$1 !== undefined) {
        ranges$1.push(range);
        return ;
      } else {
        backgroundColorDict[color$1] = [range];
        return ;
      }
    };
    console.timeEnd("$$$ Decoration / aspects / dict bundling");
    console.timeEnd("$$$ Decoration / aspects");
    console.time("$$$ Decoration / dicts");
    Belt_Array.forEach(aspects, (function (param) {
            var range = param[1];
            var style = Highlighting$AgdaModeVscode.Aspect.toStyle(param[0]);
            if (style) {
              if (Curry._1(Editor.colorThemeIsDark, undefined)) {
                return addFaceToDict(style[1], range);
              } else {
                return addFaceToDict(style[0], range);
              }
            }
            
          }));
    console.timeEnd("$$$ Decoration / dicts");
    console.time("$$$ Decoration / apply");
    var backgroundDecorations = Belt_Array.map(Js_dict.entries(backgroundColorDict), (function (param) {
            var ranges = param[1];
            return /* tuple */[
                    Curry._3(Editor.Decoration.highlightBackgroundWithColor, editor, param[0], ranges),
                    ranges
                  ];
          }));
    var foregroundDecorations = Belt_Array.map(Js_dict.entries(foregroundColorDict), (function (param) {
            var ranges = param[1];
            return /* tuple */[
                    Curry._3(Editor.Decoration.decorateTextWithColor, editor, param[0], ranges),
                    ranges
                  ];
          }));
    console.timeEnd("$$$ Decoration / apply");
    return /* tuple */[
            foregroundDecorations.concat(backgroundDecorations),
            srcLocs
          ];
  };
  var lines = function (doc, range) {
    var startingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.start, range));
    var endingLine = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.end_, range));
    var ranges = [];
    for(var i = startingLine; i <= endingLine; ++i){
      var startingPoint = i === startingLine ? Curry._1(Editor.$$Range.start, range) : Curry._2(Editor.Point.make, i, 0);
      var endingPoint;
      if (i === endingLine) {
        endingPoint = Curry._1(Editor.$$Range.end_, range);
      } else {
        var offset = Curry._2(Editor.offsetAtPoint, doc, Curry._2(Editor.Point.make, i + 1 | 0, 0)) - 1 | 0;
        endingPoint = Curry._2(Editor.pointAtOffset, doc, offset);
      }
      ranges.push(Curry._2(Editor.$$Range.make, startingPoint, endingPoint));
    }
    return ranges;
  };
  var generateSemanticTokens = function (editor, highlightings, push) {
    console.log("GENERATE");
    var $$document = Curry._1(Editor.getDocument, editor);
    var text = Curry._1(Editor.getText, $$document);
    var intervals = Curry._1(Editor.OffsetIntervals.compile, text);
    var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
            var start = offsetToPoint($$document, intervals, highlighting.start);
            var end_ = offsetToPoint($$document, intervals, highlighting.end_);
            var range = Curry._2(Editor.$$Range.make, start, end_);
            return /* tuple */[
                    range,
                    highlighting.aspects,
                    highlighting.source
                  ];
          }));
    var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
                var range = param[0];
                return Belt_Array.map(param[1], (function (aspect) {
                              return /* tuple */[
                                      aspect,
                                      range
                                    ];
                            }));
              })));
    Belt_Array.forEach(aspects, (function (param) {
            var ranges = lines(Curry._1(Editor.getDocument, editor), param[1]);
            var match = Highlighting$AgdaModeVscode.Aspect.toTokenTypeAndModifiers(param[0]);
            var tokenType = Curry._1(Highlighting$AgdaModeVscode.Aspect.TokenType.toString, match[0]);
            var tokenModifier = Belt_Option.map(match[1], (function (x) {
                    return Belt_Array.map(x, Highlighting$AgdaModeVscode.Aspect.TokenModifier.toString);
                  }));
            return Belt_Array.forEach(ranges, (function (range) {
                          return Curry._3(push, range, tokenType, tokenModifier);
                        }));
          }));
    return $$Promise.resolved(undefined);
  };
  var make = function (param) {
    return {
            tempFilePaths: [],
            highlightings: [],
            decorations: [],
            srcLocs: []
          };
  };
  var removeAppliedDecorations = function (self) {
    Belt_Array.forEach(self.decorations, (function (param) {
            return Curry._1(Editor.Decoration.destroy, param[0]);
          }));
    self.decorations = [];
    
  };
  var destroy = function (self) {
    Belt_Array.forEach(self.tempFilePaths, (function (filepath) {
            Fs.unlink(filepath, (function (param) {
                    
                  }));
            
          }));
    self.tempFilePaths = [];
    self.highlightings = [];
    Belt_Array.forEach(self.decorations, (function (param) {
            return Curry._1(Editor.Decoration.destroy, param[0]);
          }));
    self.decorations = [];
    
  };
  var refresh = function (editor, self) {
    return Belt_Array.forEach(self.decorations, (function (param) {
                  return Curry._3(Editor.Decoration.decorate, editor, param[0], param[1]);
                }));
  };
  var addDirectly = function (self, highlightings) {
    self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
    
  };
  var addIndirectly = function (self, filepath) {
    self.tempFilePaths.push(filepath);
    
  };
  var readFile = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          
        }));
  var readAndParse = function (filepath) {
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (content) {
                  if (content.tag) {
                    return [];
                  }
                  var expressions = Parser$AgdaModeVscode.SExpression.parse(content[0].toString());
                  Belt_Array.keepMap(expressions, (function (error) {
                          if (error.tag) {
                            return error[0];
                          }
                          
                        }));
                  return Belt_Array.concatMany(Belt_Array.keepMap(expressions, (function (param) {
                                    if (param.tag) {
                                      return ;
                                    }
                                    var xs = param[0];
                                    if (xs.tag) {
                                      return Highlighting$AgdaModeVscode.parseIndirectHighlightings(xs[0]);
                                    } else {
                                      return [];
                                    }
                                  })));
                }));
  };
  var readTempFiles = function (self) {
    return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), Belt_Array.concatMany), (function (highlightings) {
                  self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
                  self.tempFilePaths = [];
                  
                }));
  };
  var applyHighlightings = function (self, editor) {
    var match = decorateHighlightings(editor, self.highlightings);
    self.highlightings = [];
    self.srcLocs = match[1];
    self.decorations = Belt_Array.concat(self.decorations, match[0]);
    
  };
  var lookupSrcLoc = function (self, point) {
    return Belt_Option.map(Caml_option.undefined_to_opt(self.srcLocs.find((function (srcLoc) {
                          return Curry._2(Editor.$$Range.contains, srcLoc.range, point);
                        }))), (function (srcLoc) {
                  return $$Promise.map(Curry._1(Editor.openDocument, srcLoc.filepath), (function ($$document) {
                                var point = offsetToPointSlow($$document, srcLoc.offset - 1 | 0);
                                return [/* tuple */[
                                          srcLoc.range,
                                          srcLoc.filepath,
                                          point
                                        ]];
                              }));
                }));
  };
  return {
          decorateHole: decorateHole,
          normalize: normalize,
          offsetToPoint: offsetToPoint,
          offsetToPointSlow: offsetToPointSlow,
          decorateHighlightings: decorateHighlightings,
          lines: lines,
          generateSemanticTokens: generateSemanticTokens,
          make: make,
          removeAppliedDecorations: removeAppliedDecorations,
          destroy: destroy,
          refresh: refresh,
          addDirectly: addDirectly,
          addIndirectly: addIndirectly,
          readFile: readFile,
          readAndParse: readAndParse,
          readTempFiles: readTempFiles,
          applyHighlightings: applyHighlightings,
          lookupSrcLoc: lookupSrcLoc
        };
}

exports.Impl = Impl;
/* fs Not a pure module */
