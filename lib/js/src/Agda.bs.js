// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Common$AgdaModeVscode = require("./Common.bs.js");
var Component$AgdaModeVscode = require("./View/Component/Component.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./View/Emacs/Emacs__Parser.bs.js");

function toText(x) {
  switch (x.TAG | 0) {
    case /* Plain */0 :
        return Component$AgdaModeVscode.$$Text.plainText(["expr"], x._0);
    case /* QuestionMark */1 :
        var i = x._0;
        return Component$AgdaModeVscode.$$Text.hole("?" + String(i), true, true, [
                    "expr",
                    "question-mark"
                  ], i);
    case /* Underscore */2 :
        return Component$AgdaModeVscode.$$Text.plainText(["expr underscore"], "_" + x._0);
    
  }
}

var Term = {
  toText: toText
};

function parse(raw) {
  var __x = raw.trim();
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(__x.split(/(\?\d+)|(\_\d+[^\}\)\s]*)/), (function (i, token) {
                    var match = i % 3;
                    if (match !== 1) {
                      if (match !== 2) {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 0,
                                              _0: x,
                                              [Symbol.for("name")]: "Plain"
                                            };
                                    }));
                      } else {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 2,
                                              _0: x,
                                              [Symbol.for("name")]: "Underscore"
                                            };
                                    }));
                      }
                    } else {
                      return Belt_Option.map(Belt_Option.flatMap(Belt_Option.map(token, (function (param) {
                                            return param.slice(1);
                                          })), Pervasives.int_of_string_opt), (function (x) {
                                    return {
                                            TAG: 1,
                                            _0: x,
                                            [Symbol.for("name")]: "QuestionMark"
                                          };
                                  }));
                    }
                  })), (function (x) {
                return x;
              }));
}

function toText$1(xs) {
  return Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(xs, toText));
}

var Expr = {
  parse: parse,
  toText: toText$1
};

function toText$2(value) {
  if (value.TAG === /* NamedMeta */0) {
    var string = value._0;
    switch (string) {
      case "" :
      case "_" :
          return Component$AgdaModeVscode.$$Text.plainText(undefined, String(value._1));
      default:
        return Component$AgdaModeVscode.$$Text.plainText(undefined, "_" + string + String(value._1));
    }
  } else {
    var index = value._0;
    return Component$AgdaModeVscode.$$Text.hole("?" + String(index), undefined, undefined, undefined, index);
  }
}

var decode = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "InteractionId" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (id) {
                                      return {
                                              TAG: 1,
                                              _0: id,
                                              [Symbol.for("name")]: "InteractionId"
                                            };
                                    }), Json_decode.$$int, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "NamedMeta" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 0,
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "NamedMeta"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(Json_decode.string, Json_decode.$$int, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[Agda.NMII] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var NMII = {
  toText: toText$2,
  decode: decode
};

function toText$3(value) {
  switch (value) {
    case /* Covariant */0 :
        return Component$AgdaModeVscode.$$Text.plainText(undefined, " + ");
    case /* Contravariant */1 :
        return Component$AgdaModeVscode.$$Text.plainText(undefined, " - ");
    case /* Invariant */2 :
        return Component$AgdaModeVscode.$$Text.plainText(undefined, " * ");
    case /* Nonvariant */3 :
        return Component$AgdaModeVscode.$$Text.plainText(undefined, " _ ");
    
  }
}

var decode$1 = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "Contravariant" :
            return {
                    TAG: 1,
                    _0: /* Contravariant */1,
                    [Symbol.for("name")]: "TagOnly"
                  };
        case "Covariant" :
            return {
                    TAG: 1,
                    _0: /* Covariant */0,
                    [Symbol.for("name")]: "TagOnly"
                  };
        case "Invariant" :
            return {
                    TAG: 1,
                    _0: /* Invariant */2,
                    [Symbol.for("name")]: "TagOnly"
                  };
        case "Nonvariant" :
            return {
                    TAG: 1,
                    _0: /* Nonvariant */3,
                    [Symbol.for("name")]: "TagOnly"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[Agda.Polarity] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var Polarity = {
  toText: toText$3,
  decode: decode$1
};

var partial_arg = /^([^\:]*) \: ((?:\n|.)+)/;

function parseOfType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg, (function (captured) {
                return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse), (function (type_) {
                              return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (term) {
                                            return {
                                                    TAG: 18,
                                                    _0: toText$1(term),
                                                    _1: toText$1(type_),
                                                    [Symbol.for("name")]: "OfType'"
                                                  };
                                          }));
                            }));
              }), param);
}

var partial_arg$1 = /^Type ((?:\n|.)+)/;

function parseJustType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$1, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (type_) {
                              return {
                                      TAG: 19,
                                      _0: toText$1(type_),
                                      [Symbol.for("name")]: "JustType'"
                                    };
                            }));
              }), param);
}

var partial_arg$2 = /^Sort ((?:\n|.)+)/;

function parseJustSort(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$2, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (sort) {
                              return {
                                      TAG: 20,
                                      _0: toText$1(sort),
                                      [Symbol.for("name")]: "JustSort'"
                                    };
                            }));
              }), param);
}

function parseOthers(raw) {
  return Belt_Option.map(parse(raw), (function (raw$prime) {
                return {
                        TAG: 21,
                        _0: toText$1(raw$prime),
                        [Symbol.for("name")]: "Others'"
                      };
              }));
}

var partial_arg$3 = [
  parseOfType,
  parseJustType,
  parseJustSort,
  parseOthers
];

function parse$1(param) {
  return Emacs__Parser$AgdaModeVscode.choice(partial_arg$3, param);
}

function toText$4(value, $$location) {
  var $$location$1 = Belt_Option.mapWithDefault($$location, Component$AgdaModeVscode.$$Text.empty, (function (loc) {
          return Component$AgdaModeVscode.$$Text.$$location(loc, true);
        }));
  var cmpToText = function (cmp, a, b) {
    return Component$AgdaModeVscode.$$Text.concatMany([
                toText$2(a),
                Component$AgdaModeVscode.$$Text.plainText(undefined, cmp ? " = " : " =< "),
                toText$2(b)
              ]);
  };
  switch (value.TAG | 0) {
    case /* OfType */0 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    toText$2(value._0),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._1)
                  ]);
    case /* JustType */1 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Type "),
                    toText$2(value._0)
                  ]);
    case /* JustSort */2 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Sort "),
                    toText$2(value._0)
                  ]);
    case /* CmpInType */3 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    cmpToText(value._0, value._2, value._3),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._1)
                  ]);
    case /* CmpElim */4 :
        var polarities = Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(value._0, toText$3));
        var names1 = Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(value._2, toText$2));
        var names2 = Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(value._3, toText$2));
        return Component$AgdaModeVscode.$$Text.concatMany([
                    names1,
                    polarities,
                    names2,
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._1)
                  ]);
    case /* Guard */9 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    toText$4(value._0, undefined),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "(blocked by problem "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, String(value._1)),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, ")")
                  ]);
    case /* Assign */10 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    toText$2(value._0),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " := "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._1)
                  ]);
    case /* TypedAssign */11 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    toText$2(value._0),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " := "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._1),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " :? "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._2)
                  ]);
    case /* PostponedCheckArgs */12 :
        var t0 = Component$AgdaModeVscode.$$Text.concatMany([
              Component$AgdaModeVscode.$$Text.plainText(undefined, "(_"),
              Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
              Component$AgdaModeVscode.$$Text.plainText(undefined, value._2),
              Component$AgdaModeVscode.$$Text.plainText(undefined, ")")
            ]);
        var exprs = Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(value._1, (function (expr) {
                    return Component$AgdaModeVscode.$$Text.plainText(undefined, " (" + expr + ")");
                  })));
        return Component$AgdaModeVscode.$$Text.concatMany([
                    toText$2(value._0),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " := "),
                    t0,
                    exprs,
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._3)
                  ]);
    case /* IsEmptyType */13 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Is empty: "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._0)
                  ]);
    case /* SizeLtSat */14 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Not empty type of sizes: "),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, value._0)
                  ]);
    case /* FindInstanceOF */15 :
        var line1 = Component$AgdaModeVscode.$$Text.concatMany([
              Component$AgdaModeVscode.$$Text.plainText(undefined, "Resolve instance argument "),
              toText$2(value._0),
              Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
              Component$AgdaModeVscode.$$Text.plainText(undefined, value._1)
            ]);
        var pairs = Component$AgdaModeVscode.$$Text.concatMany(Belt_Array.map(value._2, (function (param) {
                    return Component$AgdaModeVscode.$$Text.concatMany([
                                Component$AgdaModeVscode.$$Text.plainText(undefined, param[0]),
                                Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                                Component$AgdaModeVscode.$$Text.plainText(undefined, param[1]),
                                Component$AgdaModeVscode.$$Text.plainText(undefined, " \n")
                              ]);
                  })));
        var line2 = Component$AgdaModeVscode.$$Text.concatMany([
              Component$AgdaModeVscode.$$Text.plainText(undefined, " \nCandidate: "),
              pairs
            ]);
        return Component$AgdaModeVscode.$$Text.concatMany([
                    line1,
                    line2
                  ]);
    case /* PTSInstance */16 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "PTS instance for ("),
                    toText$2(value._0),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " , "),
                    toText$2(value._1),
                    Component$AgdaModeVscode.$$Text.plainText(undefined, ")")
                  ]);
    case /* PostponedCheckFunDef */17 :
        return Component$AgdaModeVscode.$$Text.plainText(undefined, "Check definition of " + value._0 + " : " + value._1);
    case /* OfType' */18 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    value._0,
                    Component$AgdaModeVscode.$$Text.plainText(undefined, " : "),
                    value._1,
                    $$location$1
                  ]);
    case /* JustType' */19 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Type "),
                    value._0,
                    $$location$1
                  ]);
    case /* JustSort' */20 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    Component$AgdaModeVscode.$$Text.plainText(undefined, "Sort "),
                    value._0,
                    $$location$1
                  ]);
    case /* Others' */21 :
        return Component$AgdaModeVscode.$$Text.concatMany([
                    value._0,
                    $$location$1
                  ]);
    default:
      return cmpToText(value._0, value._1, value._2);
  }
}

var decode$2 = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "Assign" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 10,
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "Assign"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(decode, Json_decode.string, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpElim" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 4,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              _3: param[3],
                                              [Symbol.for("name")]: "CmpElim"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple4((function (param) {
                                                    return Json_decode.array(decode$1, param);
                                                  }), Json_decode.string, (function (param) {
                                                    return Json_decode.array(decode, param);
                                                  }), (function (param) {
                                                    return Json_decode.array(decode, param);
                                                  }), param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpInType" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 3,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              _3: param[3],
                                              [Symbol.for("name")]: "CmpInType"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple4(Json_decode.bool, Json_decode.string, decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpLevels" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 6,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "CmpLevels"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(Json_decode.bool, decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpSorts" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 8,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "CmpSorts"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(Json_decode.bool, decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpTeles" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 7,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "CmpTeles"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(Json_decode.bool, decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "CmpTypes" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 5,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "CmpTypes"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(Json_decode.bool, decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "FindInstanceOF" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 15,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "FindInstanceOF"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(decode, Json_decode.string, (function (param) {
                                                    return Json_decode.array((function (param) {
                                                                  return Json_decode.pair(Json_decode.string, Json_decode.string, param);
                                                                }), param);
                                                  }), param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "Guard" :
            throw {
                  RE_EXN_ID: Json_decode.DecodeError,
                  _1: "[Agda.OutputConstraint] Guard decoding not implemented yet",
                  Error: new Error()
                };
        case "IsEmptyType" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (expr) {
                                      return {
                                              TAG: 13,
                                              _0: expr,
                                              [Symbol.for("name")]: "IsEmptyType"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "JustSort" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (name) {
                                      return {
                                              TAG: 2,
                                              _0: name,
                                              [Symbol.for("name")]: "JustSort"
                                            };
                                    }), decode, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "JustType" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (name) {
                                      return {
                                              TAG: 1,
                                              _0: name,
                                              [Symbol.for("name")]: "JustType"
                                            };
                                    }), decode, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "OfType" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 0,
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "OfType"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(decode, Json_decode.string, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "PTSInstance" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 16,
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "PTSInstance"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(decode, decode, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "PostponedCheckArgs" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 12,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              _3: param[3],
                                              [Symbol.for("name")]: "PostponedCheckArgs"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple4(decode, (function (param) {
                                                    return Json_decode.array(Json_decode.string, param);
                                                  }), Json_decode.string, Json_decode.string, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "PostponedCheckFunDef" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 17,
                                              _0: param[0],
                                              _1: param[1],
                                              [Symbol.for("name")]: "PostponedCheckFunDef"
                                            };
                                    }), (function (param) {
                                      return Json_decode.pair(Json_decode.string, Json_decode.string, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "SizeLtSat" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (expr) {
                                      return {
                                              TAG: 14,
                                              _0: expr,
                                              [Symbol.for("name")]: "SizeLtSat"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "TypedAssign" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (param) {
                                      return {
                                              TAG: 11,
                                              _0: param[0],
                                              _1: param[1],
                                              _2: param[2],
                                              [Symbol.for("name")]: "TypedAssign"
                                            };
                                    }), (function (param) {
                                      return Json_decode.tuple3(decode, Json_decode.string, Json_decode.string, param);
                                    }), param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[Agda.OutputConstraint] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var OutputConstraint = {
  parseOfType: parseOfType,
  parseJustType: parseJustType,
  parseJustSort: parseJustSort,
  parseOthers: parseOthers,
  parse: parse$1,
  toText: toText$4,
  decode: decode$2
};

function parseOutputWithoutLocation(raw) {
  return Belt_Option.map(Curry._1(parse$1, raw), (function (x) {
                return {
                        _0: x,
                        _1: undefined,
                        [Symbol.for("name")]: "Output"
                      };
              }));
}

var partial_arg$4 = /((?:\n|.)*\S+)\s*\[ at ([^\]]+) \]/;

function parseOutputWithLocation(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$4, (function (captured) {
                return Belt_Option.map(Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 1), (function (x) {
                                      return x;
                                    })), parse$1), (function (oc) {
                              var r = Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 2), (function (x) {
                                          return x;
                                        })), Common$AgdaModeVscode.AgdaRange.parse);
                              return {
                                      _0: oc,
                                      _1: r,
                                      [Symbol.for("name")]: "Output"
                                    };
                            }));
              }), param);
}

function parse$2(raw) {
  var locRe = /\[ at (\S+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+)) \]$/;
  var hasLocation = locRe.test(raw);
  if (hasLocation) {
    return Curry._1(parseOutputWithLocation, raw);
  } else {
    return parseOutputWithoutLocation(raw);
  }
}

function toText$5(value) {
  return toText$4(value._0, value._1);
}

var Output = {
  parseOutputWithoutLocation: parseOutputWithoutLocation,
  parseOutputWithLocation: parseOutputWithLocation,
  parse: parse$2,
  toText: toText$5
};

function make(indicesUTF16) {
  var indicesUTF8 = Belt_Array.mapWithIndex(indicesUTF16, (function (i, x) {
          return x - i | 0;
        }));
  var intervals = Belt_Array.mapWithIndex(indicesUTF8, (function (i, rightEndpoint) {
          var x = Belt_Array.get(indicesUTF8, i - 1 | 0);
          var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
          return [
                  leftEndpoint,
                  rightEndpoint
                ];
        }));
  var lastInterval = Belt_Option.mapWithDefault(Belt_Array.get(intervals, intervals.length - 1 | 0), 0, (function (param) {
          return param[1] + 1 | 0;
        }));
  return {
          intervals: intervals,
          lastInterval: lastInterval,
          cursor: 0
        };
}

function convert(self, index) {
  while(true) {
    var match = Belt_Array.get(self.intervals, self.cursor);
    if (match !== undefined) {
      if (index < match[0]) {
        self.cursor = 0;
        continue ;
      }
      if (index <= match[1]) {
        return index + self.cursor | 0;
      }
      self.cursor = self.cursor + 1 | 0;
      continue ;
    }
    if (index >= self.lastInterval) {
      return index + self.cursor | 0;
    }
    self.cursor = 0;
    continue ;
  };
}

function expose(self) {
  return [
          self.intervals,
          self.cursor
        ];
}

var Indices = {
  make: make,
  convert: convert,
  expose: expose
};

var characterWidth = (function (string) {return [...string].length});

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = text.charCodeAt(i) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = text.charCodeAt(i + 1 | 0) | 0;
      if (nextCharCode >= 56320 && charCode <= 57343) {
        surrogatePairs.push(i);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function computeCRLFIndices(text) {
  var regexp = /\r\n/g;
  var matchAll = (function (regexp, string) {
          let match;
          let result = [];
          while ((match = regexp.exec(string)) !== null) {
            result.push(match.index);
          }
          return result;
        });
  return matchAll(regexp, text);
}

function make$1(text) {
  return {
          utf16indices: make(computeUTF16SurrogatePairIndices(text)),
          eolIndices: make(computeCRLFIndices(text))
        };
}

function convert$1(self, offset) {
  var offset$1 = convert(self.utf16indices, offset);
  return convert(self.eolIndices, offset$1);
}

var OffsetConverter = {
  make: make$1,
  convert: convert$1,
  characterWidth: characterWidth,
  computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
  computeCRLFIndices: computeCRLFIndices
};

exports.Term = Term;
exports.Expr = Expr;
exports.NMII = NMII;
exports.Polarity = Polarity;
exports.OutputConstraint = OutputConstraint;
exports.Output = Output;
exports.Indices = Indices;
exports.OffsetConverter = OffsetConverter;
/* decode Not a pure module */
