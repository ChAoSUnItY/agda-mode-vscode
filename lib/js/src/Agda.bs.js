// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Common$AgdaModeVscode = require("./View/Common.bs.js");
var RichText$AgdaModeVscode = require("./View/Component/RichText.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./View/Panel/Emacs/Emacs__Parser.bs.js");

function render(x) {
  switch (x.TAG | 0) {
    case /* QuestionMark */1 :
        return RichText$AgdaModeVscode.hole(x._0);
    case /* Plain */0 :
    case /* Underscore */2 :
        return RichText$AgdaModeVscode.string(x._0);
    
  }
}

var Term = {
  render: render
};

function parse(raw) {
  var __x = raw.trim();
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(Js_string.splitByRe(/(\\?\\d+)|(\\_\\d+[^\\}\\)\\s]*)/, __x), (function (i, token) {
                    var match = i % 3;
                    if (match !== 1) {
                      if (match !== 2) {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 0,
                                              _0: x,
                                              [Symbol.for("name")]: "Plain"
                                            };
                                    }));
                      } else {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 2,
                                              _0: x,
                                              [Symbol.for("name")]: "Underscore"
                                            };
                                    }));
                      }
                    } else {
                      return Belt_Option.map(Belt_Option.flatMap(Belt_Option.map(token, (function (param) {
                                            return Js_string.sliceToEnd(1, param);
                                          })), Pervasives.int_of_string_opt), (function (x) {
                                    return {
                                            TAG: 1,
                                            _0: x,
                                            [Symbol.for("name")]: "QuestionMark"
                                          };
                                  }));
                    }
                  })), (function (x) {
                return x;
              }));
}

function render$1(xs) {
  return RichText$AgdaModeVscode.concatMany(Belt_Array.map(xs, render));
}

var Expr = {
  parse: parse,
  render: render$1
};

var partial_arg = /^([^\\:]*) \\: ((?:\n|.)+)/;

function parseOfType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg, (function (captured) {
                return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse), (function (type_) {
                              return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (term) {
                                            return {
                                                    TAG: 0,
                                                    _0: RichText$AgdaModeVscode.concatMany(Belt_Array.map(term, render)),
                                                    _1: RichText$AgdaModeVscode.concatMany(Belt_Array.map(type_, render)),
                                                    [Symbol.for("name")]: "OfType'"
                                                  };
                                          }));
                            }));
              }), param);
}

var partial_arg$1 = /^Type ((?:\\n|.)+)/;

function parseJustType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$1, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (type_) {
                              return {
                                      TAG: 1,
                                      _0: RichText$AgdaModeVscode.concatMany(Belt_Array.map(type_, render)),
                                      [Symbol.for("name")]: "JustType'"
                                    };
                            }));
              }), param);
}

var partial_arg$2 = /^Sort ((?:\\n|.)+)/;

function parseJustSort(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$2, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (sort) {
                              return {
                                      TAG: 2,
                                      _0: RichText$AgdaModeVscode.concatMany(Belt_Array.map(sort, render)),
                                      [Symbol.for("name")]: "JustSort'"
                                    };
                            }));
              }), param);
}

function parseOthers(raw) {
  return Belt_Option.map(parse(raw), (function (raw$p) {
                return {
                        TAG: 3,
                        _0: RichText$AgdaModeVscode.concatMany(Belt_Array.map(raw$p, render)),
                        [Symbol.for("name")]: "Others'"
                      };
              }));
}

var partial_arg$3 = [
  parseOfType,
  parseJustType,
  parseJustSort,
  parseOthers
];

function parse$1(param) {
  return Emacs__Parser$AgdaModeVscode.choice(partial_arg$3, param);
}

function renderItem(value, $$location) {
  var inlines;
  switch (value.TAG | 0) {
    case /* OfType' */0 :
        inlines = RichText$AgdaModeVscode.concatMany([
              value._0,
              RichText$AgdaModeVscode.string(" : "),
              value._1
            ]);
        break;
    case /* JustType' */1 :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Type "),
              value._0
            ]);
        break;
    case /* JustSort' */2 :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Sort "),
              value._0
            ]);
        break;
    case /* Others' */3 :
        inlines = RichText$AgdaModeVscode.concatMany([value._0]);
        break;
    
  }
  return {
          TAG: 1,
          _0: inlines,
          _1: undefined,
          _2: $$location,
          [Symbol.for("name")]: "Unlabeled"
        };
}

var OutputConstraint = {
  parse: parse$1,
  renderItem: renderItem
};

function parseOutputWithoutLocation(raw) {
  return Belt_Option.map(Curry._1(parse$1, raw), (function (x) {
                return {
                        _0: x,
                        _1: undefined,
                        [Symbol.for("name")]: "Output"
                      };
              }));
}

var partial_arg$4 = /((?:\\n|.)*\\S+)\\s*\[ at ([^\\]]+) \]/;

function parseOutputWithLocation(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$4, (function (captured) {
                return Belt_Option.map(Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 1), (function (x) {
                                      return x;
                                    })), parse$1), (function (oc) {
                              var r = Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 2), (function (x) {
                                          return x;
                                        })), Common$AgdaModeVscode.AgdaRange.parse);
                              return {
                                      _0: oc,
                                      _1: r,
                                      [Symbol.for("name")]: "Output"
                                    };
                            }));
              }), param);
}

function parse$2(raw) {
  var locRe = /\\[ at (\\S+\\:(?:\\d+\\,\\d+\\-\\d+\\,\\d+|\\d+\\,\\d+\\-\\d+)) \\]$/;
  var hasLocation = locRe.test(raw);
  if (hasLocation) {
    return Curry._1(parseOutputWithLocation, raw);
  } else {
    return parseOutputWithoutLocation(raw);
  }
}

function renderItem$1(value) {
  return renderItem(value._0, value._1);
}

var Output = {
  parseOutputWithoutLocation: parseOutputWithoutLocation,
  parseOutputWithLocation: parseOutputWithLocation,
  parse: parse$2,
  renderItem: renderItem$1
};

function make(indicesUTF16) {
  var indicesUTF8 = Belt_Array.mapWithIndex(indicesUTF16, (function (i, x) {
          return x - i | 0;
        }));
  var intervals = Belt_Array.mapWithIndex(indicesUTF8, (function (i, rightEndpoint) {
          var x = Belt_Array.get(indicesUTF8, i - 1 | 0);
          var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
          return [
                  leftEndpoint,
                  rightEndpoint
                ];
        }));
  var lastInterval = Belt_Option.mapWithDefault(Belt_Array.get(intervals, intervals.length - 1 | 0), 0, (function (param) {
          return param[1] + 1 | 0;
        }));
  return {
          intervals: intervals,
          lastInterval: lastInterval,
          cursor: 0
        };
}

function convert(self, index) {
  while(true) {
    var match = Belt_Array.get(self.intervals, self.cursor);
    if (match !== undefined) {
      if (index < match[0]) {
        self.cursor = 0;
        continue ;
      }
      if (index <= match[1]) {
        return index + self.cursor | 0;
      }
      self.cursor = self.cursor + 1 | 0;
      continue ;
    }
    if (index >= self.lastInterval) {
      return index + self.cursor | 0;
    }
    self.cursor = 0;
    continue ;
  };
}

function expose(self) {
  return [
          self.intervals,
          self.cursor
        ];
}

var Indices = {
  make: make,
  convert: convert,
  expose: expose
};

var characterWidth = (function (string) {return [...string].length});

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = Js_string.charCodeAt(i, text) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = Js_string.charCodeAt(i + 1 | 0, text) | 0;
      if (nextCharCode >= 56320 && charCode <= 57343) {
        Js_array.push(i, surrogatePairs);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function computeCRLFIndices(text) {
  var regexp = /\\r\\n/g;
  var matchAll = (function (regexp, string) {
          let match;
          let result = [];
          while ((match = regexp.exec(string)) !== null) {
            result.push(match.index);
          }
          return result;
        });
  return matchAll(regexp, text);
}

function make$1(text) {
  return {
          utf16indices: make(computeUTF16SurrogatePairIndices(text)),
          eolIndices: make(computeCRLFIndices(text))
        };
}

function convert$1(self, offset) {
  var offset$1 = convert(self.utf16indices, offset);
  return convert(self.eolIndices, offset$1);
}

var OffsetConverter = {
  make: make$1,
  convert: convert$1,
  characterWidth: characterWidth,
  computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
  computeCRLFIndices: computeCRLFIndices
};

exports.Term = Term;
exports.Expr = Expr;
exports.OutputConstraint = OutputConstraint;
exports.Output = Output;
exports.Indices = Indices;
exports.OffsetConverter = OffsetConverter;
/* Common-AgdaModeVscode Not a pure module */
