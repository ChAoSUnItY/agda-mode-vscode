// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Os = require("os");
var Caml = require("rescript/lib/js/caml.js");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Js_promise = require("rescript/lib/js/js_promise.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Promise$BsMocha = require("bs-mocha/lib/js/src/Promise.bs.js");
var Chan$AgdaModeVscode = require("../../src/Util/Chan.bs.js");
var Main$AgdaModeVscode = require("../../src/Main.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Source$LanguageServerMule = require("language-server-mule/lib/js/src/Source.bs.js");
var Connection__Error$AgdaModeVscode = require("../../src/Connection/Connection__Error.bs.js");
var Connection__Emacs__Error$AgdaModeVscode = require("../../src/Connection/Emacs/Connection__Emacs__Error.bs.js");

var Exn = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

var runner = (function(f) {
    var tmp
    try {
      var result = f();
      tmp = {
        TAG: 0,
        _0: result,
        [Symbol.for("name")]: "Ok"
      };
    }
    catch (raw_exn){
      tmp = 
        {
          TAG: 1,
          _0: raw_exn,
          [Symbol.for("name")]: "Error"
        };
    }
    return $$Promise.resolved(tmp);
  });

function toAbsolute(filepath) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, filepath);
  } else {
    return Process.cwd();
  }
}

function extensionPath(param) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, "../../../../");
  } else {
    return Process.cwd();
  }
}

function globalStoragePath(param) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, "../../../../test/globalStoragePath");
  } else {
    return Process.cwd();
  }
}

function asset(filepath) {
  return Path.join(extensionPath(undefined), "test/tests/assets", filepath);
}

var Path$1 = {
  toAbsolute: toAbsolute,
  extensionPath: extensionPath,
  globalStoragePath: globalStoragePath,
  asset: asset
};

var activationSingleton = {
  contents: undefined
};

function activateExtension(param) {
  var channels = activationSingleton.contents;
  if (channels !== undefined) {
    return channels;
  }
  var disposables = [];
  var extensionPath$1 = extensionPath(undefined);
  var globalStoragePath$1 = globalStoragePath(undefined);
  var channels$1 = Main$AgdaModeVscode.activateWithoutContext(disposables, extensionPath$1, globalStoragePath$1);
  activationSingleton.contents = channels$1;
  return channels$1;
}

function openFile(fileName) {
  return Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
}

function activateExtensionAndOpenFile(fileName) {
  var channels = activateExtension(undefined);
  return $$Promise.map(Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined), (function (editor) {
                return [
                        editor,
                        channels
                      ];
              }));
}

function wait(ms) {
  var match = $$Promise.pending(undefined);
  setTimeout(match[1], ms);
  return match[0];
}

function toPromise(f) {
  return new Promise((function (resolve, reject) {
                $$Promise.get(f, (function (x) {
                        if (x.TAG === /* Ok */0) {
                          return resolve(x._0);
                        } else {
                          return reject(x._0);
                        }
                      }));
              }));
}

function it(s, f) {
  Promise$BsMocha.it(s)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function it_only(s, f) {
  Promise$BsMocha.it_only(s)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function it_skip(s, f) {
  Promise$BsMocha.it_skip(s)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function before(f) {
  Promise$BsMocha.before(undefined)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function before_each(f) {
  Promise$BsMocha.before_each(undefined)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function after(f) {
  Promise$BsMocha.after(undefined)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

function after_each(f) {
  Promise$BsMocha.after_each(undefined)(undefined, undefined, undefined, (function (param) {
          return toPromise(Curry._1(f, undefined));
        }));
}

var Q = {
  toPromise: toPromise,
  it: it,
  it_only: it_only,
  it_skip: it_skip,
  before: before,
  before_each: before_each,
  after: after,
  after_each: after_each
};

function equal(expected, actual) {
  return runner(function (param) {
              Assert$BsMocha.equal(undefined, actual, expected);
            });
}

function deep_equal(expected, actual) {
  return runner(function (param) {
              Assert$BsMocha.deep_equal(undefined, actual, expected);
            });
}

function deep_strict_equal(expected, actual) {
  return runner(function (param) {
              Assert$BsMocha.deep_strict_equal(undefined, actual, expected);
            });
}

function fail(value) {
  return runner(function (param) {
              Assert$BsMocha.fail(value);
            });
}

var A = {
  equal: equal,
  deep_equal: deep_equal,
  deep_strict_equal: deep_strict_equal,
  fail: fail
};

function normalize(string) {
  return Js_string.replaceByRe(/\r\n|\n/g, "\n", string.trim());
}

function unlines(xs) {
  return Js_array.joinWith("\n", xs);
}

function unlinesWith(f, xs) {
  return Js_array.joinWith("\n", Belt_Array.map(xs, f));
}

function breakInput(input, breakpoints) {
  var breakpoints$p = Belt_Array.concat([0], breakpoints);
  return Belt_Array.map(Belt_Array.mapWithIndex(breakpoints$p, (function (i, x) {
                    var next = Belt_Array.get(breakpoints$p, i + 1 | 0);
                    if (next !== undefined) {
                      return [
                              x,
                              next - x | 0
                            ];
                    } else {
                      return [
                              x,
                              input.length - x | 0
                            ];
                    }
                  })), (function (param) {
                return Js_string.substrAtMost(param[0], param[1], input);
              }));
}

var Strings = {
  normalize: normalize,
  unlines: unlines,
  unlinesWith: unlinesWith,
  breakInput: breakInput
};

function getValue(x) {
  return x._0;
}

function fromChangeObject(obj) {
  if (obj.added) {
    return {
            TAG: 0,
            _0: obj.value,
            [Symbol.for("name")]: "Added"
          };
  } else if (obj.removed) {
    return {
            TAG: 1,
            _0: obj.value,
            [Symbol.for("name")]: "Removed"
          };
  } else {
    return {
            TAG: 2,
            _0: obj.value,
            [Symbol.for("name")]: "NoChange"
          };
  }
}

function wordsWithSpace(a, b) {
  return Belt_Array.map(Diff.diffWordsWithSpace(a, b), fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  Belt_Array.forEach(diffs, (function (diff) {
          if (!Belt_Option.isNone(change.contents)) {
            return ;
          }
          switch (diff.TAG | 0) {
            case /* Added */0 :
                change.contents = {
                  TAG: 0,
                  _0: diff._0,
                  [Symbol.for("name")]: "Added"
                };
                return ;
            case /* Removed */1 :
                change.contents = {
                  TAG: 1,
                  _0: diff._0,
                  [Symbol.for("name")]: "Removed"
                };
                return ;
            case /* NoChange */2 :
                count.contents = count.contents + diff._0.length | 0;
                return ;
            
          }
        }));
  return Belt_Option.map(change.contents, (function (change) {
                return [
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var readdir = Util.promisify(function (prim0, prim1) {
        Fs.readdir(prim0, prim1);
      });
  var isInFile = function (param) {
    return Js_string.endsWith(".in", param);
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return Js_promise.then_((function (paths) {
                return Promise.resolve(Belt_Array.map(Belt_Array.keep(paths, isInFile), toBasename));
              }), readdir(directoryPath$1));
}

function getGoldenFilepathsSync(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var isInFile = function (param) {
    return Js_string.endsWith(".in", param);
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return Belt_Array.map(Belt_Array.keep(Fs.readdirSync(directoryPath$1), isInFile), toBasename);
}

var FileMissing = /* @__PURE__ */Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function map(param, f) {
  return {
          _0: param._0,
          _1: Curry._1(f, param._1),
          _2: param._2,
          [Symbol.for("name")]: "Golden"
        };
}

function readFile(filepath) {
  var filepath$1 = toAbsolute(filepath);
  var readFile$1 = Util.promisify(function (prim0, prim1) {
        Fs.readFile(prim0, prim1);
      });
  return Js_promise.then_((function (x) {
                if (x.length !== 2) {
                  return Promise.reject({
                              RE_EXN_ID: FileMissing,
                              _1: filepath$1
                            });
                }
                var input = x[0];
                var output = x[1];
                return Promise.resolve({
                            _0: filepath$1,
                            _1: input.toString(),
                            _2: normalize(output.toString()),
                            [Symbol.for("name")]: "Golden"
                          });
              }), Promise.all([
                  readFile$1(filepath$1 + ".in"),
                  readFile$1(filepath$1 + ".out")
                ]));
}

function compare(param) {
  var actual = normalize(param._1);
  var expected = normalize(param._2);
  Belt_Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff._0;
          var expected$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, expected);
          var actual$1 = Js_string.substrAtMost(Caml.int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0, actual);
          switch (diff.TAG | 0) {
            case /* Added */0 :
            case /* Removed */1 :
                return Assert$BsMocha.fail$p(undefined, undefined, undefined, actual$1, expected$1);
            case /* NoChange */2 :
                return ;
            
          }
        }));
  return Promise.resolve(undefined);
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  map: map,
  readFile: readFile,
  compare: compare
};

var match = Os.type();

var onUnix = match === "Windows_NT" ? false : true;

function toString(x) {
  if (x.TAG === /* LanguageServerMuleErrors */0) {
    return Js_array.joinWith(",", Belt_Array.map(x._0, Source$LanguageServerMule.$$Error.toString));
  }
  var match = Connection__Emacs__Error$AgdaModeVscode.toString(x._0);
  return "EmacsConnectionError: " + match[0] + ": " + match[1];
}

var $$Error = {
  toString: toString
};

function exists(command) {
  return $$Promise.flatMapError($$Promise.flatMap(Source$LanguageServerMule.Module.searchUntilSuccess([{
                        TAG: 1,
                        _0: command,
                        [Symbol.for("name")]: "FromCommand"
                      }]), (function (param) {
                    if (param[0] !== undefined) {
                      return $$Promise.resolved({
                                  TAG: 0,
                                  _0: undefined,
                                  [Symbol.for("name")]: "Ok"
                                });
                    } else {
                      return $$Promise.resolved({
                                  TAG: 1,
                                  _0: param[1],
                                  [Symbol.for("name")]: "Error"
                                });
                    }
                  })), (function (errors) {
                var msg = Js_array.joinWith(",", Belt_Array.map(errors, Source$LanguageServerMule.$$Error.toString));
                var value = "Cannot find \"Agda\" in PATH: " + msg;
                return runner(function (param) {
                            Assert$BsMocha.fail(value);
                          });
              }));
}

function make(alsOpt, filepath) {
  var als = alsOpt !== undefined ? alsOpt : false;
  var filepath$1 = asset(filepath);
  Config$AgdaModeVscode.inTestingMode.contents = true;
  return $$Promise.map($$Promise.flatMap($$Promise.flatMap(Config$AgdaModeVscode.Connection.setAgdaVersion("agda"), (function (param) {
                        return Config$AgdaModeVscode.Connection.setUseAgdaLanguageServer(als);
                      })), (function (param) {
                    return exists("agda");
                  })), (function (param) {
                return {
                        filepath: filepath$1,
                        channels: activateExtension(undefined)
                      };
              }));
}

function load(self) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var promise = match[0];
  var disposable = Chan$AgdaModeVscode.on(self.channels.responseHandled, (function (response) {
          if (typeof response === "number" && response >= 4) {
            return Curry._1(resolve, undefined);
          }
          
        }));
  return $$Promise.flatMap($$Promise.flatMap(Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined), (function (param) {
                    return Vscode.commands.executeCommand("agda-mode.load");
                  })), (function (result) {
                if (result !== undefined) {
                  if (result.TAG === /* Ok */0) {
                    var state = result._0;
                    return $$Promise.map(promise, (function (param) {
                                  Curry._1(disposable, undefined);
                                  return {
                                          TAG: 0,
                                          _0: [
                                            self,
                                            state
                                          ],
                                          [Symbol.for("name")]: "Ok"
                                        };
                                }));
                  }
                  var match = Connection__Error$AgdaModeVscode.toString(result._0);
                  var value = match[0] + "\n" + match[1];
                  return runner(function (param) {
                              Assert$BsMocha.fail(value);
                            });
                }
                var value$1 = "Cannot load " + self.filepath;
                return runner(function (param) {
                            Assert$BsMocha.fail(value$1);
                          });
              }));
}

function $$case(cursorAndPayload, param) {
  var state = param[1];
  var self = param[0];
  return $$Promise.flatMap($$Promise.flatMap($$Promise.flatMap(Vscode.window.showTextDocument(Vscode.Uri.file(self.filepath), undefined), (function (editor) {
                        if (cursorAndPayload === undefined) {
                          return $$Promise.resolved(false);
                        }
                        var cursor = cursorAndPayload[0];
                        return $$Promise.tap(Editor$AgdaModeVscode.$$Text.insert(state.document, cursor, cursorAndPayload[1]), (function (param) {
                                      Editor$AgdaModeVscode.Cursor.set(editor, cursor);
                                    }));
                      })), (function (param) {
                    return Vscode.commands.executeCommand("agda-mode.case");
                  })), (function (result) {
                if (result !== undefined) {
                  if (result.TAG === /* Ok */0) {
                    return $$Promise.resolved({
                                TAG: 0,
                                _0: [
                                  self,
                                  result._0
                                ],
                                [Symbol.for("name")]: "Ok"
                              });
                  }
                  var match = Connection__Error$AgdaModeVscode.toString(result._0);
                  var value = match[0] + "\n" + match[1];
                  return runner(function (param) {
                              Assert$BsMocha.fail(value);
                            });
                }
                var value$1 = "Cannot case split " + self.filepath;
                return runner(function (param) {
                            Assert$BsMocha.fail(value$1);
                          });
              }));
}

var Agda = {
  $$Error: $$Error,
  exists: exists,
  make: make,
  load: load,
  $$case: $$case
};

function readFile$1(filepath, $$var) {
  return $$Promise.map(Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined), (function (editor) {
                $$var.contents = Editor$AgdaModeVscode.$$Text.getAll(editor.document);
                return {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function restoreFile(filepath, $$var) {
  return $$Promise.map($$Promise.flatMap(Vscode.window.showTextDocument(Vscode.Uri.file(filepath), undefined), (function (editor) {
                    var $$document = editor.document;
                    var lineCount = $$document.lineCount;
                    var replaceRange = new Vscode.Range(new Vscode.Position(0, 0), new Vscode.Position(lineCount, 0));
                    return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace($$document, replaceRange, $$var.contents), (function (param) {
                                  return $$document.save();
                                }));
                  })), (function (param) {
                return {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

var Assert;

exports.Assert = Assert;
exports.Exn = Exn;
exports.runner = runner;
exports.Path = Path$1;
exports.activationSingleton = activationSingleton;
exports.activateExtension = activateExtension;
exports.openFile = openFile;
exports.activateExtensionAndOpenFile = activateExtensionAndOpenFile;
exports.wait = wait;
exports.Q = Q;
exports.A = A;
exports.Strings = Strings;
exports.Golden = Golden;
exports.onUnix = onUnix;
exports.Agda = Agda;
exports.readFile = readFile$1;
exports.restoreFile = restoreFile;
/* match Not a pure module */
