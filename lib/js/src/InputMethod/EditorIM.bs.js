// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");

function log(param) {
  
}

function make(editor, range) {
  var $$document = editor.document;
  var start = $$document.positionAt(range[0]);
  var end_ = $$document.positionAt(range[1]);
  return {
          range: range,
          decoration: [Editor$AgdaModeVscode.Decoration.underlineText(editor, new Vscode.Range(start, end_))],
          buffer: Buffer$AgdaModeVscode.make(undefined)
        };
}

function withIn(instance, offset) {
  var match = instance.range;
  if (match[0] <= offset) {
    return offset <= match[1];
  } else {
    return false;
  }
}

function redocorate(instance, editor) {
  Belt_Array.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
  instance.decoration = [];
  var $$document = editor.document;
  var match = instance.range;
  var start = $$document.positionAt(match[0]);
  var end_ = $$document.positionAt(match[1]);
  var range = new Vscode.Range(start, end_);
  instance.decoration = [Editor$AgdaModeVscode.Decoration.underlineText(editor, range)];
  
}

function destroy(instance) {
  Belt_Array.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
  instance.decoration = [];
  
}

var Instance = {
  make: make,
  withIn: withIn,
  redocorate: redocorate,
  destroy: destroy
};

function fromContentChangeEvent(change) {
  return {
          offset: change.rangeOffset,
          insertedText: change.text,
          replacedTextLength: change.rangeLength
        };
}

function checkCursorPositions(self, $$document, points) {
  var offsets = Belt_Array.map(points, (function (param) {
          return $$document.offsetAt(param);
        }));
  log("\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                    return String(prim);
                  }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, (function (i) {
                      return "(" + (String(i.range[0]) + (", " + (String(i.range[1]) + ")")));
                    }))))));
  self.instances = Belt_Array.keep(self.instances, (function (instance) {
          var survived = Belt_Array.some(offsets, (function (param) {
                  return withIn(instance, param);
                }));
          if (!survived) {
            destroy(instance);
          }
          return survived;
        }));
  self.cursorsToBeChecked = undefined;
  if (self.instances.length === 0) {
    Curry._1(self.eventEmitter.emit, /* Deactivate */1);
    return Curry._1(self.eventEmitterTest.emit, /* Deactivate */2);
  }
  
}

function updateView(self) {
  return Belt_Option.forEach(Belt_Array.get(self.instances, 0), (function (instance) {
                return Curry._1(self.eventEmitter.emit, {
                            TAG: 1,
                            _0: Buffer$AgdaModeVscode.toSequence(instance.buffer),
                            _1: instance.buffer.translation,
                            _2: instance.buffer.candidateIndex,
                            [Symbol.for("name")]: "Update"
                          });
              }));
}

function toRewrites(instances, f) {
  var accum = {
    contents: 0
  };
  return Belt_Array.keepMap(instances, (function (instance) {
                var match = instance.range;
                var end_ = match[1];
                var start = match[0];
                instance.range = [
                  start + accum.contents | 0,
                  end_ + accum.contents | 0
                ];
                return Belt_Option.map(Curry._1(f, instance), (function (replacement) {
                              var delta = replacement.length - (end_ - start | 0) | 0;
                              accum.contents = accum.contents + delta | 0;
                              return {
                                      rangeBefore: instance.range,
                                      rangeAfter: [
                                        instance.range[0],
                                        instance.range[1] + delta | 0
                                      ],
                                      text: replacement,
                                      instance: instance
                                    };
                            }));
              }));
}

function applyRewrites(self, editor, rewrites) {
  var $$document = editor.document;
  self.busy = true;
  return $$Promise.get(Util$AgdaModeVscode.oneByOne(Belt_Array.map(rewrites, (function (param, param$1) {
                        var instance = param.instance;
                        var text = param.text;
                        var rangeAfter = param.rangeAfter;
                        var rangeBefore = param.rangeBefore;
                        var editorRange = new Vscode.Range($$document.positionAt(rangeBefore[0]), $$document.positionAt(rangeBefore[1]));
                        return $$Promise.map($$Promise.flatMap(Editor$AgdaModeVscode.$$Text.$$delete($$document, editorRange), (function (param) {
                                          return Editor$AgdaModeVscode.$$Text.insert($$document, editorRange.start, text);
                                        })), (function (param) {
                                      if (instance !== undefined) {
                                        instance.range = rangeAfter;
                                        return redocorate(instance, editor);
                                      }
                                      
                                    }));
                      }))), (function (param) {
                Curry._1(self.eventEmitterTest.emit, /* Change */0);
                self.busy = false;
                var points = self.cursorsToBeChecked;
                if (points !== undefined) {
                  return checkCursorPositions(self, $$document, points);
                }
                
              }));
}

function updateInstanceOffsets(instances, changes) {
  var changes$1 = changes.sort(function (x, y) {
        return Caml_primitive.caml_int_compare(x.offset, y.offset);
      });
  var go = function (_accum, _param) {
    while(true) {
      var param = _param;
      var accum = _accum;
      var match = param[0];
      if (match) {
        var match$1 = param[1];
        if (!match$1) {
          return /* [] */0;
        }
        var is = match$1.tl;
        var instance = match$1.hd;
        var cs = match.tl;
        var change = match.hd;
        var match$2 = instance.range;
        var end_ = match$2[1];
        var start = match$2[0];
        var delta = change.insertedText.length - change.replacedTextLength | 0;
        if (withIn(instance, change.offset)) {
          instance.range = [
            accum + start | 0,
            (accum + end_ | 0) + delta | 0
          ];
          return {
                  hd: [
                    instance,
                    {
                      offset: change.offset + accum | 0,
                      insertedText: change.insertedText,
                      replacedTextLength: change.replacedTextLength
                    }
                  ],
                  tl: go(accum + delta | 0, [
                        cs,
                        is
                      ])
                };
        }
        if (change.offset < instance.range[0]) {
          _param = [
            cs,
            {
              hd: instance,
              tl: is
            }
          ];
          _accum = accum + delta | 0;
          continue ;
        }
        instance.range = [
          accum + start | 0,
          accum + end_ | 0
        ];
        return {
                hd: [
                  instance,
                  undefined
                ],
                tl: go(accum, [
                      {
                        hd: change,
                        tl: cs
                      },
                      is
                    ])
              };
      }
      var match$3 = param[1];
      if (match$3) {
        return Belt_List.map({
                    hd: match$3.hd,
                    tl: match$3.tl
                  }, (function (i) {
                      return [
                              i,
                              undefined
                            ];
                    }));
      } else {
        return /* [] */0;
      }
    };
  };
  var instancesWithChanges = Belt_List.toArray(go(0, [
            Belt_List.fromArray(changes$1),
            Belt_List.fromArray(instances)
          ]));
  var rewrites = [];
  var accum = {
    contents: 0
  };
  var instances$1 = Belt_Array.keepMap(instancesWithChanges, (function (param) {
          var change = param[1];
          var instance = param[0];
          if (change === undefined) {
            return instance;
          }
          var match = Buffer$AgdaModeVscode.update(instance.buffer, instance.range[0], change);
          var buffer = match[0];
          Belt_Option.forEach(match[1], (function (text) {
                  var match = instance.range;
                  var end_ = match[1];
                  var start = match[0];
                  var delta = text.length - (end_ - start | 0) | 0;
                  rewrites.push({
                        rangeBefore: [
                          start + accum.contents | 0,
                          end_ + accum.contents | 0
                        ],
                        rangeAfter: [
                          start + accum.contents | 0,
                          (end_ + accum.contents | 0) + delta | 0
                        ],
                        text: text,
                        instance: buffer.translation.further ? instance : undefined
                      });
                  accum.contents = accum.contents + delta | 0;
                  
                }));
          if (buffer.translation.further) {
            instance.buffer = buffer;
            return instance;
          } else {
            destroy(instance);
            return ;
          }
        }));
  return [
          instances$1,
          rewrites
        ];
}

function activate(self, editor, ranges) {
  self.activated = true;
  Curry._1(self.eventEmitterTest.emit, /* Activate */1);
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", true);
  self.instances = Belt_Array.map(ranges.sort(function (x, y) {
            return Caml_primitive.caml_int_compare(x[0], y[0]);
          }), (function (param) {
          return make(editor, param);
        }));
  self.handles.push(Vscode.window.onDidChangeTextEditorSelection(function ($$event) {
            var points = Belt_Array.map($$event.selections, (function (prim) {
                    return prim.anchor;
                  }));
            if (self.busy) {
              self.cursorsToBeChecked = points;
              return ;
            } else {
              return checkCursorPositions(self, editor.document, points);
            }
          }));
  self.handles.push(Vscode.workspace.onDidChangeTextDocument(function ($$event) {
            var changes = $$event.contentChanges;
            if (!(!self.busy && changes.length !== 0)) {
              return ;
            }
            var changes$1 = Belt_Array.map(changes, fromContentChangeEvent);
            var match = updateInstanceOffsets(self.instances, changes$1);
            self.instances = match[0];
            applyRewrites(self, editor, match[1]);
            return updateView(self);
          }));
  
}

function deactivate(self) {
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", false);
  Curry._1(self.eventEmitterTest.emit, /* Deactivate */2);
  Belt_Array.forEach(self.instances, destroy);
  self.instances = [];
  self.activated = false;
  self.cursorsToBeChecked = undefined;
  self.busy = false;
  Belt_Array.forEach(self.handles, (function (prim) {
          return prim.dispose();
        }));
  self.handles = [];
  
}

function make$1(eventEmitterTest) {
  return {
          instances: [],
          activated: false,
          cursorsToBeChecked: undefined,
          busy: false,
          handles: [],
          eventEmitter: Event$AgdaModeVscode.make(undefined),
          eventEmitterTest: eventEmitterTest
        };
}

function moveUp(self, editor) {
  var rewrites = toRewrites(self.instances, (function (instance) {
          instance.buffer = Buffer$AgdaModeVscode.moveUp(instance.buffer);
          return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
        }));
  applyRewrites(self, editor, rewrites);
  return updateView(self);
}

function moveRight(self, editor) {
  var rewrites = toRewrites(self.instances, (function (instance) {
          instance.buffer = Buffer$AgdaModeVscode.moveRight(instance.buffer);
          return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
        }));
  applyRewrites(self, editor, rewrites);
  return updateView(self);
}

function moveDown(self, editor) {
  var rewrites = toRewrites(self.instances, (function (instance) {
          instance.buffer = Buffer$AgdaModeVscode.moveDown(instance.buffer);
          return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
        }));
  applyRewrites(self, editor, rewrites);
  return updateView(self);
}

function moveLeft(self, editor) {
  var rewrites = toRewrites(self.instances, (function (instance) {
          instance.buffer = Buffer$AgdaModeVscode.moveLeft(instance.buffer);
          return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
        }));
  applyRewrites(self, editor, rewrites);
  return updateView(self);
}

function chooseSymbol(self, editor, symbol) {
  var rewrites = toRewrites(self.instances, (function (param) {
          return symbol;
        }));
  applyRewrites(self, editor, rewrites);
  return updateView(self);
}

function insertBackslash(editor) {
  return Belt_Array.forEach(Editor$AgdaModeVscode.Cursor.getMany(editor), (function (point) {
                Editor$AgdaModeVscode.$$Text.insert(editor.document, point, "\\");
                
              }));
}

function insertChar(editor, $$char) {
  var $$char$1 = $$char.charAt(0);
  return Belt_Array.forEach(Editor$AgdaModeVscode.Cursor.getMany(editor), (function (point) {
                Editor$AgdaModeVscode.$$Text.insert(editor.document, point, $$char$1);
                
              }));
}

var printLog = false;

exports.printLog = printLog;
exports.log = log;
exports.Instance = Instance;
exports.fromContentChangeEvent = fromContentChangeEvent;
exports.checkCursorPositions = checkCursorPositions;
exports.updateView = updateView;
exports.toRewrites = toRewrites;
exports.applyRewrites = applyRewrites;
exports.updateInstanceOffsets = updateInstanceOffsets;
exports.activate = activate;
exports.deactivate = deactivate;
exports.make = make$1;
exports.moveUp = moveUp;
exports.moveRight = moveRight;
exports.moveDown = moveDown;
exports.moveLeft = moveLeft;
exports.chooseSymbol = chooseSymbol;
exports.insertBackslash = insertBackslash;
exports.insertChar = insertChar;
/* vscode Not a pure module */
