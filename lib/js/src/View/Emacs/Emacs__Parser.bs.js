// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var View$AgdaModeVscode = require("../../View.bs.js");
var Component$AgdaModeVscode = require("../Component/Component.bs.js");

function partite(xs, tagEntry) {
  var keys = Belt_Array.keepMap(Belt_Array.mapWithIndex(xs, (function (i, x) {
              return /* tuple */[
                      i,
                      x
                    ];
            })), (function (param) {
          var i = param[0];
          return Belt_Option.map(Curry._1(tagEntry, /* tuple */[
                          param[1],
                          i
                        ]), (function (key) {
                        return /* tuple */[
                                key,
                                i
                              ];
                      }));
        }));
  var intervals = Belt_Array.mapWithIndex(keys, (function (n, param) {
          var index = param[1];
          var key = param[0];
          var match = Belt_Array.get(keys, n + 1 | 0);
          if (match !== undefined) {
            return /* tuple */[
                    key,
                    index,
                    match[1]
                  ];
          } else {
            return /* tuple */[
                    key,
                    index,
                    xs.length
                  ];
          }
        }));
  return Js_dict.fromArray(Belt_Array.map(intervals, (function (param) {
                    var start = param[1];
                    var func = function (param, param$1) {
                      return param$1.slice(start, param);
                    };
                    return /* tuple */[
                            param[0],
                            Curry._2(func, param[2], xs)
                          ];
                  })));
}

function split(dict, key, splitter) {
  var value = Js_dict.get(dict, key);
  if (value !== undefined) {
    Belt_Array.forEach(Js_dict.entries(Curry._1(splitter, value)), (function (param) {
            dict[param[0]] = param[1];
            
          }));
    return dict;
  } else {
    return dict;
  }
}

function update(dict, key, f) {
  var value = Js_dict.get(dict, key);
  if (value !== undefined) {
    dict[key] = Curry._1(f, Caml_option.valFromOption(value));
    return dict;
  } else {
    return dict;
  }
}

var Dict = {
  partite: partite,
  split: split,
  update: update
};

function partite$1(xs, p) {
  var indices = Belt_Array.map(Belt_Array.keep(Belt_Array.mapWithIndex(xs, (function (i, x) {
                  return /* tuple */[
                          i,
                          x
                        ];
                })), (function (param) {
              return Curry._1(p, param[1]);
            })), (function (prim) {
          return prim[0];
        }));
  var n = Belt_Array.get(indices, 0);
  var indicesWF = n !== undefined ? (
      n === 0 ? indices : Belt_Array.concat(indices, [0])
    ) : (
      indices.length === 0 ? [0] : indices
    );
  var intervals = Belt_Array.mapWithIndex(indicesWF, (function (n, index) {
          var next = Belt_Array.get(indicesWF, n + 1 | 0);
          if (next !== undefined) {
            return /* tuple */[
                    index,
                    next
                  ];
          } else {
            return /* tuple */[
                    index,
                    xs.length
                  ];
          }
        }));
  return Belt_Array.map(intervals, (function (param) {
                return xs.slice(param[0], param[1]);
              }));
}

function mergeWithNext(xs, p) {
  return Belt_Array.reduce(xs, [], (function (acc, x) {
                var last = Belt_Array.get(acc, acc.length - 1 | 0);
                if (last !== undefined) {
                  if (Curry._1(p, last)) {
                    Belt_Array.set(acc, acc.length - 1 | 0, Belt_Array.concat(x, last));
                    return acc;
                  } else {
                    return Belt_Array.concat([x], acc);
                  }
                } else {
                  return [x];
                }
              }));
}

var Array_ = {
  partite: partite$1,
  mergeWithNext: mergeWithNext
};

function unindent(lines) {
  var newLineIndices = Belt_Array.map(Belt_Array.keep(Belt_Array.mapWithIndex(lines, (function (index, line) {
                  return /* tuple */[
                          line,
                          Belt_Array.get(lines, index + 1 | 0),
                          index
                        ];
                })), (function (param) {
              var line = param[0];
              var nextLine = param[1];
              var sort = /^Sort \S*/;
              var delimeter = /^\u2014{4}/g;
              var completeJudgement = /^(?:(?:[^\(\{\s]+\s+\:=?)|Have\:|Goal\:)\s* \S*/;
              var reallyLongTermIdentifier = /^\S+$/;
              var restOfTheJudgement = /^\s*\:=?\s* \S*/;
              if (sort.test(line) || delimeter.test(line) || reallyLongTermIdentifier.test(line) && Belt_Option.mapWithDefault(nextLine, false, (function (line) {
                        return restOfTheJudgement.test(line);
                      }))) {
                return true;
              } else {
                return completeJudgement.test(line);
              }
            })), (function (param) {
          return param[2];
        }));
  return Belt_Array.map(Belt_Array.mapWithIndex(newLineIndices, (function (i, index) {
                    var n = Belt_Array.get(newLineIndices, i + 1 | 0);
                    if (n !== undefined) {
                      return /* tuple */[
                              index,
                              n
                            ];
                    } else {
                      return /* tuple */[
                              index,
                              lines.length + 1 | 0
                            ];
                    }
                  })), (function (param) {
                return lines.slice(param[0], param[1]).join("\n");
              }));
}

function partiteMetas(xs) {
  return split(xs, "metas", (function (rawMetas) {
                var metas = unindent(rawMetas);
                var indexOfHiddenMetas = Belt_Array.getIndexBy(metas, (function (s) {
                        return Belt_Option.isSome(Curry._1(Component$AgdaModeVscode.Output.parseOutputWithRange, s));
                      }));
                return partite(metas, (function (param) {
                              var i = param[1];
                              if (indexOfHiddenMetas !== undefined) {
                                if (i === indexOfHiddenMetas) {
                                  return "hiddenMetas";
                                } else if (i === 0) {
                                  return "interactionMetas";
                                } else {
                                  return ;
                                }
                              } else if (i === 0) {
                                return "interactionMetas";
                              } else {
                                return ;
                              }
                            }));
              }));
}

function partiteWarningsOrErrors(xs, key) {
  return update(xs, key, (function (raw) {
                var partial_arg = /^\u2014{4}/;
                var hasDelimeter = Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(raw, 0), (function (param) {
                            return Caml_option.null_to_opt(param.match(partial_arg));
                          })));
                var lines = hasDelimeter ? raw.slice(1) : raw;
                var markWarningStart = function (line) {
                  return Belt_Option.isSome(Curry._1(View$AgdaModeVscode.$$Range.parse, line));
                };
                var glueBack = function (xs) {
                  var partial_arg = /at$/;
                  return Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(xs, xs.length - 1 | 0), (function (param) {
                                    return Caml_option.null_to_opt(param.match(partial_arg));
                                  })));
                };
                return Belt_Array.map(mergeWithNext(partite$1(lines, markWarningStart), glueBack), (function (param) {
                              return param.join("\n");
                            }));
              }));
}

exports.Dict = Dict;
exports.Array_ = Array_;
exports.unindent = unindent;
exports.partiteMetas = partiteMetas;
exports.partiteWarningsOrErrors = partiteWarningsOrErrors;
/* View-AgdaModeVscode Not a pure module */
