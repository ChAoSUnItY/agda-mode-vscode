// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function toString(x) {
  switch (x) {
    case /* Comment */0 :
        return "Comment";
    case /* Keyword */1 :
        return "Keyword";
    case /* String */2 :
        return "String";
    case /* Number */3 :
        return "Number";
    case /* Symbol */4 :
        return "Symbol";
    case /* PrimitiveType */5 :
        return "PrimitiveType";
    case /* Pragma */6 :
        return "Pragma";
    case /* Background */7 :
        return "Background";
    case /* Markup */8 :
        return "Markup";
    case /* Error */9 :
        return "Error";
    case /* DottedPattern */10 :
        return "DottedPattern";
    case /* UnsolvedMeta */11 :
        return "UnsolvedMeta";
    case /* UnsolvedConstraint */12 :
        return "UnsolvedConstraint";
    case /* TerminationProblem */13 :
        return "TerminationProblem";
    case /* PositivityProblem */14 :
        return "PositivityProblem";
    case /* Deadcode */15 :
        return "Deadcode";
    case /* CoverageProblem */16 :
        return "CoverageProblem";
    case /* IncompletePattern */17 :
        return "IncompletePattern";
    case /* TypeChecks */18 :
        return "TypeChecks";
    case /* CatchallClause */19 :
        return "CatchallClause";
    case /* ConfluenceProblem */20 :
        return "ConfluenceProblem";
    case /* Bound */21 :
        return "Bound";
    case /* Generalizable */22 :
        return "Generalizable";
    case /* ConstructorInductive */23 :
        return "ConstructorInductive";
    case /* ConstructorCoInductive */24 :
        return "ConstructorCoInductive";
    case /* Datatype */25 :
        return "Datatype";
    case /* Field */26 :
        return "Field";
    case /* Function */27 :
        return "Function";
    case /* Module */28 :
        return "Module";
    case /* Postulate */29 :
        return "Postulate";
    case /* Primitive */30 :
        return "Primitive";
    case /* Record */31 :
        return "Record";
    case /* Argument */32 :
        return "Argument";
    case /* Macro */33 :
        return "Macro";
    case /* Operator */34 :
        return "Operator";
    
  }
}

function parse(x) {
  switch (x) {
    case "argument" :
        return /* Argument */32;
    case "background" :
        return /* Background */7;
    case "bound" :
        return /* Bound */21;
    case "catchallclause" :
        return /* CatchallClause */19;
    case "coinductiveconstructor" :
        return /* ConstructorCoInductive */24;
    case "comment" :
        return /* Comment */0;
    case "confluenceproblem" :
        return /* ConfluenceProblem */20;
    case "coverageproblem" :
        return /* CoverageProblem */16;
    case "datatype" :
        return /* Datatype */25;
    case "deadcode" :
        return /* Deadcode */15;
    case "dottedpattern" :
        return /* DottedPattern */10;
    case "error" :
        return /* Error */9;
    case "field" :
        return /* Field */26;
    case "function" :
        return /* Function */27;
    case "generalizable" :
        return /* Generalizable */22;
    case "incompletepattern" :
        return /* IncompletePattern */17;
    case "inductiveconstructor" :
        return /* ConstructorInductive */23;
    case "keyword" :
        return /* Keyword */1;
    case "macro" :
        return /* Macro */33;
    case "markup" :
        return /* Markup */8;
    case "module" :
        return /* Module */28;
    case "number" :
        return /* Number */3;
    case "operator" :
        return /* Operator */34;
    case "positivityproblem" :
        return /* PositivityProblem */14;
    case "postulate" :
        return /* Postulate */29;
    case "pragma" :
        return /* Pragma */6;
    case "primitive" :
        return /* Primitive */30;
    case "primitivetype" :
        return /* PrimitiveType */5;
    case "record" :
        return /* Record */31;
    case "string" :
        return /* String */2;
    case "symbol" :
        return /* Symbol */4;
    case "terminationproblem" :
        return /* TerminationProblem */13;
    case "typechecks" :
        return /* TypeChecks */18;
    case "unsolvedconstraint" :
        return /* UnsolvedConstraint */12;
    case "unsolvedmeta" :
        return /* UnsolvedMeta */11;
    default:
      return /* Operator */34;
  }
}

function toDecoration(x) {
  switch (x) {
    case /* Comment */0 :
        return {
                light: {
                  TAG: 1,
                  _0: "#B0B0B0",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#505050",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Keyword */1 :
        return {
                light: {
                  TAG: 1,
                  _0: "#CD6600",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#FF9932",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* String */2 :
        return {
                light: {
                  TAG: 1,
                  _0: "#B22222",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#DD4D4D",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Number */3 :
        return {
                light: {
                  TAG: 1,
                  _0: "#800080",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#9010E0",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Symbol */4 :
        return {
                light: {
                  TAG: 1,
                  _0: "#404040",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#BFBFBF",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Error */9 :
        return {
                light: {
                  TAG: 1,
                  _0: "#FF0000",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#FF0000",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* UnsolvedMeta */11 :
    case /* UnsolvedConstraint */12 :
        return {
                light: {
                  TAG: 0,
                  _0: "#FFFF00",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#806B00",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* TerminationProblem */13 :
        return {
                light: {
                  TAG: 0,
                  _0: "#FFA07A",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#802400",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* PositivityProblem */14 :
        return {
                light: {
                  TAG: 0,
                  _0: "#CD853F",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#803F00",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* Deadcode */15 :
        return {
                light: {
                  TAG: 0,
                  _0: "#A9A9A9",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#808080",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* CoverageProblem */16 :
        return {
                light: {
                  TAG: 0,
                  _0: "#F5DEB3",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#805300",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* IncompletePattern */17 :
        return {
                light: {
                  TAG: 0,
                  _0: "#800080",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#800080",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* CatchallClause */19 :
        return {
                light: {
                  TAG: 0,
                  _0: "#F5F5F5",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#404040",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* ConfluenceProblem */20 :
        return {
                light: {
                  TAG: 0,
                  _0: "#FFC0CB",
                  [Symbol.for("name")]: "Background"
                },
                dark: {
                  TAG: 0,
                  _0: "#800080",
                  [Symbol.for("name")]: "Background"
                }
              };
    case /* ConstructorInductive */23 :
        return {
                light: {
                  TAG: 1,
                  _0: "#008B00",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#29CC29",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* ConstructorCoInductive */24 :
        return {
                light: {
                  TAG: 1,
                  _0: "#996600",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#FFEA75",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Field */26 :
        return {
                light: {
                  TAG: 1,
                  _0: "#EE1289",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#F570B7",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Module */28 :
        return {
                light: {
                  TAG: 1,
                  _0: "#800080",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#CD80FF",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* PrimitiveType */5 :
    case /* Datatype */25 :
    case /* Function */27 :
    case /* Postulate */29 :
    case /* Primitive */30 :
    case /* Record */31 :
        return {
                light: {
                  TAG: 1,
                  _0: "#0000CD",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#8080FF",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Macro */33 :
        return {
                light: {
                  TAG: 1,
                  _0: "#458B74",
                  [Symbol.for("name")]: "Foreground"
                },
                dark: {
                  TAG: 1,
                  _0: "#73BAA2",
                  [Symbol.for("name")]: "Foreground"
                }
              };
    case /* Pragma */6 :
    case /* Background */7 :
    case /* Markup */8 :
    case /* DottedPattern */10 :
    case /* TypeChecks */18 :
    case /* Bound */21 :
    case /* Generalizable */22 :
    case /* Argument */32 :
    case /* Operator */34 :
        return ;
    
  }
}

function toTokenTypeAndModifiersAndDecoration(x) {
  var nothing_0 = [
    undefined,
    []
  ];
  var nothing = [
    nothing_0,
    undefined
  ];
  var backgroundOnly = function (light, dark) {
    return [
            [
              undefined,
              []
            ],
            {
              light: {
                TAG: 0,
                _0: light,
                [Symbol.for("name")]: "Background"
              },
              dark: {
                TAG: 0,
                _0: dark,
                [Symbol.for("name")]: "Background"
              }
            }
          ];
  };
  switch (x) {
    case /* Comment */0 :
        return [
                [
                  /* Comment */16,
                  []
                ],
                undefined
              ];
    case /* Keyword */1 :
        return [
                [
                  /* Keyword */18,
                  []
                ],
                undefined
              ];
    case /* Number */3 :
        return [
                [
                  /* Number */19,
                  []
                ],
                undefined
              ];
    case /* Error */9 :
        return [
                [
                  undefined,
                  [/* Deprecated */3]
                ],
                undefined
              ];
    case /* UnsolvedMeta */11 :
        return backgroundOnly("#FFFF00", "#806B00");
    case /* UnsolvedConstraint */12 :
    case /* TerminationProblem */13 :
        return backgroundOnly("#FFA07A", "#802400");
    case /* PositivityProblem */14 :
        return backgroundOnly("#CD853F", "#803F00");
    case /* Deadcode */15 :
        return backgroundOnly("#A9A9A9", "#808080");
    case /* CoverageProblem */16 :
        return backgroundOnly("#F5DEB3", "#805300");
    case /* IncompletePattern */17 :
        return backgroundOnly("#800080", "#800080");
    case /* Symbol */4 :
    case /* Pragma */6 :
    case /* Background */7 :
    case /* Markup */8 :
    case /* DottedPattern */10 :
    case /* TypeChecks */18 :
        return nothing;
    case /* CatchallClause */19 :
        return backgroundOnly("#F5F5F5", "#404040");
    case /* ConfluenceProblem */20 :
        return backgroundOnly("#FFC0CB", "#800080");
    case /* Bound */21 :
    case /* Generalizable */22 :
        return [
                [
                  /* Variable */8,
                  []
                ],
                undefined
              ];
    case /* ConstructorInductive */23 :
    case /* ConstructorCoInductive */24 :
        return [
                [
                  /* EnumMember */10,
                  []
                ],
                undefined
              ];
    case /* PrimitiveType */5 :
    case /* Datatype */25 :
        return [
                [
                  /* Type */1,
                  []
                ],
                undefined
              ];
    case /* Field */26 :
        return [
                [
                  /* Member */13,
                  []
                ],
                undefined
              ];
    case /* Module */28 :
        return [
                [
                  /* Namespace */0,
                  []
                ],
                undefined
              ];
    case /* Function */27 :
    case /* Postulate */29 :
        return [
                [
                  /* Function */12,
                  []
                ],
                undefined
              ];
    case /* String */2 :
    case /* Primitive */30 :
        return [
                [
                  /* String */17,
                  []
                ],
                undefined
              ];
    case /* Record */31 :
        return [
                [
                  /* Struct */5,
                  []
                ],
                undefined
              ];
    case /* Argument */32 :
        return [
                [
                  /* Parameter */7,
                  []
                ],
                undefined
              ];
    case /* Macro */33 :
        return [
                [
                  /* Macro */14,
                  []
                ],
                undefined
              ];
    case /* Operator */34 :
        return [
                [
                  /* Operator */21,
                  []
                ],
                undefined
              ];
    
  }
}

var Aspect = {
  toString: toString,
  parse: parse,
  toDecoration: toDecoration,
  toTokenTypeAndModifiersAndDecoration: toTokenTypeAndModifiersAndDecoration
};

function toString$1(self) {
  var match = self.source;
  return "Annotation " + (String(self.start) + (" " + (String(self.end_) + (" " + (Util$AgdaModeVscode.Pretty.list(Belt_List.fromArray(self.aspects)) + (
                    match !== undefined ? match[0] + (" " + String(match[1])) : ""
                  ))))));
}

function parse$1(x) {
  if (x.TAG === /* A */0) {
    return ;
  }
  var xs = x._0;
  var len = xs.length;
  if (len >= 7) {
    return ;
  }
  switch (len) {
    case 3 :
        var start$p = xs[0];
        if (start$p.TAG !== /* A */0) {
          return ;
        }
        var end_$p = xs[1];
        if (end_$p.TAG !== /* A */0) {
          return ;
        }
        var end_$p$1 = end_$p._0;
        var aspects = xs[2];
        return Belt_Option.flatMap(Pervasives.int_of_string_opt(start$p._0), (function (start) {
                      return Belt_Option.map(Pervasives.int_of_string_opt(end_$p$1), (function (end_) {
                                    return {
                                            start: start - 1 | 0,
                                            end_: end_ - 1 | 0,
                                            aspects: Belt_Array.map(Parser$AgdaModeVscode.SExpression.flatten(aspects), parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 4 :
        var start$p$1 = xs[0];
        if (start$p$1.TAG !== /* A */0) {
          return ;
        }
        var end_$p$2 = xs[1];
        if (end_$p$2.TAG !== /* A */0) {
          return ;
        }
        var end_$p$3 = end_$p$2._0;
        var aspects$1 = xs[2];
        return Belt_Option.flatMap(Pervasives.int_of_string_opt(start$p$1._0), (function (start) {
                      return Belt_Option.map(Pervasives.int_of_string_opt(end_$p$3), (function (end_) {
                                    return {
                                            start: start - 1 | 0,
                                            end_: end_ - 1 | 0,
                                            aspects: Belt_Array.map(Parser$AgdaModeVscode.SExpression.flatten(aspects$1), parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 0 :
    case 1 :
    case 2 :
    case 5 :
        return ;
    case 6 :
        var start$p$2 = xs[0];
        if (start$p$2.TAG !== /* A */0) {
          return ;
        }
        var end_$p$4 = xs[1];
        if (end_$p$4.TAG !== /* A */0) {
          return ;
        }
        var end_$p$5 = end_$p$4._0;
        var aspects$2 = xs[2];
        var match = xs[5];
        if (match.TAG === /* A */0) {
          return ;
        }
        var match$1 = match._0;
        if (match$1.length !== 3) {
          return ;
        }
        var filepath = match$1[0];
        if (filepath.TAG !== /* A */0) {
          return ;
        }
        var filepath$1 = filepath._0;
        var index$p = match$1[2];
        if (index$p.TAG !== /* A */0) {
          return ;
        }
        var index$p$1 = index$p._0;
        return Belt_Option.flatMap(Pervasives.int_of_string_opt(start$p$2._0), (function (start) {
                      return Belt_Option.flatMap(Pervasives.int_of_string_opt(end_$p$5), (function (end_) {
                                    return Belt_Option.map(Pervasives.int_of_string_opt(index$p$1), (function (index) {
                                                  return {
                                                          start: start - 1 | 0,
                                                          end_: end_ - 1 | 0,
                                                          aspects: Belt_Array.map(Parser$AgdaModeVscode.SExpression.flatten(aspects$2), parse),
                                                          isTokenBased: false,
                                                          note: undefined,
                                                          source: [
                                                            filepath$1,
                                                            index
                                                          ]
                                                        };
                                                }));
                                  }));
                    }));
    
  }
}

function parseDirectHighlightings(tokens) {
  return Belt_Array.keepMap(Belt_Array.map(tokens.slice(2), parse$1), (function (x) {
                return x;
              }));
}

function decode(param) {
  return Json_decode.map((function (param) {
                return {
                        start: param[0] - 1 | 0,
                        end_: param[1] - 1 | 0,
                        aspects: Belt_Array.map(param[2], parse),
                        isTokenBased: param[3],
                        note: param[4],
                        source: param[5]
                      };
              }), (function (param) {
                return Util$AgdaModeVscode.Decode.tuple6(Json_decode.$$int, Json_decode.$$int, (function (param) {
                              return Json_decode.array(Json_decode.string, param);
                            }), Json_decode.bool, (function (param) {
                              return Json_decode.optional(Json_decode.string, param);
                            }), (function (param) {
                              return Json_decode.optional((function (param) {
                                            return Json_decode.pair(Json_decode.string, Json_decode.$$int, param);
                                          }), param);
                            }), param);
              }), param);
}

var Token = {
  toString: toString$1,
  parse: parse$1,
  parseDirectHighlightings: parseDirectHighlightings,
  decode: decode
};

function make(param) {
  return {
          tempFiles: [],
          tokens: new BinarySearchTree.BinarySearchTree()
        };
}

function decodeHighlightingInfoDirect(param) {
  return Json_decode.map((function (param) {
                return [
                        param[0],
                        param[1]
                      ];
              }), (function (param) {
                return Json_decode.pair(Json_decode.bool, (function (param) {
                              return Json_decode.array(decode, param);
                            }), param);
              }), param);
}

function insert(self, editor, tokens) {
  return Belt_Array.forEach(tokens, (function (info) {
                var existing = AVLTree$AgdaModeVscode.find(self.tokens, info.start);
                if (existing !== undefined) {
                  var old = existing[0];
                  self.tokens.remove(info.start);
                  var newAspects = Caml_obj.caml_equal(old.aspects, info.aspects) ? old.aspects : Belt_Array.concat(old.aspects, info.aspects);
                  var new_start = old.start;
                  var new_end_ = old.end_;
                  var new_isTokenBased = old.isTokenBased;
                  var new_note = old.note;
                  var new_source = old.source;
                  var $$new = {
                    start: new_start,
                    end_: new_end_,
                    aspects: newAspects,
                    isTokenBased: new_isTokenBased,
                    note: new_note,
                    source: new_source
                  };
                  self.tokens.insert(info.start, [
                        $$new,
                        existing[1]
                      ]);
                  return ;
                }
                var $$document = editor.document;
                var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                var start = Editor$AgdaModeVscode.Position.fromOffset($$document, Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.start));
                var end_ = Editor$AgdaModeVscode.Position.fromOffset($$document, Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.end_));
                var range = new Vscode.Range(start, end_);
                self.tokens.insert(info.start, [
                      info,
                      range
                    ]);
                
              }));
}

function addEmacsFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: 0,
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
  
}

function addJSONFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: 1,
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
  
}

function readTempFiles(self, editor) {
  var readAndParseTempFile = function (format) {
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(Util.promisify(function (prim0, prim1) {
                              Fs.readFile(prim0, prim1);
                              
                            })(format._0))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return [
                            false,
                            []
                          ];
                  }
                  var buffer = x._0;
                  if (format.TAG === /* Emacs */0) {
                    var match = Belt_Array.get(Parser$AgdaModeVscode.SExpression.parse(buffer.toString()), 0);
                    var tokens;
                    if (match !== undefined) {
                      if (match.TAG === /* Ok */0) {
                        var xs = match._0;
                        tokens = xs.TAG === /* A */0 ? [] : xs._0;
                      } else {
                        tokens = [];
                      }
                    } else {
                      tokens = [];
                    }
                    var match$1 = Belt_Array.get(tokens, 0);
                    var removeTokenBasedHighlighting = match$1 !== undefined && match$1.TAG === /* A */0 && match$1._0 === "remove" ? true : false;
                    var tokens$1 = Belt_Array.keepMap(tokens.slice(1), parse$1);
                    return [
                            removeTokenBasedHighlighting,
                            tokens$1
                          ];
                  }
                  var raw = buffer.toString();
                  var json;
                  try {
                    json = JSON.parse(raw);
                  }
                  catch (_e){
                    return [
                            false,
                            []
                          ];
                  }
                  return decodeHighlightingInfoDirect(json);
                }));
  };
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFiles, readAndParseTempFile)), (function (xs) {
                    return Belt_Array.concatMany(Belt_Array.map(xs, (function (prim) {
                                      return prim[1];
                                    })));
                  })), (function (tokens) {
                insert(self, editor, tokens);
                self.tempFiles = [];
                
              }));
}

function clear(self) {
  Belt_Array.forEach(self.tempFiles, (function (format) {
          Fs.unlink(format._0, (function (param) {
                  
                }));
          
        }));
  self.tokens = new BinarySearchTree.BinarySearchTree();
  
}

function get(self) {
  return self.tokens;
}

function lookupSrcLoc(self, offset) {
  return Belt_Option.map(Belt_Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(self.tokens, offset), (function (param) {
                    var range = param[1];
                    return Belt_Option.map(param[0].source, (function (param) {
                                  return [
                                          range,
                                          param[0],
                                          param[1]
                                        ];
                                }));
                  })), (function (param) {
                var offset = param[2];
                var filepath = param[1];
                var range = param[0];
                return $$Promise.map(Vscode.workspace.openTextDocument(filepath), (function ($$document) {
                              var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                              var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                              var offset$1 = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, offset - 1 | 0);
                              var position = Editor$AgdaModeVscode.Position.fromOffset($$document, offset$1);
                              return [[
                                        range,
                                        filepath,
                                        position
                                      ]];
                            }));
              }));
}

function toDecorationsAndSemanticTokens(tokens, editor) {
  var match = Belt_Array.unzip(Belt_Array.keepMap(Belt_Array.concatMany(Belt_Array.map(AVLTree$AgdaModeVscode.toArray(tokens.tokens), (function (param) {
                      var info = param[0];
                      var ranges = Curry._2(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange, editor.document, param[1]);
                      return Belt_Array.map(ranges, (function (range) {
                                    return [
                                            info.aspects,
                                            range
                                          ];
                                  }));
                    }))), (function (param) {
              var range = param[1];
              var match = Belt_Array.unzip(Belt_Array.map(param[0], toTokenTypeAndModifiersAndDecoration));
              var match$1 = Belt_Array.unzip(match[0]);
              var tokenTypes = Belt_Array.keepMap(match$1[0], (function (x) {
                      return x;
                    }));
              var tokenModifiers = Belt_Array.concatMany(match$1[1]);
              var decorations = Belt_Array.keepMap(match[1], (function (x) {
                      return Belt_Option.map(x, (function (x) {
                                    return [
                                            x,
                                            Curry._1(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange, range)
                                          ];
                                  }));
                    }));
              var semanticToken = Belt_Option.map(Belt_Array.get(tokenTypes, 0), (function (tokenType) {
                      return {
                              range: range,
                              type_: tokenType,
                              modifiers: tokenModifiers
                            };
                    }));
              return [
                      semanticToken,
                      decorations
                    ];
            })));
  var semanticTokens = Belt_Array.keepMap(match[0], (function (x) {
          return x;
        }));
  var decorations = Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.concatMany(match[1]), editor);
  return [
          decorations,
          semanticTokens
        ];
}

function toDecorations(self, editor) {
  var aspects = Belt_Array.concatMany(Belt_Array.map(AVLTree$AgdaModeVscode.toArray(self.tokens), (function (param) {
              var range = param[1];
              return Belt_Array.map(param[0].aspects, (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  return Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.keepMap(aspects, (function (param) {
                    var range = param[1];
                    return Belt_Option.map(toDecoration(param[0]), (function (x) {
                                  return [
                                          x,
                                          range
                                        ];
                                }));
                  })), editor);
}

var Module = {
  make: make,
  decodeHighlightingInfoDirect: decodeHighlightingInfoDirect,
  get: get,
  addEmacsFilePath: addEmacsFilePath,
  addJSONFilePath: addJSONFilePath,
  readTempFiles: readTempFiles,
  insert: insert,
  clear: clear,
  lookupSrcLoc: lookupSrcLoc,
  toDecorations: toDecorations,
  toDecorationsAndSemanticTokens: toDecorationsAndSemanticTokens
};

exports.Aspect = Aspect;
exports.Token = Token;
exports.Module = Module;
exports.make = make;
exports.decodeHighlightingInfoDirect = decodeHighlightingInfoDirect;
exports.get = get;
exports.addEmacsFilePath = addEmacsFilePath;
exports.addJSONFilePath = addJSONFilePath;
exports.readTempFiles = readTempFiles;
exports.insert = insert;
exports.clear = clear;
exports.lookupSrcLoc = lookupSrcLoc;
exports.toDecorations = toDecorations;
exports.toDecorationsAndSemanticTokens = toDecorationsAndSemanticTokens;
/* fs Not a pure module */
