// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var View$AgdaModeVscode = require("../../View.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Emacs__Parser$AgdaModeVscode = require("../Emacs/Emacs__Parser.bs.js");
var Component__Link$AgdaModeVscode = require("./Component__Link.bs.js");
var Component__Range$AgdaModeVscode = require("./Component__Range.bs.js");

function toString(string) {
  switch (string.tag | 0) {
    case /* Plain */0 :
        return string[0];
    case /* QuestionMark */1 :
        return "?" + String(string[0]);
    case /* Underscore */2 :
        return "_" + string[0];
    
  }
}

function Component$Term(Props) {
  var term = Props.term;
  switch (term.tag | 0) {
    case /* Plain */0 :
        return React.createElement("span", {
                    className: "expr"
                  }, term[0]);
    case /* QuestionMark */1 :
        var i = term[0];
        return React.createElement(Component__Link$AgdaModeVscode.make, {
                    target: /* ToHole */Caml_chrome_debugger.variant("ToHole", 1, [i]),
                    jump: true,
                    hover: true,
                    className: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                        "expr",
                        /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            "question-mark",
                            /* [] */0
                          ])
                      ]),
                    children: "?" + String(i)
                  });
    case /* Underscore */2 :
        return React.createElement("span", {
                    className: "expr underscore"
                  }, term[0]);
    
  }
}

var Term = {
  toString: toString,
  jump: true,
  hover: true,
  make: Component$Term
};

function toString$1(xs) {
  return Caml_splice_call.spliceObjApply(" ", "concat", [Belt_Array.map(xs, toString)]);
}

function parse(raw) {
  var __x = raw.trim();
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(__x.split(/(\?\d+)|(\_\d+[^\}\)\s]*)/), (function (i, token) {
                    var match = i % 3;
                    if (match !== 1) {
                      if (match !== 2) {
                        return Belt_Option.map(token, (function (x) {
                                      return /* Plain */Caml_chrome_debugger.variant("Plain", 0, [x]);
                                    }));
                      } else {
                        return Belt_Option.map(token, (function (x) {
                                      return /* Underscore */Caml_chrome_debugger.variant("Underscore", 2, [x]);
                                    }));
                      }
                    } else {
                      return Belt_Option.map(Belt_Option.flatMap(Belt_Option.map(token, (function (param) {
                                            return param.slice(1);
                                          })), Pervasives.int_of_string_opt), (function (x) {
                                    return /* QuestionMark */Caml_chrome_debugger.variant("QuestionMark", 1, [x]);
                                  }));
                    }
                  })), (function (x) {
                return x;
              }));
}

function Component$Expr(Props) {
  var expr = Props.expr;
  return React.createElement("span", undefined, Belt_Array.mapWithIndex(expr, (function (i, term) {
                    return React.createElement(Component$Term, {
                                term: term,
                                key: String(i)
                              });
                  })));
}

var Expr = {
  toString: toString$1,
  parse: parse,
  make: Component$Expr
};

function toString$2(t) {
  if (t.tag) {
    return toString$1(t[0]);
  } else {
    return toString$1(t[0]) + (" : " + toString$1(t[1]));
  }
}

var partial_arg = /^([^\:]*) \: ((?:\n|.)+)/;

function parseOfType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg, (function (captured) {
                return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse), (function (type_) {
                              return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (term) {
                                            return /* OfType */Caml_chrome_debugger.variant("OfType", 0, [
                                                      term,
                                                      type_
                                                    ]);
                                          }));
                            }));
              }), param);
}

var partial_arg$1 = /^Type ((?:\n|.)+)/;

function parseJustType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$1, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (type_) {
                              return /* JustType */Caml_chrome_debugger.variant("JustType", 1, [type_]);
                            }));
              }), param);
}

var partial_arg$2 = /^Sort ((?:\n|.)+)/;

function parseJustSort(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$2, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (sort) {
                              return /* JustSort */Caml_chrome_debugger.variant("JustSort", 2, [sort]);
                            }));
              }), param);
}

function parseOthers(raw) {
  return Belt_Option.map(parse(raw), (function (raw$prime) {
                return /* Others */Caml_chrome_debugger.variant("Others", 3, [raw$prime]);
              }));
}

var partial_arg$3 = [
  parseOfType,
  parseJustType,
  parseJustSort,
  parseOthers
];

function parse$1(param) {
  return Emacs__Parser$AgdaModeVscode.choice(partial_arg$3, param);
}

function Component$OutputConstraint(Props) {
  var value = Props.value;
  var range = Props.range;
  var range$1 = Belt_Option.mapWithDefault(range, null, (function (range) {
          return React.createElement(Component__Range$AgdaModeVscode.make, {
                      range: range,
                      abbr: true
                    });
        }));
  switch (value.tag | 0) {
    case /* OfType */0 :
        return React.createElement("li", {
                    className: "output"
                  }, React.createElement(Component$Expr, {
                        expr: value[0]
                      }), " : ", React.createElement(Component$Expr, {
                        expr: value[1]
                      }), range$1);
    case /* JustType */1 :
        return React.createElement("li", {
                    className: "output"
                  }, "Type ", React.createElement(Component$Expr, {
                        expr: value[0]
                      }), range$1);
    case /* JustSort */2 :
        return React.createElement("li", {
                    className: "output"
                  }, "Sort ", React.createElement(Component$Expr, {
                        expr: value[0]
                      }), range$1);
    case /* Others */3 :
        return React.createElement("li", {
                    className: "output"
                  }, React.createElement(Component$Expr, {
                        expr: value[0]
                      }), range$1);
    
  }
}

var OutputConstraint = {
  toString: toString$2,
  parseOfType: parseOfType,
  parseJustType: parseJustType,
  parseJustSort: parseJustSort,
  parseOthers: parseOthers,
  parse: parse$1,
  make: Component$OutputConstraint
};

function Component$Labeled(Props) {
  var label = Props.label;
  var isErrorOpt = Props.isError;
  var isWarningOpt = Props.isWarning;
  var children = Props.children;
  var isError = isErrorOpt !== undefined ? isErrorOpt : false;
  var isWarning = isWarningOpt !== undefined ? isWarningOpt : false;
  var className = isError ? "error-label" : (
      isWarning ? "warning-label" : "label"
    );
  return React.createElement("li", {
              className: "labeled"
            }, React.createElement("span", {
                  className: className
                }, label), children);
}

var Labeled = {
  make: Component$Labeled
};

function toString$3(param) {
  var range = param[1];
  var c = param[0];
  if (range !== undefined) {
    return "Output " + (toString$2(c) + (" " + View$AgdaModeVscode.$$Range.toString(range)));
  } else {
    return "Output " + toString$2(c);
  }
}

function parseOutputWithoutRange(raw) {
  return Belt_Option.map(Curry._1(parse$1, raw), (function (x) {
                return /* Output */Caml_chrome_debugger.simpleVariant("Output", [
                          x,
                          undefined
                        ]);
              }));
}

var partial_arg$4 = /((?:\n|.)*\S+)\s*\[ at ([^\]]+) \]/;

function parseOutputWithRange(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$4, (function (captured) {
                return Belt_Option.map(Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 1), (function (x) {
                                      return x;
                                    })), parse$1), (function (oc) {
                              var r = Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 2), (function (x) {
                                          return x;
                                        })), View$AgdaModeVscode.$$Range.parse);
                              return /* Output */Caml_chrome_debugger.simpleVariant("Output", [
                                        oc,
                                        r
                                      ]);
                            }));
              }), param);
}

function parse$2(raw) {
  var rangeRe = /\[ at (\S+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+)) \]$/;
  var hasRange = rangeRe.test(raw);
  if (hasRange) {
    return Curry._1(parseOutputWithRange, raw);
  } else {
    return parseOutputWithoutRange(raw);
  }
}

function Component$Output(Props) {
  var value = Props.value;
  return React.createElement(Component$OutputConstraint, {
              value: value[0],
              range: value[1]
            });
}

var Output = {
  toString: toString$3,
  parseOutputWithoutRange: parseOutputWithoutRange,
  parseOutputWithRange: parseOutputWithRange,
  parse: parse$2,
  make: Component$Output
};

function toString$4(s) {
  if (s.tag) {
    return View$AgdaModeVscode.$$Range.toString(s[0]);
  } else {
    return s[0];
  }
}

var Segment = {
  toString: toString$4
};

function toString$5(segments) {
  return Belt_Array.map(segments[0], toString$4).join("");
}

function parse$3(raw) {
  return /* Text */Caml_chrome_debugger.simpleVariant("Text", [Belt_Array.mapWithIndex(Belt_Array.keepMap(raw.split(/([^\(\)\s]+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+))/), (function (x) {
                        return x;
                      })), (function (i, token) {
                    var match = i % 2;
                    if (match !== 1) {
                      return /* PlainText */Caml_chrome_debugger.variant("PlainText", 0, [token]);
                    } else {
                      return Belt_Option.mapWithDefault(Curry._1(View$AgdaModeVscode.$$Range.parse, token), /* PlainText */Caml_chrome_debugger.variant("PlainText", 0, [token]), (function (x) {
                                    return /* Range */Caml_chrome_debugger.variant("Range", 1, [x]);
                                  }));
                    }
                  }))]);
}

function Component$Text(Props) {
  var payload = Props.payload;
  return React.createElement("span", undefined, Belt_Array.mapWithIndex(payload[0], (function (i, plainText) {
                    if (plainText.tag) {
                      return React.createElement(Component__Range$AgdaModeVscode.make, {
                                  range: plainText[0],
                                  key: String(i)
                                });
                    } else {
                      return plainText[0];
                    }
                  })));
}

var $$Text = {
  Segment: Segment,
  toString: toString$5,
  parse: parse$3,
  make: Component$Text
};

function toString$6(xs) {
  return toString$5(xs[0]);
}

function parse$4(isWarning, raw) {
  var text = parse$3(raw);
  if (isWarning) {
    return /* WarningMessage */Caml_chrome_debugger.variant("WarningMessage", 0, [text]);
  } else {
    return /* ErrorMessage */Caml_chrome_debugger.variant("ErrorMessage", 1, [text]);
  }
}

function parseWarning(param) {
  return parse$4(true, param);
}

function parseError(param) {
  return parse$4(false, param);
}

function Component$WarningError(Props) {
  var value = Props.value;
  if (value.tag) {
    return React.createElement(Component$Labeled, {
                label: "Error",
                isError: true,
                children: React.createElement(Component$Text, {
                      payload: value[0]
                    })
              });
  } else {
    return React.createElement(Component$Labeled, {
                label: "Warning",
                isWarning: true,
                children: React.createElement(Component$Text, {
                      payload: value[0]
                    })
              });
  }
}

var WarningError = {
  toString: toString$6,
  parse: parse$4,
  parseWarning: parseWarning,
  parseError: parseError,
  make: Component$WarningError
};

var Link;

var $$Range;

exports.Link = Link;
exports.$$Range = $$Range;
exports.Term = Term;
exports.Expr = Expr;
exports.OutputConstraint = OutputConstraint;
exports.Labeled = Labeled;
exports.Output = Output;
exports.$$Text = $$Text;
exports.WarningError = WarningError;
/* react Not a pure module */
