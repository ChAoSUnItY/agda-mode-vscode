// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Runner3$AgdaModeVscode = require("./Runner3.bs.js");
var Dispatcher$AgdaModeVscode = require("./Dispatcher.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Dispatcher = Dispatcher$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var dispatchCommand = function (self, state, command) {
    var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
    var tasks = Curry._1(CommandHandler.handle, command);
    return Runner3$AgdaModeVscode.pushAndRun(self.runner, tasks);
  };
  var make = function (state) {
    var blockedQueues = {
      contents: /* [] */0
    };
    var agdaIsOccupied = function (queues) {
      if (Belt_List.length(queues) !== 0) {
        return Belt_List.some(queues, (function (param) {
                      if (param.tag) {
                        return false;
                      } else {
                        return true;
                      }
                    }));
      } else {
        return false;
      }
    };
    var viewIsOccupied = function (queues) {
      if (Belt_List.length(queues) !== 0) {
        return Belt_List.some(queues, (function (param) {
                      if (param.tag) {
                        return true;
                      } else {
                        return false;
                      }
                    }));
      } else {
        return false;
      }
    };
    var releaseAgda = function (param) {
      if (!param) {
        return /* tuple */[
                undefined,
                /* [] */0
              ];
      }
      var queue = param[0];
      if (!queue.tag) {
        return /* tuple */[
                queue[0],
                param[1]
              ];
      }
      var other = queue[0];
      var match = releaseAgda(param[1]);
      var others = match[1];
      var queue$1 = match[0];
      if (queue$1 !== undefined) {
        return /* tuple */[
                undefined,
                /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* BlockedByView */Caml_chrome_debugger.variant("BlockedByView", 1, [Belt_List.concat(other, queue$1)]),
                    others
                  ])
              ];
      } else {
        return /* tuple */[
                undefined,
                /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* BlockedByView */Caml_chrome_debugger.variant("BlockedByView", 1, [other]),
                    others
                  ])
              ];
      }
    };
    var releaseView = function (param) {
      if (!param) {
        return /* tuple */[
                undefined,
                /* [] */0
              ];
      }
      var queue = param[0];
      if (queue.tag) {
        return /* tuple */[
                queue[0],
                param[1]
              ];
      }
      var other = queue[0];
      var match = releaseView(param[1]);
      var others = match[1];
      var queue$1 = match[0];
      if (queue$1 !== undefined) {
        return /* tuple */[
                undefined,
                /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* BlockedByAgda */Caml_chrome_debugger.variant("BlockedByAgda", 0, [Belt_List.concat(other, queue$1)]),
                    others
                  ])
              ];
      } else {
        return /* tuple */[
                undefined,
                /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* BlockedByAgda */Caml_chrome_debugger.variant("BlockedByAgda", 0, [other]),
                    others
                  ])
              ];
      }
    };
    var runner = Runner3$AgdaModeVscode.make(undefined);
    var printStatus = function (task, runner, queues) {
      console.log("\nTask: " + (Curry._1(Task.toString, task) + ("\nRunner: " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(runner.queue, Task.toString)) + "\n==============================="))));
      return Belt_List.forEach(queues, (function (queue) {
                    if (queue.tag) {
                      console.log("View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(queue[0], Task.toString)));
                      return ;
                    }
                    console.log("Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(queue[0], Task.toString)));
                    
                  }));
    };
    var classifyTask = function (task) {
      printStatus(task, runner, blockedQueues.contents);
      if (typeof task === "number") {
        return Curry._1(Task.State.destroy, state);
      }
      switch (task.tag | 0) {
        case /* SendRequest */0 :
            if (agdaIsOccupied(blockedQueues.contents)) {
              console.log("Agda blocked");
              return $$Promise.resolved(undefined);
            }
            console.log("Agda not blocked");
            var queue = Belt_List.fromArray(Runner3$AgdaModeVscode.empty(runner));
            blockedQueues.contents = /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* BlockedByAgda */Caml_chrome_debugger.variant("BlockedByAgda", 0, [queue]),
                blockedQueues.contents
              ]);
            $$Promise.tap(Curry._3(Dispatcher.sendAgdaRequest, (function (tasks) {
                        printStatus(task, runner, blockedQueues.contents);
                        Runner3$AgdaModeVscode.pushAndRun(runner, tasks);
                        return $$Promise.resolved(undefined);
                      }), state, task[0]), (function (param) {
                    console.log("Agda unblocked");
                    var match = releaseAgda(blockedQueues.contents);
                    var queue = match[0];
                    blockedQueues.contents = match[1];
                    if (queue !== undefined) {
                      return Runner3$AgdaModeVscode.pushAndRun(runner, queue);
                    }
                    
                  }));
            return $$Promise.resolved(undefined);
        case /* ViewReq */1 :
            var callback = task[1];
            if (viewIsOccupied(blockedQueues.contents)) {
              console.log("View blocked");
              return $$Promise.resolved(undefined);
            } else {
              console.log("View not blocked");
              return $$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                            var queue = Belt_List.fromArray(Runner3$AgdaModeVscode.empty(runner));
                            blockedQueues.contents = /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* BlockedByView */Caml_chrome_debugger.variant("BlockedByView", 1, [queue]),
                                blockedQueues.contents
                              ]);
                            printStatus(task, runner, blockedQueues.contents);
                            var tasks = Curry._1(callback, response);
                            Runner3$AgdaModeVscode.pushAndRun(runner, tasks);
                            console.log("View unblocked");
                            var match = releaseView(blockedQueues.contents);
                            var queue$1 = match[0];
                            blockedQueues.contents = match[1];
                            if (queue$1 !== undefined) {
                              return Runner3$AgdaModeVscode.pushAndRun(runner, queue$1);
                            }
                            
                          }));
            }
        case /* ViewEvent */2 :
            var tasks = task[0] ? /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* Terminate */0,
                  /* [] */0
                ]) : /* [] */0;
            Runner3$AgdaModeVscode.pushAndRun(runner, tasks);
            return $$Promise.resolved(undefined);
        case /* Error */3 :
            var tasks$1 = Curry._1(ErrorHandler.handle, task[0]);
            Runner3$AgdaModeVscode.pushAndRun(runner, tasks$1);
            return $$Promise.resolved(undefined);
        case /* Goal */4 :
            var tasks$2 = Curry._1(GoalHandler.handle, task[0]);
            Runner3$AgdaModeVscode.pushAndRun(runner, tasks$2);
            return $$Promise.resolved(undefined);
        case /* WithState */5 :
            return $$Promise.map(Curry._1(task[0], state), (function (tasks) {
                          return Runner3$AgdaModeVscode.pushAndRun(runner, tasks);
                        }));
        case /* Debug */6 :
            var tasks_000 = Curry._2(Task.displayWarning, "Debug", task[0]);
            var tasks$3 = /* :: */Caml_chrome_debugger.simpleVariant("::", [
                tasks_000,
                /* [] */0
              ]);
            Runner3$AgdaModeVscode.pushAndRun(runner, tasks$3);
            return $$Promise.resolved(undefined);
        
      }
    };
    Runner3$AgdaModeVscode.setup(runner, classifyTask);
    return {
            runner: runner,
            blockedQueues: /* [] */0
          };
  };
  var interrupt = function (self, command) {
    return $$Promise.resolved(undefined);
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Dispatcher: Dispatcher,
          Task: Task,
          dispatchCommand: dispatchCommand,
          make: make,
          interrupt: interrupt,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
