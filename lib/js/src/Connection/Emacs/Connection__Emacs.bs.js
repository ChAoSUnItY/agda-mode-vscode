// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("rescript/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Untildify = require("untildify");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Chan$AgdaModeVscode = require("../../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../Config.bs.js");
var Parser$AgdaModeVscode = require("../../Parser/Parser.bs.js");
var Response$AgdaModeVscode = require("../../Response.bs.js");
var Client__Process$LanguageServerMule = require("language-server-mule/lib/js/src/Client/Client__Process.bs.js");
var Connection__Scheduler$AgdaModeVscode = require("../Connection__Scheduler.bs.js");

function make(path, args) {
  var path$1 = Untildify(path);
  var $$process = Client__Process$LanguageServerMule.make(path$1, ["-V"]);
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var handle = Client__Process$LanguageServerMule.onOutput($$process, (function (output) {
          switch (output.TAG | 0) {
            case /* Stdout */0 :
                var match_ = output._0.match(/Agda version (.*)/);
                if (match_ === null) {
                  return Curry._1(resolve, {
                              TAG: 1,
                              _0: "Cannot read Agda version",
                              [Symbol.for("name")]: "Error"
                            });
                }
                var version = Belt_Array.get(match_, 1);
                if (version !== undefined) {
                  return Curry._1(resolve, {
                              TAG: 0,
                              _0: {
                                path: path$1,
                                args: args,
                                version: version
                              },
                              [Symbol.for("name")]: "Ok"
                            });
                } else {
                  return Curry._1(resolve, {
                              TAG: 1,
                              _0: "Cannot read Agda version",
                              [Symbol.for("name")]: "Error"
                            });
                }
            case /* Stderr */1 :
                return Curry._1(resolve, {
                            TAG: 1,
                            _0: "Message from stderr when validating the program:\n" + output._0,
                            [Symbol.for("name")]: "Error"
                          });
            case /* Event */2 :
                return Curry._1(resolve, {
                            TAG: 1,
                            _0: "Something occured when validating the program:\n" + Client__Process$LanguageServerMule.$$Event.toString(output._0),
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  return $$Promise.mapError($$Promise.tap(match[0], (function (param) {
                    return Curry._1(handle, undefined);
                  })), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "Validation"
                      };
              }));
}

function toString(self) {
  var path = "* path: " + self.path;
  var args = "* args: " + Util$AgdaModeVscode.Pretty.array(self.args);
  var version = "* version: " + self.version;
  var os = "* platform: " + Os.type();
  return "## Parse Log\n" + (path + ("\n" + (args + ("\n" + (version + ("\n" + (os + "\n")))))));
}

var ProcInfo = {
  make: make,
  toString: toString
};

function destroy(self) {
  Chan$AgdaModeVscode.destroy(self.chan);
  self.encountedFirstPrompt = false;
  return Client__Process$LanguageServerMule.destroy(self.process);
}

function wire(self) {
  var toResponse = Curry._1(Parser$AgdaModeVscode.Incr.Gen.flatMap, (function (x) {
          if (x.TAG === /* Ok */0) {
            var tokens = x._0;
            if (tokens.TAG === /* A */0 && tokens._0 === "Agda2>") {
              return /* Stop */0;
            } else {
              return {
                      _0: Response$AgdaModeVscode.Prioritized.parse(tokens),
                      [Symbol.for("name")]: "Yield"
                    };
            }
          }
          var match = x._0;
          return {
                  _0: {
                    TAG: 1,
                    _0: {
                      TAG: 0,
                      _0: match[0],
                      _1: match[1],
                      [Symbol.for("name")]: "SExpression"
                    },
                    [Symbol.for("name")]: "Error"
                  },
                  [Symbol.for("name")]: "Yield"
                };
        }));
  var incrParser = Parser$AgdaModeVscode.SExpression.makeIncr(function (x) {
        var res = Curry._1(toResponse, x);
        if (!res) {
          if (self.encountedFirstPrompt) {
            return Chan$AgdaModeVscode.emit(self.chan, {
                        TAG: 0,
                        _0: /* Stop */0,
                        [Symbol.for("name")]: "Ok"
                      });
          } else {
            self.encountedFirstPrompt = true;
            return ;
          }
        }
        var response = res._0;
        if (response.TAG === /* Ok */0) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: {
                        _0: response._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 1,
                      _0: {
                        TAG: 3,
                        _0: response._0,
                        [Symbol.for("name")]: "ResponseParseError"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }
      });
  var listenerHandle;
  listenerHandle = Client__Process$LanguageServerMule.onOutput(self.process, (function (x) {
          switch (x.TAG | 0) {
            case /* Stdout */0 :
                var rawText = x._0;
                if (rawText.startsWith("Error:")) {
                  return Chan$AgdaModeVscode.emit(self.chan, {
                              TAG: 1,
                              _0: {
                                TAG: 2,
                                _0: rawText,
                                [Symbol.for("name")]: "AgdaError"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                } else {
                  return Belt_Array.forEach(Parser$AgdaModeVscode.split(rawText), (function (param) {
                                return Parser$AgdaModeVscode.Incr.feed(incrParser, param);
                              }));
                }
            case /* Stderr */1 :
                return ;
            case /* Event */2 :
                return Chan$AgdaModeVscode.emit(self.chan, {
                            TAG: 1,
                            _0: {
                              TAG: 1,
                              _0: x._0,
                              [Symbol.for("name")]: "Process"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  
}

function make$1(method) {
  if (method.TAG !== /* ViaStdIO */0) {
    return $$Promise.resolved({
                TAG: 1,
                _0: /* ConnectionViaTCPNotSupported */0,
                [Symbol.for("name")]: "Error"
              });
  }
  var persistPathInConfig = function (procInfo) {
    return $$Promise.map(Config$AgdaModeVscode.Connection.setAgdaPath(procInfo.path), (function (param) {
                  return {
                          TAG: 0,
                          _0: procInfo,
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  };
  var args = ["--interaction"].concat(Config$AgdaModeVscode.Connection.getCommandLineOptions(undefined));
  return $$Promise.tapOk($$Promise.mapOk($$Promise.flatMapOk(make(method._0, args), persistPathInConfig), (function (procInfo) {
                    return {
                            procInfo: procInfo,
                            process: Client__Process$LanguageServerMule.make(procInfo.path, procInfo.args),
                            chan: Chan$AgdaModeVscode.make(undefined),
                            encountedFirstPrompt: false
                          };
                  })), wire);
}

function onResponse(conn, callback) {
  var scheduler = Connection__Scheduler$AgdaModeVscode.make(undefined);
  var match = $$Promise.pending(undefined);
  var stopListener = match[1];
  var listener = function (x) {
    if (x.TAG === /* Ok */0) {
      var match = x._0;
      if (match) {
        var response = match._0;
        if (response.TAG === /* NonLast */0) {
          return Connection__Scheduler$AgdaModeVscode.runNonLast(scheduler, (function (response) {
                        return Curry._1(callback, {
                                    TAG: 0,
                                    _0: response,
                                    [Symbol.for("name")]: "Ok"
                                  });
                      }), response._0);
        } else {
          return Connection__Scheduler$AgdaModeVscode.addLast(scheduler, response._0, response._1);
        }
      }
      Curry._1(stopListener, {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          });
      return Connection__Scheduler$AgdaModeVscode.runLast(scheduler, (function (response) {
                    return Curry._1(callback, {
                                TAG: 0,
                                _0: response,
                                [Symbol.for("name")]: "Ok"
                              });
                  }));
    }
    var error = x._0;
    Curry._1(stopListener, {
          TAG: 1,
          _0: error,
          [Symbol.for("name")]: "Error"
        });
    Curry._1(callback, {
          TAG: 1,
          _0: error,
          [Symbol.for("name")]: "Error"
        });
    
  };
  var listenerHandle = {
    contents: undefined
  };
  listenerHandle.contents = Chan$AgdaModeVscode.on(conn.chan, listener);
  return $$Promise.tap(match[0], (function (param) {
                return Belt_Option.forEach(listenerHandle.contents, (function (destroyListener) {
                              return Curry._1(destroyListener, undefined);
                            }));
              }));
}

function sendRequest(conn, request, handler) {
  var promise = onResponse(conn, handler);
  Client__Process$LanguageServerMule.send(conn.process, request);
  return promise;
}

function getInfo(conn) {
  return [
          conn.procInfo.version,
          conn.procInfo.path
        ];
}

var Module = {
  make: make$1,
  destroy: destroy,
  sendRequest: sendRequest,
  getInfo: getInfo
};

var $$Error;

var Scheduler;

var Process;

exports.$$Error = $$Error;
exports.Scheduler = Scheduler;
exports.Process = Process;
exports.ProcInfo = ProcInfo;
exports.Module = Module;
exports.make = make$1;
exports.destroy = destroy;
exports.sendRequest = sendRequest;
exports.getInfo = getInfo;
/* os Not a pure module */
