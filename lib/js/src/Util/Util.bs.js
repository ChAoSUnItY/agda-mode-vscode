// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var React = require("react");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var CompareVersions = require("compare-versions");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");

function mapError(x, f) {
  if (x.TAG === /* Ok */0) {
    return {
            TAG: 0,
            _0: x._0,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: Curry._1(f, x._0),
            [Symbol.for("name")]: "Error"
          };
  }
}

var Result = {
  mapError: mapError
};

var $$Error = /* @__PURE__ */Caml_exceptions.create("Util-AgdaModeVscode.Error");

var TempDecodeError = /* @__PURE__ */Caml_exceptions.create("Util-AgdaModeVscode.Decode.TempDecodeError");

function convert(translation, json) {
  var translation$1 = Json$JsonCombinators.decode(json, translation);
  if (translation$1.TAG === /* Ok */0) {
    return translation$1._0;
  }
  throw {
        RE_EXN_ID: TempDecodeError,
        _1: json,
        Error: new Error()
      };
}

function sum_(decoder) {
  return Json_Decode$JsonCombinators.flatMap(Json_Decode$JsonCombinators.field("tag", Json_Decode$JsonCombinators.string), (function (tag) {
                var d = Curry._1(decoder, tag);
                if (d.TAG === /* Contents */0) {
                  return Json_Decode$JsonCombinators.field("contents", d._0);
                }
                var d$1 = d._0;
                return Json_Decode$JsonCombinators.custom(function (param) {
                            return d$1;
                          });
              }));
}

function sum(decoder) {
  return function (param) {
    return Json_decode.andThen((function (tag) {
                  var d = Curry._1(decoder, tag);
                  if (d.TAG === /* Contents */0) {
                    var d$1 = d._0;
                    return function (param) {
                      return Json_decode.field("contents", d$1, param);
                    };
                  }
                  var d$2 = d._0;
                  return function (param) {
                    return d$2;
                  };
                }), (function (param) {
                  return Json_decode.field("tag", Json_decode.string, param);
                }), param);
  };
}

function maybe(decoder) {
  return sum(function (x) {
              if (x === "Just") {
                return {
                        TAG: 0,
                        _0: (function (json) {
                            return Caml_option.some(Curry._1(decoder, json));
                          }),
                        [Symbol.for("name")]: "Contents"
                      };
              } else {
                return {
                        TAG: 1,
                        _0: undefined,
                        [Symbol.for("name")]: "TagOnly"
                      };
              }
            });
}

function tuple5(decodeA, decodeB, decodeC, decodeD, decodeE, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 5) {
      try {
        return [
                Curry._1(decodeA, json[0]),
                Curry._1(decodeB, json[1]),
                Curry._1(decodeC, json[2]),
                Curry._1(decodeD, json[3]),
                Curry._1(decodeE, json[4])
              ];
      }
      catch (raw_msg){
        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === Json_decode.DecodeError) {
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: msg._1 + "\n\tin tuple5",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: Json_decode.DecodeError,
            _1: "Expected array of length 5, got array of length " + String(length) + "",
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: Json_decode.DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function tuple6(decodeA, decodeB, decodeC, decodeD, decodeE, decodeF, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 6) {
      try {
        return [
                Curry._1(decodeA, json[0]),
                Curry._1(decodeB, json[1]),
                Curry._1(decodeC, json[2]),
                Curry._1(decodeD, json[3]),
                Curry._1(decodeE, json[4]),
                Curry._1(decodeF, json[5])
              ];
      }
      catch (raw_msg){
        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === Json_decode.DecodeError) {
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: msg._1 + "\n\tin tuple6",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: Json_decode.DecodeError,
            _1: "Expected array of length 6, got array of length " + String(length) + "",
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: Json_decode.DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

var Decode = {
  TempDecodeError: TempDecodeError,
  convert: convert,
  sum_: sum_,
  sum: sum,
  maybe: maybe,
  tuple5: tuple5,
  tuple6: tuple6
};

function tuple5$1(encodeA, encodeB, encodeC, encodeD, encodeE, param) {
  return [
          Curry._1(encodeA, param[0]),
          Curry._1(encodeB, param[1]),
          Curry._1(encodeC, param[2]),
          Curry._1(encodeD, param[3]),
          Curry._1(encodeE, param[4])
        ];
}

var Encode = {
  tuple5: tuple5$1
};

function manyIn(elems, elem) {
  return Caml_splice_call.spliceApply(React.createElement, [
              elem,
              {},
              elems
            ]);
}

function manyIn2(elems, elem, props) {
  return Caml_splice_call.spliceApply(React.createElement, [
              elem,
              props,
              elems
            ]);
}

function sepBy$p(item, sep) {
  if (!item) {
    return React.createElement(React.Fragment, undefined);
  }
  var xs = item.tl;
  var x = item.hd;
  if (xs) {
    return manyIn(Belt_List.toArray({
                    hd: x,
                    tl: Belt_List.map(xs, (function (i) {
                            return React.createElement(React.Fragment, undefined, sep, i);
                          }))
                  }), "span");
  } else {
    return x;
  }
}

function sepBy(sep, xs) {
  return sepBy$p(Belt_List.fromArray(xs), sep);
}

function enclosedBy(front, back, item) {
  return React.createElement(React.Fragment, undefined, front, " ", item, " ", back);
}

function when_(p, className) {
  if (p) {
    return " " + className;
  } else {
    return "";
  }
}

function showWhen(x) {
  if (x) {
    return "";
  } else {
    return " hidden";
  }
}

var React$1 = {
  manyIn: manyIn,
  manyIn2: manyIn2,
  sepBy$p: sepBy$p,
  sepBy: sepBy,
  enclosedBy: enclosedBy,
  when_: when_,
  showWhen: showWhen
};

var partial_arg = /-.*/;

function trim(param) {
  return Js_string.replaceByRe(partial_arg, "", param);
}

function compare(a, b) {
  var match = CompareVersions(Curry._1(trim, a), Curry._1(trim, b));
  if (match !== -1) {
    if (match !== 0) {
      return /* GT */2;
    } else {
      return /* EQ */1;
    }
  } else {
    return /* LT */0;
  }
}

function gte(a, b) {
  var match = compare(a, b);
  return match !== 0;
}

var Version = {
  trim: trim,
  compare: compare,
  gte: gte
};

function array(xs) {
  return "[" + (Js_array.joinWith(", ", xs) + "]");
}

function list(xs) {
  return array(Belt_List.toArray(xs));
}

var Pretty = {
  array: array,
  list: list
};

function oneByOne$p(x) {
  if (!x) {
    return $$Promise.resolved(/* [] */0);
  }
  var xs = x.tl;
  return $$Promise.flatMap(x.hd, (function (x$p) {
                return $$Promise.map(oneByOne$p(xs), (function (xs$p) {
                              return {
                                      hd: x$p,
                                      tl: xs$p
                                    };
                            }));
              }));
}

function oneByOne(xs) {
  return $$Promise.map(oneByOne$p(Belt_List.fromArray(xs)), Belt_List.toArray);
}

function toString(_e) {
  return (_e.toString());
}

var JsError = {
  toString: toString
};

function span(p, xs) {
  if (!xs) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (!Curry._1(p, x)) {
    return [
            /* [] */0,
            xs$1
          ];
  }
  var match = span(p, xs$1);
  return [
          {
            hd: x,
            tl: match[0]
          },
          match[1]
        ];
}

function dropWhile(p, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs.tl;
    var x = xs.hd;
    if (!Curry._1(p, x)) {
      return {
              hd: x,
              tl: xs$1
            };
    }
    _xs = xs$1;
    continue ;
  };
}

var List = {
  span: span,
  dropWhile: dropWhile
};

function toPromise(p) {
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(p)), (function (x) {
                if (x.TAG !== /* Ok */0) {
                  return {
                          TAG: 1,
                          _0: x._0,
                          [Symbol.for("name")]: "Error"
                        };
                }
                var x$1 = x._0;
                if (x$1.TAG === /* Ok */0) {
                  return {
                          TAG: 0,
                          _0: x$1._0,
                          [Symbol.for("name")]: "Ok"
                        };
                } else {
                  return {
                          TAG: 1,
                          _0: x$1._0,
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

var P = {
  toPromise: toPromise
};

var React$p;

exports.Result = Result;
exports.$$Error = $$Error;
exports.Decode = Decode;
exports.Encode = Encode;
exports.React$p = React$p;
exports.React = React$1;
exports.Version = Version;
exports.Pretty = Pretty;
exports.oneByOne$p = oneByOne$p;
exports.oneByOne = oneByOne;
exports.JsError = JsError;
exports.List = List;
exports.P = P;
/* react Not a pure module */
