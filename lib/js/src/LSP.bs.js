// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/lib/js/src/Json_encode.bs.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var VscodeLanguageclient = require("vscode-languageclient");
var Process$AgdaModeVscode = require("./Process.bs.js");

var Message = {};

function toEnum(x) {
  if (x) {
    return 2;
  } else {
    return 1;
  }
}

var ErrorAction = {
  toEnum: toEnum
};

function toEnum$1(x) {
  if (x) {
    return 2;
  } else {
    return 1;
  }
}

var CloseAction = {
  toEnum: toEnum$1
};

function make(error, closed) {
  var error$1 = function (a, b, c) {
    var x = Curry._3(error, a, b, c);
    if (x) {
      return 2;
    } else {
      return 1;
    }
  };
  var closed$1 = function (param) {
    var x = Curry._1(closed, undefined);
    if (x) {
      return 2;
    } else {
      return 1;
    }
  };
  return {
          error: error$1,
          closed: closed$1
        };
}

function makeDefault(name, maxRestartCount) {
  var restarts = [];
  return make((function (param, param$1, count) {
                if (count !== undefined && count <= 3) {
                  return /* Continue */0;
                } else {
                  return /* Shutdown */1;
                }
              }), (function (param) {
                restarts.push(Date.now());
                var length = restarts.length;
                if (length <= maxRestartCount) {
                  return /* Restart */1;
                }
                var diff = Belt_Option.flatMap(Belt_Array.get(restarts, length - 1 | 0), (function (latest) {
                        return Belt_Option.map(Belt_Array.get(restarts, 0), (function (first) {
                                      return latest - first;
                                    }));
                      }));
                if (diff === undefined) {
                  return /* Restart */1;
                }
                if ((diff | 0) <= 180000) {
                  var max = String(maxRestartCount + 1 | 0);
                  Vscode.window.showErrorMessage("The " + name + "server crashed " + max + " times in the last 3 minutes. The server will not be restarted.");
                  return /* DoNotRestart */0;
                }
                restarts.shift();
                return /* Restart */1;
              }));
}

var ErrorHandler = {
  make: make,
  makeDefault: makeDefault
};

var make$1 = (function (documentSelector, synchronize, errorHandler) {
      return {
		    documentSelector: documentSelector,
		    synchronize: synchronize,
        errorHandler: errorHandler
      }
    });

var LanguageClientOptions = {
  make: make$1
};

var makeWithCommand = (function (command) {
      return { command: command }
    });

var makeWithStreamInfo = (function (port) {
      const net = require('net');
      const socket = net.createConnection({ port: port })
      return (() => { return new Promise(resolve => resolve({
        writer: socket,
        reader: socket
      })
      )})
    });

var ServerOptions = {
  makeWithCommand: makeWithCommand,
  makeWithStreamInfo: makeWithStreamInfo
};

var LanguageClient = {};

var errorChan = Chan$AgdaModeVscode.make(undefined);

var dataChan = Chan$AgdaModeVscode.make(undefined);

function onError(callback) {
  return new Vscode.Disposable(Chan$AgdaModeVscode.on(errorChan, callback));
}

function onData(callback) {
  return new Vscode.Disposable(Chan$AgdaModeVscode.on(dataChan, callback));
}

function sendRequest(self, data) {
  return $$Promise.flatMapOk($$Promise.Js.toResult(self.client.onReady()), (function (param) {
                return $$Promise.Js.toResult(self.client.sendRequest("agda", data));
              }));
}

function destroy(self) {
  self.subscription.dispose();
  return $$Promise.map($$Promise.Js.toResult(self.client.stop()), (function (param) {
                
              }));
}

function make$2(devMode, method) {
  var serverOptions = method === /* ViaTCP */1 ? makeWithStreamInfo(3000) : makeWithCommand("als");
  var documentSelector = [VSCode.StringOr.others({
          language: "agda",
          pattern: undefined,
          scheme: "file"
        })];
  var synchronize = Vscode.workspace.createFileSystemWatcher('**/.clientrc', false, false, false);
  var errorHandler = devMode ? make((function (exn, _msg, _count) {
            Chan$AgdaModeVscode.emit(errorChan, exn);
            return /* Shutdown */1;
          }), (function (param) {
            return /* DoNotRestart */0;
          })) : makeDefault("Agda", 3);
  var clientOptions = make$1(documentSelector, synchronize, errorHandler);
  var languageClient = new VscodeLanguageclient.LanguageClient("agdaLanguageServer", "Agda Language Server", serverOptions, clientOptions);
  var self = {
    client: languageClient,
    queue: [],
    subscription: languageClient.start()
  };
  return $$Promise.map($$Promise.race({
                  hd: $$Promise.Js.toResult(self.client.onReady()),
                  tl: {
                    hd: $$Promise.map(Chan$AgdaModeVscode.once(errorChan), (function (err) {
                            return {
                                    TAG: 1,
                                    _0: err,
                                    [Symbol.for("name")]: "Error"
                                  };
                          })),
                    tl: /* [] */0
                  }
                }), (function (result) {
                if (result.TAG !== /* Ok */0) {
                  return {
                          TAG: 1,
                          _0: result._0,
                          [Symbol.for("name")]: "Error"
                        };
                }
                var flag = {
                  contents: true
                };
                self.client.onNotification("agda", (function (json) {
                        if (flag.contents) {
                          Chan$AgdaModeVscode.emit(dataChan, json);
                          flag.contents = false;
                        } else {
                          flag.contents = true;
                        }
                        
                      }));
                return {
                        TAG: 0,
                        _0: self,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

var Client = {
  onError: onError,
  onData: onData,
  sendRequest: sendRequest,
  destroy: destroy,
  make: make$2
};

function encode(x) {
  return Json_encode.object_({
              hd: [
                "tag",
                "ReqInitialize"
              ],
              tl: /* [] */0
            });
}

var $$Request = {
  encode: encode
};

function fromJsError(error) {
  return (function (e) {return e.toString()})(error);
}

var decode = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "ResCannotDecodeRequest" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (version) {
                                      return {
                                              TAG: 3,
                                              _0: version,
                                              [Symbol.for("name")]: "CannotDecodeRequest"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "ResInitialize" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (version) {
                                      return {
                                              TAG: 0,
                                              _0: version,
                                              [Symbol.for("name")]: "Initialize"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[LSP.Response] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var $$Response = {
  fromJsError: fromJsError,
  decode: decode
};

var statusChan = Chan$AgdaModeVscode.make(undefined);

var methodChan = Chan$AgdaModeVscode.make(undefined);

var singleton = {
  state: /* Disconnected */0,
  method: /* ViaStdIO */0,
  devMode: false
};

function find(param) {
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run("als"), (function (prim) {
                    return prim.trim();
                  })), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "PathSearch"
                      };
              }));
}

function stop(param) {
  var match = singleton.state;
  if (typeof match === "number") {
    return $$Promise.resolved(undefined);
  }
  if (match.TAG === /* Connecting */0) {
    singleton.state = /* Disconnected */0;
    Chan$AgdaModeVscode.emit(statusChan, /* Disconnected */0);
    return $$Promise.resolved(undefined);
  }
  singleton.state = /* Disconnected */0;
  Chan$AgdaModeVscode.emit(statusChan, /* Disconnected */0);
  return destroy(match._0);
}

function sendRequestWithClient(client, request) {
  return $$Promise.map(sendRequest(client, encode(request)), (function (x) {
                if (x.TAG === /* Ok */0) {
                  return Curry._1(decode, x._0);
                }
                Chan$AgdaModeVscode.emit(statusChan, /* Disconnected */0);
                return {
                        TAG: 1,
                        _0: fromJsError(x._0),
                        [Symbol.for("name")]: "CannotEncodeRequest"
                      };
              }));
}

function startWithMethod(devMode, method) {
  var match = singleton.state;
  if (typeof match !== "number") {
    if (match.TAG === /* Connecting */0) {
      return match._1;
    } else {
      return $$Promise.resolved([
                  [],
                  match._1
                ]);
    }
  }
  var match$1 = $$Promise.pending(undefined);
  var resolve = match$1[1];
  singleton.state = {
    TAG: 0,
    _0: [],
    _1: match$1[0],
    [Symbol.for("name")]: "Connecting"
  };
  Chan$AgdaModeVscode.emit(statusChan, /* Connecting */1);
  return $$Promise.flatMap(make$2(devMode, method), (function (result) {
                if (result.TAG === /* Ok */0) {
                  var client = result._0;
                  var match = singleton.state;
                  var queuedRequest;
                  queuedRequest = typeof match === "number" ? [] : (
                      match.TAG === /* Connecting */0 ? match._0 : []
                    );
                  var handleQueued = function (param) {
                    return Util$AgdaModeVscode.oneByOne(Belt_Array.map(queuedRequest, (function (param) {
                                      return $$Promise.tap(sendRequestWithClient(client, param[0]), param[1]);
                                    })));
                  };
                  return $$Promise.flatMap(sendRequestWithClient(client, /* Initialize */0), (function (response) {
                                if (typeof response === "number") {
                                  return $$Promise.resolved(undefined);
                                }
                                switch (response.TAG | 0) {
                                  case /* Initialize */0 :
                                      var version = response._0;
                                      singleton.state = {
                                        TAG: 1,
                                        _0: client,
                                        _1: version,
                                        [Symbol.for("name")]: "Connected"
                                      };
                                      Chan$AgdaModeVscode.emit(statusChan, /* Connected */2);
                                      return $$Promise.tap($$Promise.map(handleQueued(undefined), (function (responses) {
                                                        return [
                                                                responses,
                                                                version
                                                              ];
                                                      })), resolve);
                                  case /* CannotDecodeRequest */3 :
                                      console.log(response._0);
                                      return $$Promise.resolved(undefined);
                                  default:
                                    return $$Promise.resolved(undefined);
                                }
                              }));
                }
                var isECONNREFUSED = Belt_Option.mapWithDefault(result._0.message, false, (function (param) {
                        return param.startsWith("connect ECONNREFUSED");
                      }));
                var shouldSwitchToStdIO = isECONNREFUSED && method === /* ViaTCP */1;
                if (shouldSwitchToStdIO) {
                  console.log("Connecting via TCP failed, switch to StdIO");
                  singleton.method = /* ViaStdIO */0;
                  Chan$AgdaModeVscode.emit(methodChan, /* ViaStdIO */0);
                  singleton.state = /* Disconnected */0;
                  Chan$AgdaModeVscode.emit(statusChan, /* Disconnected */0);
                  return startWithMethod(devMode, /* ViaStdIO */0);
                } else {
                  singleton.state = /* Disconnected */0;
                  Chan$AgdaModeVscode.emit(statusChan, /* Disconnected */0);
                  Curry._1(resolve, undefined);
                  return $$Promise.resolved(undefined);
                }
              }));
}

function start(devMode) {
  singleton.devMode = devMode;
  singleton.method = devMode ? /* ViaTCP */1 : /* ViaStdIO */0;
  return startWithMethod(devMode, singleton.method);
}

function isConnected(param) {
  var match = singleton.state;
  if (typeof match === "number" || match.TAG === /* Connecting */0) {
    return ;
  } else {
    return match._1;
  }
}

function onChangeStatus(callback) {
  return new Vscode.Disposable(Chan$AgdaModeVscode.on(statusChan, callback));
}

function onChangeMethod(callback) {
  return new Vscode.Disposable(Chan$AgdaModeVscode.on(methodChan, callback));
}

function sendRequest$1(request) {
  var match = singleton.state;
  if (typeof match === "number") {
    return $$Promise.resolved(/* Disconnected */0);
  }
  if (match.TAG !== /* Connecting */0) {
    return sendRequestWithClient(match._0, request);
  }
  var match$1 = $$Promise.pending(undefined);
  match._0.push([
        request,
        match$1[1]
      ]);
  return match$1[0];
}

function changeMethod(method) {
  if (singleton.method !== method) {
    singleton.method = method;
    Chan$AgdaModeVscode.emit(methodChan, method);
    return $$Promise.flatMap(stop(undefined), (function (param) {
                  return start(singleton.devMode);
                }));
  } else {
    return $$Promise.resolved(undefined);
  }
}

var Module = {
  find: find,
  start: start,
  stop: stop,
  sendRequest: sendRequest$1,
  changeMethod: changeMethod,
  isConnected: isConnected,
  onError: onError,
  onChangeStatus: onChangeStatus,
  onChangeMethod: onChangeMethod
};

exports.Message = Message;
exports.ErrorAction = ErrorAction;
exports.CloseAction = CloseAction;
exports.ErrorHandler = ErrorHandler;
exports.LanguageClientOptions = LanguageClientOptions;
exports.ServerOptions = ServerOptions;
exports.LanguageClient = LanguageClient;
exports.Client = Client;
exports.$$Request = $$Request;
exports.$$Response = $$Response;
exports.Module = Module;
exports.find = find;
exports.start = start;
exports.stop = stop;
exports.sendRequest = sendRequest$1;
exports.changeMethod = changeMethod;
exports.isConnected = isConnected;
exports.onError = onError;
exports.onChangeStatus = onChangeStatus;
exports.onChangeMethod = onChangeMethod;
/* errorChan Not a pure module */
