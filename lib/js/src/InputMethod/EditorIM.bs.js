// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");

function Impl(Editor) {
  var $$Buffer = Buffer$AgdaModeVscode.Impl(Editor);
  var log = function (param) {
    
  };
  var make = function (editor, range) {
    var start = Curry._2(Editor.pointAtOffset, editor, range[0]);
    var end_ = Curry._2(Editor.pointAtOffset, editor, range[1]);
    return {
            range: range,
            decoration: [Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, start, end_))],
            buffer: Curry._1($$Buffer.make, undefined)
          };
  };
  var withIn = function (instance, offset) {
    var match = instance.range;
    if (match[0] <= offset) {
      return offset <= match[1];
    } else {
      return false;
    }
  };
  var redocorate = function (instance, editor) {
    Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
    instance.decoration = [];
    var match = instance.range;
    var start = Curry._2(Editor.pointAtOffset, editor, match[0]);
    var end_ = Curry._2(Editor.pointAtOffset, editor, match[1]);
    instance.decoration = [Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, start, end_))];
    
  };
  var destroy = function (instance) {
    Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
    instance.decoration = [];
    
  };
  var Instance = {
    make: make,
    withIn: withIn,
    redocorate: redocorate,
    destroy: destroy
  };
  var insertBackslash = function (editor) {
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, editor, point, "\\");
                  
                }));
  };
  var insertChar = function (editor, $$char) {
    var $$char$1 = $$char.charAt(0);
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, editor, point, $$char$1);
                  
                }));
  };
  var checkCursorPositions = function (self, editor, points) {
    var offsets = Belt_Array.map(points, Curry._1(Editor.offsetAtPoint, editor));
    Curry._1(log, "\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                      return String(prim);
                    }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, (function (i) {
                        return "(" + (String(i.range[0]) + (", " + (String(i.range[1]) + ")")));
                      }))))));
    self.instances = Belt_Array.keep(self.instances, (function (instance) {
            var survived = Belt_Array.some(offsets, (function (param) {
                    return withIn(instance, param);
                  }));
            if (!survived) {
              destroy(instance);
            }
            return survived;
          }));
    self.cursorsToBeChecked = undefined;
    if (self.instances.length === 0) {
      Curry._1(self.onAction.emit, /* Deactivate */1);
      return Curry._1(self.eventEmitter.emit, /* Deactivate */2);
    }
    
  };
  var updateView = function (self) {
    return Belt_Option.forEach(Belt_Array.get(self.instances, 0), (function (instance) {
                  return Curry._1(self.onAction.emit, /* Update */Caml_chrome_debugger.variant("Update", 1, [
                                Curry._1($$Buffer.toSequence, instance.buffer),
                                instance.buffer.translation,
                                instance.buffer.candidateIndex
                              ]));
                }));
  };
  var applyRewrites = function (self, editor, rewrites) {
    var go = function (accum, param) {
      if (!param) {
        return $$Promise.resolved(undefined);
      }
      var match = param[0];
      var range = match.range;
      var end_ = range[1];
      var start = range[0];
      var rewrites = param[1];
      var instance = match.instance;
      var text = match.text;
      var delta = text.length - (end_ - start | 0) | 0;
      Curry._1(log, "!!! " + (text + (" (" + (String(accum + start | 0) + ("," + (String(accum + end_ | 0) + (") => (" + (String(accum + start | 0) + ("," + (String((accum + end_ | 0) + delta | 0) + (") " + String(accum))))))))))));
      var editorRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, start + accum | 0), Curry._2(Editor.pointAtOffset, editor, end_ + accum | 0));
      return $$Promise.flatMap($$Promise.flatMap(Curry._2(Editor.deleteText, editor, editorRange), (function (param) {
                        return Curry._3(Editor.insertText, editor, Curry._1(Editor.$$Range.start, editorRange), text);
                      })), (function (param) {
                    if (instance !== undefined) {
                      instance.range = /* tuple */[
                        accum + start | 0,
                        (accum + end_ | 0) + delta | 0
                      ];
                      redocorate(instance, editor);
                    }
                    return go(accum + delta | 0, rewrites);
                  }));
    };
    self.busy = true;
    return $$Promise.get(go(0, Belt_List.fromArray(rewrites)), (function (param) {
                  Curry._1(self.eventEmitter.emit, /* Change */0);
                  self.busy = false;
                  var points = self.cursorsToBeChecked;
                  if (points !== undefined) {
                    return checkCursorPositions(self, editor, points);
                  }
                  
                }));
  };
  var moveUp = function (self, editor) {
    var rewrites = Belt_Array.keepMap(self.instances, (function (instance) {
            instance.buffer = Curry._1($$Buffer.moveUp, instance.buffer);
            return Belt_Option.map(Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex), (function (symbol) {
                          return {
                                  range: instance.range,
                                  text: symbol,
                                  instance: instance
                                };
                        }));
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveRight = function (self, editor) {
    var rewrites = Belt_Array.keepMap(self.instances, (function (instance) {
            instance.buffer = Curry._1($$Buffer.moveRight, instance.buffer);
            return Belt_Option.map(Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex), (function (symbol) {
                          return {
                                  range: instance.range,
                                  text: symbol,
                                  instance: instance
                                };
                        }));
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveDown = function (self, editor) {
    var rewrites = Belt_Array.keepMap(self.instances, (function (instance) {
            instance.buffer = Curry._1($$Buffer.moveDown, instance.buffer);
            return Belt_Option.map(Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex), (function (symbol) {
                          return {
                                  range: instance.range,
                                  text: symbol,
                                  instance: instance
                                };
                        }));
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveLeft = function (self, editor) {
    var rewrites = Belt_Array.keepMap(self.instances, (function (instance) {
            instance.buffer = Curry._1($$Buffer.moveLeft, instance.buffer);
            return Belt_Option.map(Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex), (function (symbol) {
                          return {
                                  range: instance.range,
                                  text: symbol,
                                  instance: instance
                                };
                        }));
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var chooseSymbol = function (self, editor, symbol) {
    var rewrites = Belt_Array.map(self.instances, (function (instance) {
            return {
                    range: instance.range,
                    text: symbol,
                    instance: instance
                  };
          }));
    return applyRewrites(self, editor, rewrites);
  };
  var activate = function (self, editor, ranges) {
    self.activated = true;
    Curry._1(self.eventEmitter.emit, /* Activate */1);
    Curry._2(Editor.setContext, "agdaModeTyping", true);
    self.instances = Belt_Array.map(ranges.sort((function (x, y) {
                return Caml_primitive.caml_int_compare(x[0], y[0]);
              })), (function (param) {
            return make(editor, param);
          }));
    var updateInstanceOffsets = function (changes) {
      var changes$1 = changes.sort((function (x, y) {
              return Caml_primitive.caml_int_compare(x.offset, y.offset);
            }));
      var go = function (_accum, _param) {
        while(true) {
          var param = _param;
          var accum = _accum;
          var match = param[0];
          if (match) {
            var match$1 = param[1];
            if (!match$1) {
              return /* [] */0;
            }
            var is = match$1[1];
            var instance = match$1[0];
            var cs = match[1];
            var change = match[0];
            var match$2 = instance.range;
            var end_ = match$2[1];
            var start = match$2[0];
            var delta = change.insertText.length - change.replaceLength | 0;
            if (withIn(instance, change.offset)) {
              instance.range = /* tuple */[
                accum + start | 0,
                (accum + end_ | 0) + delta | 0
              ];
              return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                        /* tuple */[
                          instance,
                          {
                            offset: change.offset + accum | 0,
                            insertText: change.insertText,
                            replaceLength: change.replaceLength
                          }
                        ],
                        go(accum + delta | 0, /* tuple */[
                              cs,
                              is
                            ])
                      ]);
            }
            if (change.offset < instance.range[0]) {
              _param = /* tuple */[
                cs,
                /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    instance,
                    is
                  ])
              ];
              _accum = accum + delta | 0;
              continue ;
            }
            instance.range = /* tuple */[
              accum + start | 0,
              accum + end_ | 0
            ];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* tuple */[
                        instance,
                        undefined
                      ],
                      go(accum, /* tuple */[
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                change,
                                cs
                              ]),
                            is
                          ])
                    ]);
          }
          var match$3 = param[1];
          if (match$3) {
            return Belt_List.map(/* :: */Caml_chrome_debugger.simpleVariant("::", [
                          match$3[0],
                          match$3[1]
                        ]), (function (i) {
                          return /* tuple */[
                                  i,
                                  undefined
                                ];
                        }));
          } else {
            return /* [] */0;
          }
        };
      };
      var instancesWithChanges = Belt_List.toArray(go(0, /* tuple */[
                Belt_List.fromArray(changes$1),
                Belt_List.fromArray(self.instances)
              ]));
      var rewrites = [];
      self.instances = Belt_Array.keepMap(instancesWithChanges, (function (param) {
              var change = param[1];
              var instance = param[0];
              if (change === undefined) {
                return instance;
              }
              var match = Curry._3($$Buffer.reflectEditorChange, instance.buffer, instance.range[0], change);
              var buffer = match[0];
              Belt_Option.forEach(match[1], (function (text) {
                      rewrites.push({
                            range: instance.range,
                            text: text,
                            instance: buffer.translation.further ? instance : undefined
                          });
                      
                    }));
              if (buffer.translation.further) {
                instance.buffer = buffer;
                return instance;
              } else {
                destroy(instance);
                return ;
              }
            }));
      return rewrites;
    };
    self.handles.push(Curry._1(Editor.onChangeCursorPosition, (function (points) {
                if (self.busy) {
                  self.cursorsToBeChecked = points;
                  return ;
                } else {
                  return checkCursorPositions(self, editor, points);
                }
              })));
    self.handles.push(Curry._1(Editor.onChange, (function (changes) {
                if (!(!self.busy && changes.length !== 0)) {
                  return ;
                }
                var rewrites = updateInstanceOffsets(changes);
                applyRewrites(self, editor, rewrites);
                return updateView(self);
              })));
    
  };
  var deactivate = function (self) {
    Curry._2(Editor.setContext, "agdaModeTyping", false);
    Curry._1(self.eventEmitter.emit, /* Deactivate */2);
    Belt_Array.forEach(self.instances, destroy);
    self.instances = [];
    self.activated = false;
    self.cursorsToBeChecked = undefined;
    self.busy = false;
    Belt_Array.forEach(self.handles, Editor.Disposable.dispose);
    self.handles = [];
    
  };
  var make$1 = function (eventEmitter) {
    return {
            onAction: Event$AgdaModeVscode.make(undefined),
            instances: [],
            activated: false,
            cursorsToBeChecked: undefined,
            busy: false,
            handles: [],
            eventEmitter: eventEmitter
          };
  };
  return {
          $$Buffer: $$Buffer,
          printLog: false,
          log: log,
          Instance: Instance,
          insertBackslash: insertBackslash,
          insertChar: insertChar,
          checkCursorPositions: checkCursorPositions,
          updateView: updateView,
          applyRewrites: applyRewrites,
          moveUp: moveUp,
          moveRight: moveRight,
          moveDown: moveDown,
          moveLeft: moveLeft,
          chooseSymbol: chooseSymbol,
          activate: activate,
          deactivate: deactivate,
          make: make$1
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
