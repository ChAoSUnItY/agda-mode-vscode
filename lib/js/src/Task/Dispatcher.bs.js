// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var sendAgdaRequest = function (runTasks, state, req) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        console.log(">>> " + Response$AgdaModeVscode.toString(response));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response));
      }
      console.log(">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap(Curry._2(Task.State.sendRequestToAgda, state, req), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var log = function (prim) {
    console.log(prim);
    
  };
  var make = function (param) {
    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
              /* tuple */[
                /* Command */2,
                /* [] */0
              ],
              /* [] */0
            ]);
  };
  var spawn = function (queues, source) {
    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
              /* tuple */[
                source,
                /* [] */0
              ],
              queues
            ]);
  };
  var remove = function (queues, target) {
    var lastQueueMatched = {
      contents: undefined
    };
    return Belt_List.keepMap(queues, (function (param) {
                  var queue = param[1];
                  var source = param[0];
                  if (Caml_obj.caml_equal(source, target) && Belt_Option.isNone(lastQueueMatched.contents)) {
                    lastQueueMatched.contents = queue;
                    return ;
                  }
                  var queue$prime = lastQueueMatched.contents;
                  if (queue$prime !== undefined) {
                    lastQueueMatched.contents = undefined;
                    return /* tuple */[
                            source,
                            Belt_List.concat(queue$prime, queue)
                          ];
                  } else {
                    return /* tuple */[
                            source,
                            queue
                          ];
                  }
                }));
  };
  var addTasks = function (queues, target, tasks) {
    var concatenated = {
      contents: false
    };
    return Belt_List.keepMap(queues, (function (param) {
                  var queue = param[1];
                  var source = param[0];
                  if (Caml_obj.caml_equal(source, target) && !concatenated.contents) {
                    concatenated.contents = true;
                    return /* tuple */[
                            source,
                            Belt_List.concat(queue, tasks)
                          ];
                  } else {
                    return /* tuple */[
                            source,
                            queue
                          ];
                  }
                }));
  };
  var countBySource = function (queues, target) {
    return Belt_List.reduce(queues, 0, (function (accum, param) {
                  if (Caml_obj.caml_equal(param[0], target)) {
                    return accum + 1 | 0;
                  } else {
                    return accum;
                  }
                }));
  };
  var toString = function (queues) {
    var strings = Belt_List.toArray(Belt_List.map(queues, (function (param) {
                switch (param[0]) {
                  case /* Agda */0 :
                      return "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* View */1 :
                      return "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Command */2 :
                      return "Comm " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Misc */3 :
                      return "Misc " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  
                }
              })));
    return strings.join("\n");
  };
  var getNextTask = function (blocking, queues) {
    if (!queues) {
      return ;
    }
    var match = queues[0];
    var match$1 = match[1];
    var _source = match[0];
    if (match$1) {
      return /* tuple */[
              match$1[0],
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    _source,
                    match$1[1]
                  ],
                  queues[1]
                ])
            ];
    } else if (blocking) {
      return ;
    } else {
      return Belt_Option.map(getNextTask(blocking, queues[1]), (function (param) {
                    return /* tuple */[
                            param[0],
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* tuple */[
                                  _source,
                                  /* [] */0
                                ],
                                param[1]
                              ])
                          ];
                  }));
    }
  };
  var MultiQueue = {
    make: make,
    spawn: spawn,
    remove: remove,
    addTasks: addTasks,
    countBySource: countBySource,
    toString: toString,
    getNextTask: getNextTask
  };
  var make$1 = function (param) {
    return {
            queues: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  /* Command */2,
                  /* [] */0
                ],
                /* [] */0
              ]),
            busy: false
          };
  };
  var spawn$1 = function (self, target) {
    self.queues = spawn(self.queues, target);
    
  };
  var remove$1 = function (self, target) {
    self.queues = remove(self.queues, target);
    
  };
  var addTasks$1 = function (self, target, tasks) {
    self.queues = addTasks(self.queues, target, tasks);
    
  };
  var countBySource$1 = function (self, target) {
    return countBySource(self.queues, target);
  };
  var getNextTask$1 = function (self) {
    return Belt_Option.map(getNextTask(true, self.queues), (function (param) {
                  self.queues = param[1];
                  return param[0];
                }));
  };
  var addMiscTasks = function (self, tasks) {
    spawn$1(self, /* Misc */3);
    addTasks$1(self, /* Misc */3, tasks);
    remove$1(self, /* Misc */3);
    return $$Promise.resolved(true);
  };
  var Queues = {
    spawn: spawn$1,
    remove: remove$1,
    addTasks: addTasks$1,
    countBySource: countBySource$1,
    getNextTask: getNextTask$1,
    addMiscTasks: addMiscTasks
  };
  var executeTask = function (self, state, task) {
    if (typeof task === "number") {
      return $$Promise.map(Curry._1(Task.State.destroy, state), (function (param) {
                    return false;
                  }));
    }
    switch (task.tag | 0) {
      case /* DispatchCommand */0 :
          var tasks = Curry._1(CommandHandler.handle, task[0]);
          addTasks$1(self, /* Command */2, tasks);
          return $$Promise.resolved(true);
      case /* SendRequest */1 :
          if (countBySource(self.queues, /* Agda */0) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawn$1(self, /* Agda */0);
            $$Promise.get(sendAgdaRequest((function (tasks) {
                        addTasks$1(self, /* Agda */0, tasks);
                        return kickStart(self, state);
                      }), state, task[0]), (function (param) {
                    return remove$1(self, /* Agda */0);
                  }));
            return $$Promise.resolved(true);
          }
      case /* SendEventToView */2 :
          spawn$1(self, /* View */1);
          return $$Promise.map(Curry._2(Task.State.sendEventToView, state, task[0]), (function (param) {
                        remove$1(self, /* View */1);
                        return true;
                      }));
      case /* SendRequestToView */3 :
          var callback = task[1];
          if (countBySource(self.queues, /* View */1) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawn$1(self, /* View */1);
            return $$Promise.map($$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                              if (response !== undefined) {
                                return addTasks$1(self, /* View */1, Curry._1(callback, response));
                              }
                              
                            })), (function (param) {
                          remove$1(self, /* View */1);
                          return true;
                        }));
          }
      case /* EventFromView */4 :
          var $$event = task[0];
          var tasks$1;
          if (typeof $$event === "number") {
            tasks$1 = $$event !== 0 ? /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* Terminate */0,
                  /* [] */0
                ]) : /* [] */0;
          } else {
            var $$char = $$event[0];
            tasks$1 = $$char.tag ? /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [/* InputMethod */Caml_chrome_debugger.variant("InputMethod", 4, [/* ChooseSymbol */Caml_chrome_debugger.variant("ChooseSymbol", 2, [$$char[0]])])]),
                  /* [] */0
                ]) : /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [/* InputMethod */Caml_chrome_debugger.variant("InputMethod", 4, [/* InsertChar */Caml_chrome_debugger.variant("InsertChar", 1, [$$char[0]])])]),
                  /* [] */0
                ]);
          }
          return addMiscTasks(self, tasks$1);
      case /* Error */5 :
          var tasks$2 = Curry._1(ErrorHandler.handle, task[0]);
          return addMiscTasks(self, tasks$2);
      case /* Goal */6 :
          var tasks$3 = Curry._1(GoalHandler.handle, task[0]);
          return addMiscTasks(self, tasks$3);
      case /* WithState */7 :
          spawn$1(self, /* Misc */3);
          return $$Promise.map($$Promise.tap($$Promise.map(Curry._1(task[0], state), (function (param) {
                                return addTasks$1(self, /* Misc */3, param);
                              })), (function (param) {
                            return remove$1(self, /* Misc */3);
                          })), (function (param) {
                        return true;
                      }));
      case /* Debug */8 :
          console.log("DEBUG " + task[0]);
          return $$Promise.resolved(true);
      
    }
  };
  var kickStart = function (self, state) {
    if (self.busy) {
      return ;
    }
    var task = getNextTask$1(self);
    if (task !== undefined) {
      self.busy = true;
      return $$Promise.get(executeTask(self, state, task), (function (keepRunning) {
                    self.busy = false;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    
  };
  var Runner = {
    make: make$1,
    Queues: Queues,
    executeTask: executeTask,
    kickStart: kickStart
  };
  var make$2 = function (param) {
    return {
            blocking: {
              queues: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    /* Command */2,
                    /* [] */0
                  ],
                  /* [] */0
                ]),
              busy: false
            },
            critical: {
              queues: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    /* Command */2,
                    /* [] */0
                  ],
                  /* [] */0
                ]),
              busy: false
            }
          };
  };
  var dispatchCommand = function (self, state, command) {
    Curry._1(log, "\n\n" + (toString(self.critical.queues) + ("\n----------------------------\n" + toString(self.blocking.queues))));
    var exit = 0;
    if (typeof command === "number") {
      switch (command) {
        case /* NextGoal */2 :
        case /* PreviousGoal */3 :
        case /* Escape */8 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    } else {
      switch (command.tag | 0) {
        case /* EventFromView */3 :
        case /* InputMethod */4 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          addTasks$1(self.blocking, /* Command */2, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.blocking, state);
      case 2 :
          addTasks$1(self.critical, /* Command */2, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.critical, state);
      
    }
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          sendAgdaRequest: sendAgdaRequest,
          printLog: true,
          log: log,
          MultiQueue: MultiQueue,
          Runner: Runner,
          make: make$2,
          dispatchCommand: dispatchCommand,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
