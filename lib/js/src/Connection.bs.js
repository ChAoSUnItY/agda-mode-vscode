// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Untildify = require("untildify");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Process$AgdaModeVscode = require("./Process.bs.js");
var Response$AgdaModeVscode = require("./Response.bs.js");

function toString(x) {
  switch (x.TAG | 0) {
    case /* PathSearch */0 :
        return Curry._1(Process$AgdaModeVscode.PathSearch.$$Error.toString, x._0);
    case /* Validation */1 :
        return Curry._1(Process$AgdaModeVscode.Validation.$$Error.toString, x._0);
    case /* Process */2 :
        return Process$AgdaModeVscode.$$Error.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(x) {
  if (x) {
    return "Emacs / JSON";
  } else {
    return "Emacs";
  }
}

var Protocol = {
  toString: toString$1
};

function toString$2(self) {
  var path = "* path: " + self.path;
  var args = "* args: " + Util$AgdaModeVscode.Pretty.array(self.args);
  var version = "* version: " + self.version;
  var protocol = "* protocol: " + (
    self.protocol ? "Emacs / JSON" : "Emacs"
  );
  var os = "* platform: " + Os.type();
  return "## Parse Log\n" + (path + ("\n" + (args + ("\n" + (version + ("\n" + (protocol + ("\n" + (os + "\n")))))))));
}

function make(path, args) {
  var validator = function (output) {
    var match_ = output.match(/Agda version (.*)/);
    if (match_ === null) {
      return {
              TAG: 1,
              _0: "Cannot read Agda version",
              [Symbol.for("name")]: "Error"
            };
    }
    var version = Belt_Array.get(match_, 1);
    if (version !== undefined) {
      return {
              TAG: 0,
              _0: [
                version,
                /--interaction-json/.test(output) ? /* EmacsAndJSON */1 : /* EmacsOnly */0
              ],
              [Symbol.for("name")]: "Ok"
            };
    } else {
      return {
              TAG: 1,
              _0: "Cannot read Agda version",
              [Symbol.for("name")]: "Error"
            };
    }
  };
  var path$1 = Untildify(path);
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.Validation.run("\"" + (path$1 + "\" -V"), validator), (function (param) {
                    return {
                            path: path$1,
                            args: args,
                            version: param[0],
                            protocol: param[1]
                          };
                  })), (function (e) {
                return {
                        TAG: 1,
                        _0: e,
                        [Symbol.for("name")]: "Validation"
                      };
              }));
}

var Metadata = {
  Protocol: Protocol,
  toString: toString$2,
  make: make
};

function destroy(self) {
  Curry._1(self.process.disconnect, undefined);
  Chan$AgdaModeVscode.destroy(self.chan);
  self.encountedFirstPrompt = false;
  
}

function wire(self) {
  var toResponse = Curry._1(Parser$AgdaModeVscode.Incr.Gen.flatMap, (function (x) {
          if (x.TAG !== /* Ok */0) {
            return {
                    _0: {
                      TAG: 1,
                      _0: x._0,
                      [Symbol.for("name")]: "Error"
                    },
                    [Symbol.for("name")]: "Yield"
                  };
          }
          var tokens = x._0;
          if (tokens.TAG === /* A */0 && tokens._0 === "Agda2>") {
            return /* Stop */0;
          } else {
            return {
                    _0: Response$AgdaModeVscode.Prioritized.parse(tokens),
                    [Symbol.for("name")]: "Yield"
                  };
          }
        }));
  var mapError = function (x) {
    return Curry._2(Parser$AgdaModeVscode.Incr.Gen.map, (function (x) {
                  if (x.TAG === /* Ok */0) {
                    return {
                            TAG: 0,
                            _0: x._0,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                  var match = x._0;
                  return {
                          TAG: 1,
                          _0: {
                            TAG: 0,
                            _0: match[0],
                            _1: match[1],
                            [Symbol.for("name")]: "SExpression"
                          },
                          [Symbol.for("name")]: "Error"
                        };
                }), x);
  };
  var pipeline = Parser$AgdaModeVscode.SExpression.makeIncr(function (x) {
        var res = Curry._1(toResponse, mapError(x));
        if (res) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: {
                        _0: res._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else if (self.encountedFirstPrompt) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: /* Stop */0,
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          self.encountedFirstPrompt = true;
          return ;
        }
      });
  var onData = function (x) {
    switch (x.TAG | 0) {
      case /* Stdout */0 :
          return Belt_Array.forEach(Parser$AgdaModeVscode.split(x._0), (function (param) {
                        return Parser$AgdaModeVscode.Incr.feed(pipeline, param);
                      }));
      case /* Stderr */1 :
          return ;
      case /* Error */2 :
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 1,
                      _0: {
                        TAG: 2,
                        _0: x._0,
                        [Symbol.for("name")]: "Process"
                      },
                      [Symbol.for("name")]: "Error"
                    });
      
    }
  };
  Chan$AgdaModeVscode.on(self.process.chan, onData);
  
}

function make$1(fromConfig, toConfig) {
  var getPath = function (param) {
    var storedPath = Belt_Option.mapWithDefault(Curry._1(fromConfig, undefined), "", (function (prim) {
            return prim.trim();
          }));
    if (storedPath === "" || storedPath === ".") {
      return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run("agda"), (function (prim) {
                        return prim.trim();
                      })), (function (e) {
                    return {
                            TAG: 0,
                            _0: e,
                            [Symbol.for("name")]: "PathSearch"
                          };
                  }));
    } else {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: storedPath,
                  [Symbol.for("name")]: "Ok"
                });
    }
  };
  var args = ["--interaction"];
  return $$Promise.tapOk($$Promise.mapOk($$Promise.tapOk($$Promise.flatMapOk(getPath(undefined), (function (path) {
                            return make(path, args);
                          })), (function (metadata) {
                        Curry._1(toConfig, metadata.path);
                        
                      })), (function (metadata) {
                    return {
                            metadata: metadata,
                            process: Process$AgdaModeVscode.make(metadata.path, metadata.args),
                            chan: Chan$AgdaModeVscode.make(undefined),
                            encountedFirstPrompt: false
                          };
                  })), wire);
}

function send(request, self) {
  Curry._1(self.process.send, request);
  
}

exports.$$Error = $$Error;
exports.Metadata = Metadata;
exports.destroy = destroy;
exports.wire = wire;
exports.make = make$1;
exports.send = send;
/* os Not a pure module */
