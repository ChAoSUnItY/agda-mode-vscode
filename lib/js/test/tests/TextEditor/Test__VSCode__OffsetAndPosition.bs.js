// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Mocha$BsMocha = require("bs-mocha/lib/js/src/Mocha.bs.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Promise$BsMocha = require("bs-mocha/lib/js/src/Promise.bs.js");

var graphemeWidth = (function (string) {return [...string].length});

Mocha$BsMocha.describe_only("Conversion between Offsets and Positions")(undefined, undefined, undefined, (function (param) {
        Mocha$BsMocha.describe("`graphemeWidth`")(undefined, undefined, undefined, (function (param) {
                Mocha$BsMocha.it("should calculate the width of some grapheme cluster")(undefined, undefined, undefined, (function (param) {
                        var actual = graphemeWidth("𝐀");
                        return Assert$BsMocha.deep_equal(undefined, actual, 1);
                      }));
                return Mocha$BsMocha.it("should calculate the width of some ordinary ASCII character")(undefined, undefined, undefined, (function (param) {
                              var actual = graphemeWidth("a");
                              return Assert$BsMocha.deep_equal(undefined, actual, 1);
                            }));
              }));
        Mocha$BsMocha.describe("VSCode.TextDocument.positionAt")(undefined, undefined, undefined, (function (param) {
                var openTextDocument = Vscode.workspace.openTextDocument({
                      content: "𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇\na",
                      language: "agda"
                    });
                return Promise$BsMocha.it("should count it wrong")(undefined, undefined, undefined, (function (param) {
                              return $$Promise.Js.toBsPromise($$Promise.map(openTextDocument, (function (textDocument) {
                                                var range = new Vscode.Range(textDocument.positionAt(0), textDocument.positionAt(4));
                                                var actual = textDocument.getText(Caml_option.some(range));
                                                Assert$BsMocha.not_equal(undefined, actual, "𝐀𝐁𝐂𝐃");
                                                return Assert$BsMocha.equal(undefined, actual, "𝐀𝐁");
                                              })));
                            }));
              }));
        return Mocha$BsMocha.describe("VSCode.TextDocument.positionAt")(undefined, undefined, undefined, (function (param) {
                      var openTextDocument = Vscode.workspace.openTextDocument({
                            content: "𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇\na",
                            language: "agda"
                          });
                      return Promise$BsMocha.it("should count it wrong")(undefined, undefined, undefined, (function (param) {
                                    return $$Promise.Js.toBsPromise($$Promise.map(openTextDocument, (function (textDocument) {
                                                      var range = new Vscode.Range(textDocument.positionAt(0), textDocument.positionAt(4));
                                                      var actual = textDocument.getText(Caml_option.some(range));
                                                      Assert$BsMocha.not_equal(undefined, actual, "𝐀𝐁𝐂𝐃");
                                                      return Assert$BsMocha.equal(undefined, actual, "𝐀𝐁");
                                                    })));
                                  }));
                    }));
      }));

var Assert;

var P;

exports.Assert = Assert;
exports.P = P;
exports.graphemeWidth = graphemeWidth;
/*  Not a pure module */
