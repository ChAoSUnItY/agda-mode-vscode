// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var IM$AgdaModeVscode = require("./InputMethod/IM.bs.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Goal$AgdaModeVscode = require("./Goal.bs.js");
var Item$AgdaModeVscode = require("./View/Component/Item.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Connection$AgdaModeVscode = require("./Connection/Connection.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var ViewController$AgdaModeVscode = require("./ViewController.bs.js");
var Connection__Error$AgdaModeVscode = require("./Connection/Connection__Error.bs.js");

function make(param) {
  return {
          queue: [],
          busy: false
        };
}

function kickStart(self) {
  if (self.busy) {
    return ;
  }
  var thunk = self.queue.shift();
  if (thunk !== undefined) {
    self.busy = true;
    return $$Promise.get(Curry._1(thunk, undefined), (function (param) {
                  self.busy = false;
                  return kickStart(self);
                }));
  }
  
}

function push(self, sendRequestAndHandleResponses, request) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var thunk = function (param) {
    return $$Promise.tap(Curry._1(sendRequestAndHandleResponses, request), resolve);
  };
  self.queue.push(thunk);
  kickStart(self);
  return match[0];
}

var RequestQueue = {
  make: make,
  push: push
};

function make$1(param) {
  return {
          display: undefined,
          prompt: undefined
        };
}

function cacheEvent(self, $$event) {
  if (typeof $$event === "number" || $$event.TAG !== /* Display */0) {
    return ;
  } else {
    self.display = [
      $$event._0,
      $$event._1
    ];
    return ;
  }
}

function cacheRequest(self, $$event, callback) {
  self.prompt = [
    $$event._0,
    $$event._1,
    callback
  ];
  
}

function clearPrompt(self) {
  self.prompt = undefined;
  
}

function restore(self, view) {
  var match = self.prompt;
  if (match !== undefined) {
    ViewController$AgdaModeVscode.sendRequest(view, {
          _0: match[0],
          _1: match[1],
          [Symbol.for("name")]: "Prompt"
        }, match[2]);
    return ;
  } else {
    return Belt_Option.forEach(self.display, (function (param) {
                  ViewController$AgdaModeVscode.sendEvent(view, {
                        TAG: 0,
                        _0: param[0],
                        _1: param[1],
                        [Symbol.for("name")]: "Display"
                      });
                  
                }));
  }
}

var ViewCache = {
  make: make$1,
  cacheEvent: cacheEvent,
  cacheRequest: cacheRequest,
  clearPrompt: clearPrompt,
  restore: restore
};

function setPrompt(value) {
  Vscode.commands.executeCommand("setContext", "agdaModePrompting", value);
  
}

function setIM(value) {
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", value);
  
}

var Context = {
  setPrompt: setPrompt,
  setIM: setIM
};

function sendEvent(state, $$event) {
  cacheEvent(state.viewCache, $$event);
  return ViewController$AgdaModeVscode.sendEvent(state.view, $$event);
}

function activate(state) {
  return restore(state.viewCache, state.view);
}

function reveal(state) {
  return ViewController$AgdaModeVscode.reveal(state.view);
}

function display(state, header, body) {
  return sendEvent(state, {
              TAG: 0,
              _0: header,
              _1: body,
              [Symbol.for("name")]: "Display"
            });
}

function displayInAppendMode(state, header, body) {
  return sendEvent(state, {
              TAG: 1,
              _0: header,
              _1: body,
              [Symbol.for("name")]: "Append"
            });
}

function displayOutOfGoalError(state) {
  return display(state, {
              TAG: 3,
              _0: "Out of goal",
              [Symbol.for("name")]: "Error"
            }, [Item$AgdaModeVscode.plainText("Please place the cursor in a goal")]);
}

function displayConnectionError(state, error) {
  var match = Connection__Error$AgdaModeVscode.toString(error);
  return display(state, {
              TAG: 3,
              _0: "Connection Error: " + match[0],
              [Symbol.for("name")]: "Error"
            }, [Item$AgdaModeVscode.plainText(match[1])]);
}

function displayConnectionStatus(state, status) {
  if (status.TAG === /* Emacs */0) {
    return sendEvent(state, {
                TAG: 2,
                _0: "Emacs",
                [Symbol.for("name")]: "SetStatus"
              });
  } else if (status._1.TAG === /* ViaStdIO */0) {
    return sendEvent(state, {
                TAG: 2,
                _0: "LSP",
                [Symbol.for("name")]: "SetStatus"
              });
  } else {
    return sendEvent(state, {
                TAG: 2,
                _0: "LSP (TCP)",
                [Symbol.for("name")]: "SetStatus"
              });
  }
}

function updateIM(state, $$event) {
  return sendEvent(state, {
              TAG: 4,
              _0: $$event,
              [Symbol.for("name")]: "InputMethod"
            });
}

function updatePromptIM(state, content) {
  return sendEvent(state, {
              TAG: 3,
              _0: content,
              [Symbol.for("name")]: "PromptIMUpdate"
            });
}

function prompt(state, header, prompt$1, callbackOnPromptSuccess) {
  Vscode.commands.executeCommand("setContext", "agdaModePrompting", true);
  ViewController$AgdaModeVscode.focus(state.view);
  var request = {
    _0: header,
    _1: prompt$1,
    [Symbol.for("name")]: "Prompt"
  };
  var callback = function (response) {
    if (response) {
      return $$Promise.map(Curry._1(callbackOnPromptSuccess, response._0), (function (param) {
                    Vscode.commands.executeCommand("setContext", "agdaModePrompting", false);
                    Editor$AgdaModeVscode.focus(state.document);
                    state.viewCache.prompt = undefined;
                    
                  }));
    } else {
      Vscode.commands.executeCommand("setContext", "agdaModePrompting", false);
      Editor$AgdaModeVscode.focus(state.document);
      state.viewCache.prompt = undefined;
      restore(state.viewCache, state.view);
      return $$Promise.resolved(undefined);
    }
  };
  cacheRequest(state.viewCache, request, callback);
  return ViewController$AgdaModeVscode.sendRequest(state.view, request, callback);
}

function interruptPrompt(state) {
  return $$Promise.tap(sendEvent(state, /* PromptInterrupt */0), (function (param) {
                Vscode.commands.executeCommand("setContext", "agdaModePrompting", false);
                Editor$AgdaModeVscode.focus(state.document);
                state.viewCache.prompt = undefined;
                return restore(state.viewCache, state.view);
              }));
}

var View = {
  activate: activate,
  reveal: reveal,
  display: display,
  displayInAppendMode: displayInAppendMode,
  displayOutOfGoalError: displayOutOfGoalError,
  displayConnectionError: displayConnectionError,
  displayConnectionStatus: displayConnectionStatus,
  updateIM: updateIM,
  updatePromptIM: updatePromptIM,
  prompt: prompt,
  interruptPrompt: interruptPrompt
};

function sendRequest(state, handleResponse, request) {
  return push(state.agdaRequestQueue, (function (request) {
                var onResponse = function (result) {
                  if (result.TAG === /* Ok */0) {
                    return Curry._1(handleResponse, result._0);
                  } else {
                    return displayConnectionError(state, result._0);
                  }
                };
                return $$Promise.flatMap(Connection$AgdaModeVscode.sendRequest(state.globalStoragePath, Config$AgdaModeVscode.Connection.useAgdaLanguageServer(undefined), state.document, request, onResponse), (function (result) {
                              if (result.TAG === /* Ok */0) {
                                return displayConnectionStatus(state, result._0);
                              } else {
                                return displayConnectionError(state, result._0);
                              }
                            }));
              }), request);
}

function destroy(state, alsoRemoveFromRegistry) {
  if (alsoRemoveFromRegistry) {
    Chan$AgdaModeVscode.emit(state.onRemoveFromRegistry, undefined);
  }
  Chan$AgdaModeVscode.destroy(state.onRemoveFromRegistry);
  Belt_Array.forEach(state.goals, Goal$AgdaModeVscode.destroy);
  Decoration$AgdaModeVscode.destroy(state.decoration);
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  return Connection$AgdaModeVscode.stop(undefined);
}

function make$2(chan, globalStoragePath, editor, view) {
  return {
          editor: editor,
          document: editor.document,
          view: view,
          viewCache: {
            display: undefined,
            prompt: undefined
          },
          goals: [],
          decoration: Decoration$AgdaModeVscode.make(undefined),
          cursor: undefined,
          editorIM: IM$AgdaModeVscode.make(chan),
          promptIM: IM$AgdaModeVscode.make(chan),
          subscriptions: [],
          onRemoveFromRegistry: Chan$AgdaModeVscode.make(undefined),
          agdaRequestQueue: {
            queue: [],
            busy: false
          },
          globalStoragePath: globalStoragePath
        };
}

exports.RequestQueue = RequestQueue;
exports.ViewCache = ViewCache;
exports.Context = Context;
exports.View = View;
exports.sendRequest = sendRequest;
exports.destroy = destroy;
exports.make = make$2;
/* vscode Not a pure module */
