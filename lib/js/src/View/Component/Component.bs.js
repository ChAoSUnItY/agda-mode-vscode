// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Common$AgdaModeVscode = require("../../Common.bs.js");
var Emacs__Parser$AgdaModeVscode = require("../Emacs/Emacs__Parser.bs.js");
var Component__Link$AgdaModeVscode = require("./Component__Link.bs.js");

function toString(x) {
  switch (x.TAG | 0) {
    case /* Icon */1 :
        return "[Icon " + x._0 + "]";
    case /* PlainText */0 :
    case /* Link */2 :
        return x._0;
    case /* Location */3 :
        return Curry._1(Common$AgdaModeVscode.Agda.$$Location.toString, x._0);
    
  }
}

var Segment = {
  toString: toString
};

function toSegments(x) {
  return x._0;
}

function concatMany(xs) {
  return {
          _0: Belt_Array.concatMany(Belt_Array.map(xs, toSegments)),
          [Symbol.for("name")]: "Text"
        };
}

var empty = {
  _0: [],
  [Symbol.for("name")]: "Text"
};

function plainText(className, s) {
  return {
          _0: [{
              TAG: 0,
              _0: s,
              _1: className,
              [Symbol.for("name")]: "PlainText"
            }],
          [Symbol.for("name")]: "Text"
        };
}

function link(text, jumpOpt, hoverOpt, className, loc) {
  var jump = jumpOpt !== undefined ? jumpOpt : true;
  var hover = hoverOpt !== undefined ? hoverOpt : false;
  return {
          _0: [{
              TAG: 2,
              _0: text,
              _1: className,
              _2: jump,
              _3: hover,
              _4: {
                TAG: 0,
                _0: loc,
                [Symbol.for("name")]: "ToLocation"
              },
              [Symbol.for("name")]: "Link"
            }],
          [Symbol.for("name")]: "Text"
        };
}

function hole(text, jumpOpt, hoverOpt, className, holeIndex) {
  var jump = jumpOpt !== undefined ? jumpOpt : true;
  var hover = hoverOpt !== undefined ? hoverOpt : false;
  return {
          _0: [{
              TAG: 2,
              _0: text,
              _1: className,
              _2: jump,
              _3: hover,
              _4: {
                TAG: 1,
                _0: holeIndex,
                [Symbol.for("name")]: "ToHole"
              },
              [Symbol.for("name")]: "Link"
            }],
          [Symbol.for("name")]: "Text"
        };
}

function $$location($$location$1, abbr) {
  return {
          _0: [{
              TAG: 3,
              _0: $$location$1,
              _1: abbr,
              [Symbol.for("name")]: "Location"
            }],
          [Symbol.for("name")]: "Text"
        };
}

function toString$1(segments) {
  return Belt_Array.map(segments._0, toString).join("");
}

function parse(raw) {
  return {
          _0: Belt_Array.mapWithIndex(Belt_Array.keepMap(raw.split(/([^\(\)\s]+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+))/), (function (x) {
                      return x;
                    })), (function (i, token) {
                  var match = i % 2;
                  if (match !== 1) {
                    return {
                            TAG: 0,
                            _0: token,
                            _1: undefined,
                            [Symbol.for("name")]: "PlainText"
                          };
                  } else {
                    return Belt_Option.mapWithDefault(Curry._1(Common$AgdaModeVscode.Agda.$$Location.parse, token), {
                                TAG: 0,
                                _0: token,
                                _1: undefined,
                                [Symbol.for("name")]: "PlainText"
                              }, (function (x) {
                                  return {
                                          TAG: 3,
                                          _0: x,
                                          _1: false,
                                          [Symbol.for("name")]: "Location"
                                        };
                                }));
                  }
                })),
          [Symbol.for("name")]: "Text"
        };
}

function Component$Text(Props) {
  var text = Props.text;
  return React.createElement("span", undefined, Belt_Array.mapWithIndex(text._0, (function (i, x) {
                    switch (x.TAG | 0) {
                      case /* PlainText */0 :
                          var className = x._1;
                          var plainText = x._0;
                          if (className !== undefined) {
                            return React.createElement("span", {
                                        key: String(i),
                                        className: Belt_Array.joinWith(className, " ", (function (x) {
                                                return x;
                                              }))
                                      }, plainText);
                          } else {
                            return plainText;
                          }
                      case /* Icon */1 :
                          return React.createElement("div", {
                                      className: "codicon codicon-" + x._0
                                    });
                      case /* Link */2 :
                          var className$1 = x._1;
                          var text = x._0;
                          if (className$1 === undefined) {
                            return React.createElement(Component__Link$AgdaModeVscode.make, {
                                        target: x._4,
                                        jump: x._2,
                                        hover: x._3,
                                        children: text,
                                        key: String(i)
                                      });
                          }
                          var className$2 = Belt_List.fromArray(className$1);
                          return React.createElement(Component__Link$AgdaModeVscode.make, {
                                      target: x._4,
                                      jump: x._2,
                                      hover: x._3,
                                      className: className$2,
                                      children: text,
                                      key: String(i)
                                    });
                      case /* Location */3 :
                          var $$location = x._0;
                          if (x._1) {
                            return React.createElement(Component__Link$AgdaModeVscode.make, {
                                        target: {
                                          TAG: 0,
                                          _0: $$location,
                                          [Symbol.for("name")]: "ToLocation"
                                        },
                                        jump: true,
                                        children: React.createElement("div", {
                                              className: "codicon codicon-link"
                                            }),
                                        key: String(i)
                                      });
                          } else {
                            return React.createElement(Component__Link$AgdaModeVscode.make, {
                                        target: {
                                          TAG: 0,
                                          _0: $$location,
                                          [Symbol.for("name")]: "ToLocation"
                                        },
                                        jump: true,
                                        children: null,
                                        key: String(i)
                                      }, React.createElement("div", {
                                            className: "codicon codicon-link"
                                          }), Curry._1(Common$AgdaModeVscode.Agda.$$Location.toString, $$location));
                          }
                      
                    }
                  })));
}

var $$Text = {
  Segment: Segment,
  toSegments: toSegments,
  concatMany: concatMany,
  empty: empty,
  plainText: plainText,
  link: link,
  hole: hole,
  $$location: $$location,
  toString: toString$1,
  parse: parse,
  make: Component$Text
};

function toString$2(x) {
  switch (x.TAG | 0) {
    case /* Plain */0 :
        return x._0;
    case /* QuestionMark */1 :
        return "?" + String(x._0);
    case /* Underscore */2 :
        return "_" + x._0;
    
  }
}

function toText(x) {
  switch (x.TAG | 0) {
    case /* Plain */0 :
        return plainText(["expr"], x._0);
    case /* QuestionMark */1 :
        var i = x._0;
        return hole("?" + String(i), true, true, [
                    "expr",
                    "question-mark"
                  ], i);
    case /* Underscore */2 :
        return plainText(["expr underscore"], "_" + x._0);
    
  }
}

var Term = {
  toString: toString$2,
  toText: toText
};

function toString$3(xs) {
  return Caml_splice_call.spliceObjApply(" ", "concat", [Belt_Array.map(xs, toString$2)]);
}

function parse$1(raw) {
  var __x = raw.trim();
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(__x.split(/(\?\d+)|(\_\d+[^\}\)\s]*)/), (function (i, token) {
                    var match = i % 3;
                    if (match !== 1) {
                      if (match !== 2) {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 0,
                                              _0: x,
                                              [Symbol.for("name")]: "Plain"
                                            };
                                    }));
                      } else {
                        return Belt_Option.map(token, (function (x) {
                                      return {
                                              TAG: 2,
                                              _0: x,
                                              [Symbol.for("name")]: "Underscore"
                                            };
                                    }));
                      }
                    } else {
                      return Belt_Option.map(Belt_Option.flatMap(Belt_Option.map(token, (function (param) {
                                            return param.slice(1);
                                          })), Pervasives.int_of_string_opt), (function (x) {
                                    return {
                                            TAG: 1,
                                            _0: x,
                                            [Symbol.for("name")]: "QuestionMark"
                                          };
                                  }));
                    }
                  })), (function (x) {
                return x;
              }));
}

function toText$1(xs) {
  return concatMany(Belt_Array.map(xs, toText));
}

var Expr = {
  toString: toString$3,
  parse: parse$1,
  toText: toText$1
};

function toString$4(x) {
  if (x.TAG === /* OfType */0) {
    return toString$1(x._0) + (" : " + toString$1(x._1));
  } else {
    return toString$1(x._0);
  }
}

var partial_arg = /^([^\:]*) \: ((?:\n|.)+)/;

function parseOfType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg, (function (captured) {
                return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse$1), (function (type_) {
                              return Belt_Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse$1), (function (term) {
                                            return {
                                                    TAG: 0,
                                                    _0: concatMany(Belt_Array.map(term, toText)),
                                                    _1: concatMany(Belt_Array.map(type_, toText)),
                                                    [Symbol.for("name")]: "OfType"
                                                  };
                                          }));
                            }));
              }), param);
}

var partial_arg$1 = /^Type ((?:\n|.)+)/;

function parseJustType(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$1, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse$1), (function (type_) {
                              return {
                                      TAG: 1,
                                      _0: concatMany(Belt_Array.map(type_, toText)),
                                      [Symbol.for("name")]: "JustType"
                                    };
                            }));
              }), param);
}

var partial_arg$2 = /^Sort ((?:\n|.)+)/;

function parseJustSort(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$2, (function (captured) {
                return Belt_Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse$1), (function (sort) {
                              return {
                                      TAG: 2,
                                      _0: concatMany(Belt_Array.map(sort, toText)),
                                      [Symbol.for("name")]: "JustSort"
                                    };
                            }));
              }), param);
}

function parseOthers(raw) {
  return Belt_Option.map(parse$1(raw), (function (raw$prime) {
                return {
                        TAG: 3,
                        _0: concatMany(Belt_Array.map(raw$prime, toText)),
                        [Symbol.for("name")]: "Others"
                      };
              }));
}

var partial_arg$3 = [
  parseOfType,
  parseJustType,
  parseJustSort,
  parseOthers
];

function parse$2(param) {
  return Emacs__Parser$AgdaModeVscode.choice(partial_arg$3, param);
}

function Component$OutputConstraint(Props) {
  var value = Props.value;
  var $$location = Props.location;
  var $$location$1 = Belt_Option.mapWithDefault($$location, null, (function ($$location) {
          return React.createElement(Component__Link$AgdaModeVscode.make, {
                      target: {
                        TAG: 0,
                        _0: $$location,
                        [Symbol.for("name")]: "ToLocation"
                      },
                      jump: true,
                      children: React.createElement("div", {
                            className: "codicon codicon-link"
                          })
                    });
        }));
  switch (value.TAG | 0) {
    case /* OfType */0 :
        return React.createElement("li", {
                    className: "unlabeled-item"
                  }, React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: value._0
                          }), " : ", React.createElement(Component$Text, {
                            text: value._1
                          }), $$location$1));
    case /* JustType */1 :
        return React.createElement("li", {
                    className: "unlabeled-item"
                  }, React.createElement("div", {
                        className: "item-content"
                      }, "Type ", React.createElement(Component$Text, {
                            text: value._0
                          }), $$location$1));
    case /* JustSort */2 :
        return React.createElement("li", {
                    className: "unlabeled-item"
                  }, React.createElement("div", {
                        className: "item-content"
                      }, "Sort ", React.createElement(Component$Text, {
                            text: value._0
                          }), $$location$1));
    case /* Others */3 :
        return React.createElement("li", {
                    className: "unlabeled-item"
                  }, React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: value._0
                          }), $$location$1));
    
  }
}

var OutputConstraint = {
  toString: toString$4,
  parseOfType: parseOfType,
  parseJustType: parseJustType,
  parseJustSort: parseJustSort,
  parseOthers: parseOthers,
  parse: parse$2,
  make: Component$OutputConstraint
};

function toString$5(x) {
  var $$location = x._1;
  var c = x._0;
  if ($$location !== undefined) {
    return "Output " + (toString$4(c) + (" " + Curry._1(Common$AgdaModeVscode.Agda.$$Location.toString, $$location)));
  } else {
    return "Output " + toString$4(c);
  }
}

function parseOutputWithoutLocation(raw) {
  return Belt_Option.map(Curry._1(parse$2, raw), (function (x) {
                return {
                        _0: x,
                        _1: undefined,
                        [Symbol.for("name")]: "Output"
                      };
              }));
}

var partial_arg$4 = /((?:\n|.)*\S+)\s*\[ at ([^\]]+) \]/;

function parseOutputWithLocation(param) {
  return Emacs__Parser$AgdaModeVscode.captures(partial_arg$4, (function (captured) {
                return Belt_Option.map(Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 1), (function (x) {
                                      return x;
                                    })), parse$2), (function (oc) {
                              var r = Belt_Option.flatMap(Belt_Option.flatMap(Belt_Array.get(captured, 2), (function (x) {
                                          return x;
                                        })), Common$AgdaModeVscode.Agda.$$Location.parse);
                              return {
                                      _0: oc,
                                      _1: r,
                                      [Symbol.for("name")]: "Output"
                                    };
                            }));
              }), param);
}

function parse$3(raw) {
  var locRe = /\[ at (\S+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+)) \]$/;
  var hasLocation = locRe.test(raw);
  if (hasLocation) {
    return Curry._1(parseOutputWithLocation, raw);
  } else {
    return parseOutputWithoutLocation(raw);
  }
}

function Component$Output(Props) {
  var value = Props.value;
  return React.createElement(Component$OutputConstraint, {
              value: value._0,
              location: value._1
            });
}

var Output = {
  toString: toString$5,
  parseOutputWithoutLocation: parseOutputWithoutLocation,
  parseOutputWithLocation: parseOutputWithLocation,
  parse: parse$3,
  make: Component$Output
};

function toString$6(x) {
  switch (x.TAG | 0) {
    case /* PlainText */0 :
        return "Item [PlainText] " + toString$1(x._0);
    case /* Error */1 :
        return "Item [Error] " + toString$1(x._0);
    case /* Warning */2 :
        return "Item [Warning] " + toString$1(x._0);
    case /* Goal */3 :
        return "Item [Goal] " + toString$1(x._0);
    case /* Have */4 :
        return "Item [Have] " + toString$1(x._0);
    case /* Output */5 :
        return "Item [Output] " + toString$5(x._0);
    
  }
}

function Component$Item(Props) {
  var item = Props.item;
  switch (item.TAG | 0) {
    case /* PlainText */0 :
        return React.createElement("li", {
                    className: "labeled-item"
                  }, React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: item._0
                          })));
    case /* Error */1 :
        return React.createElement("li", {
                    className: "labeled-item error"
                  }, React.createElement("div", {
                        className: "item-label"
                      }, "Error"), React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: item._0
                          })));
    case /* Warning */2 :
        return React.createElement("li", {
                    className: "labeled-item warning"
                  }, React.createElement("div", {
                        className: "item-label"
                      }, "Warning"), React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: item._0
                          })));
    case /* Goal */3 :
        return React.createElement("li", {
                    className: "labeled-item special"
                  }, React.createElement("div", {
                        className: "item-label"
                      }, "Goal"), React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: item._0
                          })));
    case /* Have */4 :
        return React.createElement("li", {
                    className: "labeled-item special"
                  }, React.createElement("div", {
                        className: "item-label"
                      }, "Have"), React.createElement("div", {
                        className: "item-content"
                      }, React.createElement(Component$Text, {
                            text: item._0
                          })));
    case /* Output */5 :
        return React.createElement(Component$Output, {
                    value: item._0
                  });
    
  }
}

var Item = {
  toString: toString$6,
  make: Component$Item
};

exports.$$Text = $$Text;
exports.Term = Term;
exports.Expr = Expr;
exports.OutputConstraint = OutputConstraint;
exports.Output = Output;
exports.Item = Item;
/* react Not a pure module */
