// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var View$AgdaModeVscode = require("../../View.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Component$AgdaModeVscode = require("../Component/Component.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./Emacs__Parser.bs.js");

function partiteMetas(xs) {
  return Emacs__Parser$AgdaModeVscode.Dict.split(xs, "metas", (function (rawMetas) {
                var metas = Emacs__Parser$AgdaModeVscode.unindent(rawMetas);
                var indexOfHiddenMetas = Belt_Array.getIndexBy(metas, (function (s) {
                        return Belt_Option.isSome(Curry._1(Component$AgdaModeVscode.Output.parseOutputWithRange, s));
                      }));
                return Emacs__Parser$AgdaModeVscode.Dict.partite(metas, (function (param) {
                              var i = param[1];
                              if (indexOfHiddenMetas !== undefined) {
                                if (i === indexOfHiddenMetas) {
                                  return "hiddenMetas";
                                } else if (i === 0) {
                                  return "interactionMetas";
                                } else {
                                  return ;
                                }
                              } else if (i === 0) {
                                return "interactionMetas";
                              } else {
                                return ;
                              }
                            }));
              }));
}

function partiteWarningsOrErrors(xs, key) {
  return Emacs__Parser$AgdaModeVscode.Dict.update(xs, key, (function (raw) {
                var partial_arg = /^\u2014{4}/;
                var hasDelimeter = Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(raw, 0), (function (param) {
                            return Caml_option.null_to_opt(param.match(partial_arg));
                          })));
                var lines = hasDelimeter ? raw.slice(1) : raw;
                var markWarningStart = function (line) {
                  return Belt_Option.isSome(Curry._1(View$AgdaModeVscode.$$Range.parse, line));
                };
                var glueBack = function (xs) {
                  var partial_arg = /at$/;
                  return Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(xs, xs.length - 1 | 0), (function (param) {
                                    return Caml_option.null_to_opt(param.match(partial_arg));
                                  })));
                };
                return Belt_Array.map(Emacs__Parser$AgdaModeVscode.Array_.mergeWithNext(Emacs__Parser$AgdaModeVscode.Array_.partite(lines, markWarningStart), glueBack), (function (param) {
                              return param.join("\n");
                            }));
              }));
}

function parseError(raw) {
  var lines = raw.split("\n");
  return Belt_Option.mapWithDefault(Js_dict.get(partiteWarningsOrErrors(Emacs__Parser$AgdaModeVscode.Dict.partite(lines, (function (param) {
                            if (param[1] === 0) {
                              return "errors";
                            }
                            
                          })), "errors"), "errors"), [], (function (entries) {
                return Belt_Array.map(entries, (function (entry) {
                              return /* Error */Caml_chrome_debugger.variant("Error", 0, [Component$AgdaModeVscode.$$Text.parse(entry)]);
                            }));
              }));
}

function parseGoalType(raw) {
  var markGoal = function (param) {
    return Belt_Option.map(Caml_option.null_to_opt(param[0].match(/^Goal:/)), (function (param) {
                  return "goal";
                }));
  };
  var markHave = function (param) {
    return Belt_Option.map(Caml_option.null_to_opt(param[0].match(/^Have:/)), (function (param) {
                  return "have";
                }));
  };
  var markMetas = function (param) {
    return Belt_Option.map(Caml_option.null_to_opt(param[0].match(/\u2014{60}/g)), (function (param) {
                  return "metas";
                }));
  };
  var partiteGoalTypeContext = function (xs) {
    return Emacs__Parser$AgdaModeVscode.Dict.partite(xs, (function (line) {
                  var v = markGoal(line);
                  if (v !== undefined) {
                    return v;
                  }
                  var v$1 = markHave(line);
                  if (v$1 !== undefined) {
                    return v$1;
                  }
                  var v$2 = markMetas(line);
                  if (v$2 !== undefined) {
                    return v$2;
                  }
                  
                }));
  };
  var removeDelimeter = function (xs) {
    return Emacs__Parser$AgdaModeVscode.Dict.update(xs, "metas", (function (param) {
                  return param.slice(1);
                }));
  };
  var lines = raw.split("\n");
  var dictionary = partiteMetas(removeDelimeter(partiteGoalTypeContext(lines)));
  return Caml_splice_call.spliceObjApply([], "concat", [Belt_Array.map(Js_dict.entries(dictionary), (function (param) {
                      var lines = param[1];
                      switch (param[0]) {
                        case "goal" :
                            return Belt_Option.mapWithDefault(Component$AgdaModeVscode.Expr.parse(lines.join("\n").slice(5)), [], (function (expr) {
                                          return [/* Goal */Caml_chrome_debugger.variant("Goal", 2, [expr])];
                                        }));
                        case "have" :
                            return Belt_Option.mapWithDefault(Component$AgdaModeVscode.Expr.parse(lines.join("\n").slice(5)), [], (function (expr) {
                                          return [/* Have */Caml_chrome_debugger.variant("Have", 3, [expr])];
                                        }));
                        case "hiddenMetas" :
                            return Belt_Array.map(Belt_Array.keepMap(Belt_Array.map(lines, Component$AgdaModeVscode.Output.parseOutputWithRange), (function (x) {
                                              return x;
                                            })), (function (output) {
                                          return /* Output */Caml_chrome_debugger.variant("Output", 4, [output]);
                                        }));
                        case "interactionMetas" :
                            return Belt_Array.map(Belt_Array.keepMap(Belt_Array.map(lines, Component$AgdaModeVscode.Output.parseOutputWithoutRange), (function (x) {
                                              return x;
                                            })), (function (output) {
                                          return /* Output */Caml_chrome_debugger.variant("Output", 4, [output]);
                                        }));
                        default:
                          return [];
                      }
                    }))]);
}

exports.partiteMetas = partiteMetas;
exports.partiteWarningsOrErrors = partiteWarningsOrErrors;
exports.parseError = parseError;
exports.parseGoalType = parseGoalType;
/* View-AgdaModeVscode Not a pure module */
