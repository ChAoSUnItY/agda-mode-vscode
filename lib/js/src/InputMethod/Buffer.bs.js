// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Translator$AgdaModeVscode = require("./Translator.bs.js");

function Impl(Editor) {
  var make = function (param) {
    return {
            symbol: undefined,
            tail: ""
          };
  };
  var isEmpty = function (self) {
    if (self.symbol === undefined) {
      return self.tail === "";
    } else {
      return false;
    }
  };
  var toSequence = function (self) {
    var match = self.symbol;
    if (match !== undefined) {
      return match[1] + self.tail;
    } else {
      return self.tail;
    }
  };
  var toSurface = function (self) {
    var match = self.symbol;
    if (match !== undefined) {
      return match[0] + self.tail;
    } else {
      return self.tail;
    }
  };
  var toString = function (self) {
    return "\"" + (toSurface(self) + ("\"[" + (toSequence(self) + "]")));
  };
  var init = function (string) {
    return string.substring(0, string.length - 1 | 0);
  };
  var update = function (start, self, change) {
    var sequence = toSequence(self);
    var insertStartInTextEditor = change.offset - start | 0;
    var match = self.symbol;
    var insertStart = match !== undefined ? (insertStartInTextEditor + match[1].length | 0) - match[0].length | 0 : insertStartInTextEditor;
    var insertEnd = insertStart + change.replaceLength | 0;
    var beforeInsertedText = sequence.substring(0, insertStart);
    var afterInsertedText = sequence.substring(insertEnd);
    var newSequence = beforeInsertedText + (change.insertText + afterInsertedText);
    var translation = Translator$AgdaModeVscode.translate(newSequence);
    var symbol = translation.symbol;
    if (symbol !== undefined) {
      if (translation.further) {
        var buffer_symbol = /* tuple */[
          symbol,
          newSequence
        ];
        var buffer = {
          symbol: buffer_symbol,
          tail: ""
        };
        return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 1, [
                  buffer,
                  translation.keySuggestions,
                  translation.candidateSymbols,
                  toSurface(buffer)
                ]);
      }
      var buffer_symbol$1 = /* tuple */[
        symbol,
        newSequence
      ];
      var buffer$1 = {
        symbol: buffer_symbol$1,
        tail: ""
      };
      return /* RewriteAndStuck */Caml_chrome_debugger.variant("RewriteAndStuck", 2, [
                buffer$1,
                translation.keySuggestions,
                translation.candidateSymbols,
                toSurface(buffer$1)
              ]);
    }
    if (!translation.further) {
      return /* Stuck */1;
    }
    if (newSequence.includes(sequence)) {
      var diff = newSequence.substring(sequence.length);
      var buffer_symbol$2 = self.symbol;
      var buffer_tail = self.tail + diff;
      var buffer$2 = {
        symbol: buffer_symbol$2,
        tail: buffer_tail
      };
      return /* Update */Caml_chrome_debugger.variant("Update", 0, [
                buffer$2,
                translation.keySuggestions,
                translation.candidateSymbols
              ]);
    }
    var buffer$3 = {
      symbol: undefined,
      tail: newSequence
    };
    return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 1, [
              buffer$3,
              translation.keySuggestions,
              translation.candidateSymbols,
              toSurface(buffer$3)
            ]);
  };
  return {
          make: make,
          isEmpty: isEmpty,
          toSequence: toSequence,
          toSurface: toSurface,
          toString: toString,
          init: init,
          update: update
        };
}

exports.Impl = Impl;
/* Translator-AgdaModeVscode Not a pure module */
