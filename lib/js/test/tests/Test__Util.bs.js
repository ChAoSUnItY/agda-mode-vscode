// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

var Exn = Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

function toAbsolute(filepath) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, filepath);
  } else {
    return Process.cwd();
  }
}

var Path$1 = {
  toAbsolute: toAbsolute
};

function normalize(string) {
  return string.trim().replace(/\r\n|\r/g, "\n");
}

function serialize(xs) {
  return xs.join("\n");
}

function serializeWith(f, xs) {
  return Belt_Array.map(xs, f).join("\n");
}

function breakInput(input, breakpoints) {
  var breakpoints$prime = Belt_Array.concat([0], breakpoints);
  return Belt_Array.map(Belt_Array.mapWithIndex(breakpoints$prime, (function (i, x) {
                    var next = Belt_Array.get(breakpoints$prime, i + 1 | 0);
                    if (next !== undefined) {
                      return /* tuple */[
                              x,
                              next - x | 0
                            ];
                    } else {
                      return /* tuple */[
                              x,
                              input.length - x | 0
                            ];
                    }
                  })), (function (param) {
                return input.substr(param[0], param[1]);
              }));
}

var Strings = {
  normalize: normalize,
  serialize: serialize,
  serializeWith: serializeWith,
  breakInput: breakInput
};

function getValue(string) {
  return string[0];
}

function fromChangeObject(obj) {
  if (obj.added) {
    return /* Added */Caml_chrome_debugger.variant("Added", 0, [obj.value]);
  } else if (obj.removed) {
    return /* Removed */Caml_chrome_debugger.variant("Removed", 1, [obj.value]);
  } else {
    return /* NoChange */Caml_chrome_debugger.variant("NoChange", 2, [obj.value]);
  }
}

function wordsWithSpace(a, b) {
  return Belt_Array.map(Diff.diffWordsWithSpace(a, b), fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  Belt_Array.forEach(diffs, (function (diff) {
          if (!Belt_Option.isNone(change.contents)) {
            return ;
          }
          switch (diff.tag | 0) {
            case /* Added */0 :
                change.contents = /* Added */Caml_chrome_debugger.variant("Added", 0, [diff[0]]);
                return ;
            case /* Removed */1 :
                change.contents = /* Removed */Caml_chrome_debugger.variant("Removed", 1, [diff[0]]);
                return ;
            case /* NoChange */2 :
                count.contents = count.contents + diff[0].length | 0;
                return ;
            
          }
        }));
  return Belt_Option.map(change.contents, (function (change) {
                return /* tuple */[
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var readdir = Util.promisify((function (prim, prim$1) {
          Fs.readdir(prim, prim$1);
          
        }));
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return readdir(directoryPath$1).then((function (paths) {
                return Promise.resolve(Belt_Array.map(Belt_Array.keep(paths, isInFile), toBasename));
              }));
}

function getGoldenFilepathsSync(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return Belt_Array.map(Belt_Array.keep(Fs.readdirSync(directoryPath$1), isInFile), toBasename);
}

var FileMissing = Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function map(param, f) {
  return /* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
            param[0],
            Curry._1(f, param[1]),
            param[2]
          ]);
}

function readFile(filepath) {
  var filepath$1 = toAbsolute(filepath);
  var readFile$1 = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          
        }));
  return Promise.all([
                readFile$1(filepath$1 + ".in"),
                readFile$1(filepath$1 + ".out")
              ]).then((function (param) {
                if (param.length !== 2) {
                  return Promise.reject([
                              FileMissing,
                              filepath$1
                            ]);
                }
                var input = param[0];
                var output = param[1];
                return Promise.resolve(/* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
                              filepath$1,
                              input.toString(),
                              output.toString()
                            ]));
              }));
}

function compare(param) {
  var actual = normalize(param[1]);
  var expected = normalize(param[2]);
  Belt_Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff[0];
          var change = value.length > 100 ? value.substr(0, 100) + " ..." : value;
          var expected$prime = expected.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var actual$prime = actual.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var message = "\n\nexpected => " + (expected$prime + ("\n\nactual   => " + (actual$prime + "\n\nchange => ")));
          switch (diff.tag | 0) {
            case /* Added */0 :
                return Assert$BsMocha.fail(message + (" added \"" + (change + ("\"\n at position " + String(count)))));
            case /* Removed */1 :
                return Assert$BsMocha.fail(message + (" removed \"" + (change + ("\"\n\n at position " + String(count)))));
            case /* NoChange */2 :
                return ;
            
          }
        }));
  return Promise.resolve(undefined);
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  map: map,
  readFile: readFile,
  compare: compare
};

exports.Exn = Exn;
exports.Path = Path$1;
exports.Strings = Strings;
exports.Golden = Golden;
/* fs Not a pure module */
