// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var IM$AgdaModeVscode = require("./InputMethod/IM.bs.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Goal$AgdaModeVscode = require("./Goal.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var View$AgdaModeVscode = require("./View.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Request$AgdaModeVscode = require("./Request.bs.js");
var Connection$AgdaModeVscode = require("./Connection.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var ViewController$AgdaModeVscode = require("./ViewController.bs.js");

function make(param) {
  return {
          queue: [],
          busy: false
        };
}

function kickStart(self) {
  if (self.busy) {
    return ;
  }
  var thunk = self.queue.shift();
  if (thunk !== undefined) {
    self.busy = true;
    return $$Promise.get(Curry._1(thunk, undefined), (function (param) {
                  self.busy = false;
                  return kickStart(self);
                }));
  }
  
}

function push(self, sendRequestAndHandleResponses, request) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var thunk = function (param) {
    return $$Promise.tap(Curry._1(sendRequestAndHandleResponses, request), resolve);
  };
  self.queue.push(thunk);
  kickStart(self);
  return match[0];
}

var RequestQueue = {
  make: make,
  push: push
};

function setLoaded(value) {
  Vscode.commands.executeCommand("setContext", "agdaMode", value);
  
}

function setPrompt(value) {
  Vscode.commands.executeCommand("setContext", "agdaModePrompting", value);
  
}

function setIM(value) {
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", value);
  
}

var Context = {
  setLoaded: setLoaded,
  setPrompt: setPrompt,
  setIM: setIM
};

function reveal(state) {
  ViewController$AgdaModeVscode.reveal(state.view);
  Vscode.commands.executeCommand("setContext", "agdaMode", true);
  
}

function display(state, header, body) {
  return ViewController$AgdaModeVscode.sendEvent(state.view, {
              TAG: 0,
              _0: header,
              _1: body,
              [Symbol.for("name")]: "Display"
            });
}

function displayEmacs(state, kind, header, body) {
  return ViewController$AgdaModeVscode.sendEvent(state.view, {
              TAG: 0,
              _0: header,
              _1: {
                TAG: 1,
                _0: kind,
                _1: View$AgdaModeVscode.Header.toString(header),
                _2: body,
                [Symbol.for("name")]: "Emacs"
              },
              [Symbol.for("name")]: "Display"
            });
}

function displayOutOfGoalError(state) {
  return display(state, {
              TAG: 3,
              _0: "Out of goal",
              [Symbol.for("name")]: "Error"
            }, {
              TAG: 0,
              _0: "Please place the cursor in a goal",
              [Symbol.for("name")]: "Plain"
            });
}

function displayConnectionError(state, error) {
  var match = Connection$AgdaModeVscode.$$Error.toString(error);
  return display(state, {
              TAG: 3,
              _0: "Connection Error: " + match[0],
              [Symbol.for("name")]: "Error"
            }, {
              TAG: 0,
              _0: match[1],
              [Symbol.for("name")]: "Plain"
            });
}

function updateIM(state, $$event) {
  return ViewController$AgdaModeVscode.sendEvent(state.view, {
              TAG: 2,
              _0: $$event,
              [Symbol.for("name")]: "InputMethod"
            });
}

function updatePromptIM(state, content) {
  return ViewController$AgdaModeVscode.sendEvent(state.view, {
              TAG: 1,
              _0: content,
              [Symbol.for("name")]: "PromptIMUpdate"
            });
}

function prompt(state, header, prompt$1, callbackOnPromptSuccess) {
  Vscode.commands.executeCommand("setContext", "agdaModePrompting", true);
  ViewController$AgdaModeVscode.focus(state.view);
  return ViewController$AgdaModeVscode.sendRequest(state.view, {
              _0: header,
              _1: prompt$1,
              [Symbol.for("name")]: "Prompt"
            }, (function (response) {
                if (response) {
                  return $$Promise.map(Curry._1(callbackOnPromptSuccess, response._0), (function (param) {
                                Vscode.commands.executeCommand("setContext", "agdaModePrompting", false);
                                return Editor$AgdaModeVscode.focus(state.document);
                              }));
                } else {
                  return $$Promise.resolved(undefined);
                }
              }));
}

function interruptPrompt(state) {
  return ViewController$AgdaModeVscode.sendEvent(state.view, /* PromptInterrupt */0);
}

var View = {
  reveal: reveal,
  display: display,
  displayEmacs: displayEmacs,
  displayOutOfGoalError: displayOutOfGoalError,
  displayConnectionError: displayConnectionError,
  updateIM: updateIM,
  updatePromptIM: updatePromptIM,
  prompt: prompt,
  interruptPrompt: interruptPrompt
};

function connect(state) {
  var connection = state.connection;
  if (connection !== undefined) {
    return $$Promise.resolved({
                TAG: 0,
                _0: connection,
                [Symbol.for("name")]: "Ok"
              });
  } else {
    return $$Promise.tapOk(Connection$AgdaModeVscode.make(Config$AgdaModeVscode.getAgdaPath, Config$AgdaModeVscode.setAgdaPath), (function (conn) {
                  state.connection = conn;
                  
                }));
  }
}

function disconnect(state) {
  var connection = state.connection;
  if (connection !== undefined) {
    Connection$AgdaModeVscode.destroy(connection);
    return $$Promise.resolved(undefined);
  } else {
    return $$Promise.resolved(undefined);
  }
}

var tally = {
  contents: 0
};

var allDone = Chan$AgdaModeVscode.make(undefined);

function runNonLast(promise) {
  tally.contents = tally.contents + 1 | 0;
  return $$Promise.tap(promise, (function (param) {
                tally.contents = tally.contents - 1 | 0;
                if (tally.contents === 0) {
                  return Chan$AgdaModeVscode.emit(allDone, undefined);
                }
                
              }));
}

function onceDone(param) {
  if (tally.contents === 0) {
    return $$Promise.resolved(undefined);
  } else {
    return Chan$AgdaModeVscode.once(allDone);
  }
}

function sendRequest(state, handleResponse, request) {
  return push(state.agdaRequestQueue, (function (param) {
                var deferredLastResponses = [];
                var match = $$Promise.pending(undefined);
                var stopListener = match[1];
                var promise = match[0];
                var handle = {
                  contents: undefined
                };
                var agdaResponseListener = function (x) {
                  if (x.TAG === /* Ok */0) {
                    var match = x._0;
                    if (match) {
                      var error = match._0;
                      if (error.TAG === /* Ok */0) {
                        var response = error._0;
                        if (response.TAG === /* NonLast */0) {
                          runNonLast(Curry._1(handleResponse, response._0));
                          return ;
                        }
                        deferredLastResponses.push([
                              response._0,
                              response._1
                            ]);
                        return ;
                      }
                      var body = Parser$AgdaModeVscode.$$Error.toString(error._0);
                      display(state, {
                            TAG: 3,
                            _0: "Internal Parse Error",
                            [Symbol.for("name")]: "Error"
                          }, {
                            TAG: 0,
                            _0: body,
                            [Symbol.for("name")]: "Plain"
                          });
                      return ;
                    }
                    var deferredLastResponses$1 = Belt_Array.map(deferredLastResponses.sort(function (x, y) {
                              return Caml_primitive.caml_int_compare(x[0], y[0]);
                            }), (function (prim) {
                            return prim[1];
                          }));
                    $$Promise.flatMap($$Promise.map($$Promise.flatMap($$Promise.tap(onceDone(undefined), (function (param) {
                                        return Curry._1(stopListener, undefined);
                                      })), (function (param) {
                                    return Decoration$AgdaModeVscode.apply(state.decoration, state.editor);
                                  })), (function (param) {
                                return Belt_Array.map(deferredLastResponses$1, handleResponse);
                              })), Util$AgdaModeVscode.oneByOne);
                    return ;
                  }
                  displayConnectionError(state, x._0);
                  
                };
                return $$Promise.tap($$Promise.flatMap($$Promise.mapOk(connect(state), (function (connection) {
                                      var version = connection.metadata.version;
                                      var filepath = Parser$AgdaModeVscode.filepath(state.document.fileName);
                                      var libraryPath = Config$AgdaModeVscode.getLibraryPath(undefined);
                                      var highlightingMethod = Config$AgdaModeVscode.getHighlightingMethod(undefined);
                                      var backend = Config$AgdaModeVscode.getBackend(undefined);
                                      var encoded = Request$AgdaModeVscode.encode(state.document, version, filepath, backend, libraryPath, highlightingMethod, param);
                                      Connection$AgdaModeVscode.send(encoded, connection);
                                      return connection;
                                    })), (function (x) {
                                  if (x.TAG !== /* Ok */0) {
                                    return $$Promise.flatMap(displayConnectionError(state, x._0), (function (param) {
                                                  return promise;
                                                }));
                                  }
                                  handle.contents = Chan$AgdaModeVscode.on(x._0.chan, agdaResponseListener);
                                  return promise;
                                })), (function (param) {
                              return Belt_Option.forEach(handle.contents, (function (destroyListener) {
                                            return Curry._1(destroyListener, undefined);
                                          }));
                            }));
              }), request);
}

var Connection = {
  disconnect: disconnect,
  sendRequest: sendRequest
};

function destroy(state) {
  ViewController$AgdaModeVscode.destroy(state.view);
  Chan$AgdaModeVscode.emit(state.onRemoveFromRegistry, undefined);
  Chan$AgdaModeVscode.destroy(state.onRemoveFromRegistry);
  Belt_Array.forEach(state.goals, Goal$AgdaModeVscode.destroy);
  Decoration$AgdaModeVscode.destroy(state.decoration);
  Vscode.commands.executeCommand("setContext", "agdaMode", false);
  Belt_Array.forEach(state.subscriptions, (function (prim) {
          return prim.dispose();
        }));
  return disconnect(state);
}

function make$1(extentionPath, chan, editor) {
  Vscode.commands.executeCommand("setContext", "agdaMode", true);
  var view = ViewController$AgdaModeVscode.make(extentionPath);
  return {
          editor: editor,
          document: editor.document,
          view: view,
          connection: undefined,
          goals: [],
          decoration: Decoration$AgdaModeVscode.make(undefined),
          cursor: undefined,
          editorIM: IM$AgdaModeVscode.make(chan),
          promptIM: IM$AgdaModeVscode.make(chan),
          subscriptions: [],
          onRemoveFromRegistry: Chan$AgdaModeVscode.make(undefined),
          agdaRequestQueue: {
            queue: [],
            busy: false
          }
        };
}

exports.RequestQueue = RequestQueue;
exports.Context = Context;
exports.View = View;
exports.Connection = Connection;
exports.destroy = destroy;
exports.make = make$1;
/* allDone Not a pure module */
