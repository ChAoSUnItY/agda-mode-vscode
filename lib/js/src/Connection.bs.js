// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Net = require("net");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Untildify = require("untildify");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/lib/js/src/Json_encode.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var LSP$AgdaModeVscode = require("./LSP.bs.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Process$AgdaModeVscode = require("./Process.bs.js");
var Request$AgdaModeVscode = require("./Request.bs.js");
var Response$AgdaModeVscode = require("./Response.bs.js");

function toString(x) {
  if (typeof x === "number") {
    if (x === /* LSPCannotConnectDevServer */0) {
      return [
              "LSP: Cannot Connect to the Dev Server",
              ""
            ];
    } else {
      return [
              "Connection not established yet",
              ""
            ];
    }
  }
  switch (x.TAG | 0) {
    case /* PathSearch */0 :
        return Curry._1(Process$AgdaModeVscode.PathSearch.$$Error.toString, x._0);
    case /* Validation */1 :
        return Curry._1(Process$AgdaModeVscode.Validation.$$Error.toString, x._0);
    case /* Process */2 :
        return Process$AgdaModeVscode.$$Error.toString(x._0);
    case /* LSPInternalError */3 :
        return [
                "LSP: Internal Error",
                x._0
              ];
    case /* LSPConnection */4 :
        return [
                "LSP: Connection Failed",
                Util$AgdaModeVscode.JsError.toString(x._0)
              ];
    case /* LSPSendRequest */5 :
        return [
                "LSP: Cannot Send Request",
                Util$AgdaModeVscode.JsError.toString(x._0)
              ];
    case /* LSPClientCannotDecodeResponse */6 :
        return [
                "LSP: Client Cannot Decode Response",
                x._0 + "\n" + JSON.stringify(x._1)
              ];
    case /* LSPServerCannotDecodeRequest */7 :
        return [
                "LSP: Server Cannot Decode Request",
                x._0
              ];
    case /* ResponseParseError */8 :
        return [
                "Internal Parse Error",
                Parser$AgdaModeVscode.$$Error.toString(x._0)
              ];
    
  }
}

var $$Error = {
  toString: toString
};

var tally = {
  contents: 0
};

var allDone = Chan$AgdaModeVscode.make(undefined);

function onceDone(param) {
  if (tally.contents === 0) {
    return $$Promise.resolved(undefined);
  } else {
    return Chan$AgdaModeVscode.once(allDone);
  }
}

function destroy(self) {
  Chan$AgdaModeVscode.destroy(self.chan);
  self.encountedFirstPrompt = false;
  return Process$AgdaModeVscode.destroy(self.process);
}

function wire(self) {
  var toResponse = Curry._1(Parser$AgdaModeVscode.Incr.Gen.flatMap, (function (x) {
          if (x.TAG !== /* Ok */0) {
            return {
                    _0: {
                      TAG: 1,
                      _0: x._0,
                      [Symbol.for("name")]: "Error"
                    },
                    [Symbol.for("name")]: "Yield"
                  };
          }
          var tokens = x._0;
          if (tokens.TAG === /* A */0 && tokens._0 === "Agda2>") {
            return /* Stop */0;
          } else {
            return {
                    _0: Response$AgdaModeVscode.Prioritized.parse(tokens),
                    [Symbol.for("name")]: "Yield"
                  };
          }
        }));
  var mapError = function (x) {
    return Curry._2(Parser$AgdaModeVscode.Incr.Gen.map, (function (x) {
                  if (x.TAG === /* Ok */0) {
                    return {
                            TAG: 0,
                            _0: x._0,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                  var match = x._0;
                  return {
                          TAG: 1,
                          _0: {
                            TAG: 0,
                            _0: match[0],
                            _1: match[1],
                            [Symbol.for("name")]: "SExpression"
                          },
                          [Symbol.for("name")]: "Error"
                        };
                }), x);
  };
  var pipeline = Parser$AgdaModeVscode.SExpression.makeIncr(function (x) {
        var res = Curry._1(toResponse, mapError(x));
        if (res) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: {
                        _0: res._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else if (self.encountedFirstPrompt) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: /* Stop */0,
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          self.encountedFirstPrompt = true;
          return ;
        }
      });
  Process$AgdaModeVscode.onOutput(self.process, (function (x) {
          switch (x.TAG | 0) {
            case /* Stdout */0 :
                return Belt_Array.forEach(Parser$AgdaModeVscode.split(x._0), (function (param) {
                              return Parser$AgdaModeVscode.Incr.feed(pipeline, param);
                            }));
            case /* Stderr */1 :
                return ;
            case /* Error */2 :
                return Chan$AgdaModeVscode.emit(self.chan, {
                            TAG: 1,
                            _0: {
                              TAG: 2,
                              _0: x._0,
                              [Symbol.for("name")]: "Process"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  
}

function make(param) {
  var getPath = function (param) {
    var storedPath = Config$AgdaModeVscode.getAgdaPath(undefined);
    if (!(storedPath === "" || storedPath === ".")) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: storedPath,
                  [Symbol.for("name")]: "Ok"
                });
    }
    var agdaVersion = Config$AgdaModeVscode.getAgdaVersion(undefined);
    return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run(agdaVersion), (function (prim) {
                      return prim.trim();
                    })), (function (e) {
                  return {
                          TAG: 0,
                          _0: e,
                          [Symbol.for("name")]: "PathSearch"
                        };
                }));
  };
  var setPath = function (metadata) {
    return $$Promise.map(Config$AgdaModeVscode.setAgdaPath(metadata.path), (function (param) {
                  return {
                          TAG: 0,
                          _0: metadata,
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  };
  var args = ["--interaction"];
  return $$Promise.tapOk($$Promise.mapOk($$Promise.flatMapOk($$Promise.flatMapOk(getPath(undefined), (function (path) {
                            var validator = function (output) {
                              var match_ = output.match(/Agda version (.*)/);
                              if (match_ === null) {
                                return {
                                        TAG: 1,
                                        _0: "Cannot read Agda version",
                                        [Symbol.for("name")]: "Error"
                                      };
                              }
                              var version = Belt_Array.get(match_, 1);
                              if (version !== undefined) {
                                return {
                                        TAG: 0,
                                        _0: version,
                                        [Symbol.for("name")]: "Ok"
                                      };
                              } else {
                                return {
                                        TAG: 1,
                                        _0: "Cannot read Agda version",
                                        [Symbol.for("name")]: "Error"
                                      };
                              }
                            };
                            var path$1 = Untildify(path);
                            return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.Validation.run("\"" + (path$1 + "\" -V"), validator), (function (version) {
                                              return {
                                                      path: path$1,
                                                      args: args,
                                                      version: version
                                                    };
                                            })), (function (e) {
                                          return {
                                                  TAG: 1,
                                                  _0: e,
                                                  [Symbol.for("name")]: "Validation"
                                                };
                                        }));
                          })), setPath), (function (metadata) {
                    return {
                            metadata: metadata,
                            process: Process$AgdaModeVscode.make(metadata.path, metadata.args),
                            chan: Chan$AgdaModeVscode.make(undefined),
                            encountedFirstPrompt: false
                          };
                  })), wire);
}

function sendRequest(connection, $$document, request) {
  var filepath = Parser$AgdaModeVscode.filepath($$document.fileName);
  var libraryPath = Config$AgdaModeVscode.getLibraryPath(undefined);
  var highlightingMethod = Config$AgdaModeVscode.getHighlightingMethod(undefined);
  var backend = Config$AgdaModeVscode.getBackend(undefined);
  var encoded = Request$AgdaModeVscode.encode($$document, connection.metadata.version, filepath, backend, libraryPath, highlightingMethod, request);
  Process$AgdaModeVscode.send(connection.process, encoded);
  
}

function onResponse(connection, callback) {
  var deferredLastResponses = [];
  var match = $$Promise.pending(undefined);
  var stopListener = match[1];
  var listener = function (x) {
    if (x.TAG === /* Ok */0) {
      var match = x._0;
      if (match) {
        var error = match._0;
        if (error.TAG === /* Ok */0) {
          var response = error._0;
          if (response.TAG === /* NonLast */0) {
            var promise = Curry._1(callback, {
                  TAG: 0,
                  _0: response._0,
                  [Symbol.for("name")]: "Ok"
                });
            tally.contents = tally.contents + 1 | 0;
            return $$Promise.get(promise, (function (param) {
                          tally.contents = tally.contents - 1 | 0;
                          if (tally.contents === 0) {
                            return Chan$AgdaModeVscode.emit(allDone, undefined);
                          }
                          
                        }));
          }
          deferredLastResponses.push([
                response._0,
                response._1
              ]);
          return ;
        }
        Curry._1(callback, {
              TAG: 1,
              _0: {
                TAG: 8,
                _0: error._0,
                [Symbol.for("name")]: "ResponseParseError"
              },
              [Symbol.for("name")]: "Error"
            });
        return ;
      }
      var deferredLastResponses$1 = Belt_Array.map(deferredLastResponses.sort(function (x, y) {
                return Caml_primitive.caml_int_compare(x[0], y[0]);
              }), (function (prim) {
              return prim[1];
            }));
      deferredLastResponses$1.unshift(/* CompleteHighlightingAndMakePromptReappear */4);
      $$Promise.flatMap($$Promise.map($$Promise.tap(onceDone(undefined), stopListener), (function (param) {
                  return Belt_Array.map(deferredLastResponses$1, (function (res) {
                                return Curry._1(callback, {
                                            TAG: 0,
                                            _0: res,
                                            [Symbol.for("name")]: "Ok"
                                          });
                              }));
                })), Util$AgdaModeVscode.oneByOne);
      return ;
    }
    Curry._1(callback, {
          TAG: 1,
          _0: x._0,
          [Symbol.for("name")]: "Error"
        });
    
  };
  var listenerHandle = {
    contents: undefined
  };
  listenerHandle.contents = Chan$AgdaModeVscode.on(connection.chan, listener);
  return $$Promise.tap(match[0], (function (param) {
                return Belt_Option.forEach(listenerHandle.contents, (function (destroyListener) {
                              return Curry._1(destroyListener, undefined);
                            }));
              }));
}

var Emacs = {
  make: make,
  destroy: destroy,
  onResponse: onResponse,
  sendRequest: sendRequest
};

function encode(x) {
  if (x) {
    return Json_encode.object_({
                hd: [
                  "tag",
                  "ReqCommand"
                ],
                tl: {
                  hd: [
                    "contents",
                    x._0
                  ],
                  tl: /* [] */0
                }
              });
  } else {
    return Json_encode.object_({
                hd: [
                  "tag",
                  "ReqInitialize"
                ],
                tl: /* [] */0
              });
  }
}

var LSPReq = {
  encode: encode
};

function fromJsError(error) {
  return (function (e) {return e.toString()})(error);
}

var decode = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "ResCannotDecodeRequest" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (version) {
                                      return {
                                              TAG: 1,
                                              _0: version,
                                              [Symbol.for("name")]: "ServerCannotDecodeRequest"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        case "ResCommandDone" :
            return {
                    TAG: 1,
                    _0: /* CommandDone */0,
                    [Symbol.for("name")]: "TagOnly"
                  };
        case "ResInitialize" :
            return {
                    TAG: 0,
                    _0: (function (param) {
                        return Json_decode.map((function (version) {
                                      return {
                                              TAG: 0,
                                              _0: version,
                                              [Symbol.for("name")]: "Initialize"
                                            };
                                    }), Json_decode.string, param);
                      }),
                    [Symbol.for("name")]: "Contents"
                  };
        default:
          throw {
                RE_EXN_ID: Json_decode.DecodeError,
                _1: "[LSP.Response] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var LSPRes = {
  fromJsError: fromJsError,
  decode: decode
};

var decode$1 = Util$AgdaModeVscode.Decode.sum(function (x) {
      if (x === "LSPNtf") {
        return {
                TAG: 0,
                _0: (function (param) {
                    return Json_decode.map((function (version) {
                                  return {
                                          _0: version,
                                          [Symbol.for("name")]: "Response"
                                        };
                                }), Json_decode.string, param);
                  }),
                [Symbol.for("name")]: "Contents"
              };
      }
      throw {
            RE_EXN_ID: Json_decode.DecodeError,
            _1: "[LSP.Notification] Unknown constructor: " + x,
            Error: new Error()
          };
    });

var LSPNtf = {
  decode: decode$1
};

function toString$1(x) {
  if (x.TAG === /* StdIO */0) {
    return "\"" + x._0 + "\" on path \"" + x._1 + "\"";
  } else {
    return "on port \"" + String(x._0) + "\"";
  }
}

var Handle = {
  toString: toString$1
};

var singleton = {
  state: /* Disconnected */0,
  handle: undefined
};

function find(devMode) {
  if (devMode) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var socket = Net.connect(4000, (function (param) {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      });
          }));
    socket.on("error", (function (_exn) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: /* LSPCannotConnectDevServer */0,
                        [Symbol.for("name")]: "Error"
                      });
          }));
    return $$Promise.mapOk(match[0], (function (param) {
                  socket.destroy();
                  return {
                          TAG: 1,
                          _0: 4000,
                          [Symbol.for("name")]: "TCP"
                        };
                }));
  }
  var name = "als";
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run(name), (function (path) {
                    return {
                            TAG: 0,
                            _0: name,
                            _1: path.trim(),
                            [Symbol.for("name")]: "StdIO"
                          };
                  })), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "PathSearch"
                      };
              }));
}

function stop(param) {
  var match = singleton.state;
  if (match) {
    singleton.state = /* Disconnected */0;
    return LSP$AgdaModeVscode.Client.destroy(match._0);
  } else {
    return $$Promise.resolved(undefined);
  }
}

function sendRequestPrim(client, request) {
  return $$Promise.map(LSP$AgdaModeVscode.Client.sendRequest(client, encode(request)), (function (x) {
                if (x.TAG !== /* Ok */0) {
                  return {
                          TAG: 1,
                          _0: {
                            TAG: 5,
                            _0: x._0,
                            [Symbol.for("name")]: "LSPSendRequest"
                          },
                          [Symbol.for("name")]: "Error"
                        };
                }
                var json = x._0;
                var response;
                try {
                  response = Curry._1(decode, json);
                }
                catch (raw_msg){
                  var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                  if (msg.RE_EXN_ID === Json_decode.DecodeError) {
                    return {
                            TAG: 1,
                            _0: {
                              TAG: 6,
                              _0: msg._1,
                              _1: json,
                              [Symbol.for("name")]: "LSPClientCannotDecodeResponse"
                            },
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  throw msg;
                }
                return {
                        TAG: 0,
                        _0: response,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function startWithHandle(handle) {
  var match = singleton.state;
  if (match) {
    return $$Promise.resolved({
                TAG: 0,
                _0: match._1,
                [Symbol.for("name")]: "Ok"
              });
  }
  var match$1;
  match$1 = handle.TAG === /* StdIO */0 ? [
      true,
      /* ViaStdIO */0
    ] : [
      true,
      /* ViaTCP */1
    ];
  var method = match$1[1];
  return $$Promise.flatMap(LSP$AgdaModeVscode.Client.make(match$1[0], method), (function (result) {
                if (result.TAG === /* Ok */0) {
                  var client = result._0;
                  return $$Promise.flatMapOk(sendRequestPrim(client, /* Initialize */0), (function (response) {
                                if (typeof response === "number") {
                                  return $$Promise.resolved({
                                              TAG: 1,
                                              _0: {
                                                TAG: 4,
                                                _0: Js_exn.raiseError("Got `CommandDone` instead"),
                                                [Symbol.for("name")]: "LSPConnection"
                                              },
                                              [Symbol.for("name")]: "Error"
                                            });
                                }
                                if (response.TAG !== /* Initialize */0) {
                                  return $$Promise.resolved({
                                              TAG: 1,
                                              _0: {
                                                TAG: 7,
                                                _0: response._0,
                                                [Symbol.for("name")]: "LSPServerCannotDecodeRequest"
                                              },
                                              [Symbol.for("name")]: "Error"
                                            });
                                }
                                var version = response._0;
                                singleton.state = {
                                  _0: client,
                                  _1: version,
                                  [Symbol.for("name")]: "Connected"
                                };
                                return $$Promise.resolved({
                                            TAG: 0,
                                            _0: version,
                                            [Symbol.for("name")]: "Ok"
                                          });
                              }));
                }
                var exn = result._0;
                var isECONNREFUSED = Belt_Option.mapWithDefault(exn.message, false, (function (param) {
                        return param.startsWith("connect ECONNREFUSED");
                      }));
                var shouldSwitchToStdIO = isECONNREFUSED && method === /* ViaTCP */1;
                singleton.state = /* Disconnected */0;
                singleton.handle = undefined;
                if (shouldSwitchToStdIO) {
                  console.log("Connecting via TCP failed, trying to switch to StdIO");
                  return $$Promise.flatMapOk(find(false), (function (handle) {
                                singleton.handle = handle;
                                return startWithHandle(handle);
                              }));
                } else {
                  return $$Promise.resolved({
                              TAG: 1,
                              _0: {
                                TAG: 4,
                                _0: exn,
                                [Symbol.for("name")]: "LSPConnection"
                              },
                              [Symbol.for("name")]: "Error"
                            });
                }
              }));
}

function start(handle) {
  singleton.handle = handle;
  return startWithHandle(handle);
}

function getVersion(param) {
  var match = singleton.state;
  if (match) {
    return match._1;
  }
  
}

function isConnected(param) {
  var match = singleton.state;
  if (match) {
    return true;
  } else {
    return false;
  }
}

var onError = LSP$AgdaModeVscode.Client.onError;

function sendRequest$1(request, responseHandler) {
  var match = singleton.state;
  if (!match) {
    return $$Promise.resolved({
                TAG: 1,
                _0: /* NotConnectedYet */1,
                [Symbol.for("name")]: "Error"
              });
  }
  var subscription = LSP$AgdaModeVscode.Client.onData(function (json) {
        console.log("json: " + JSON.stringify(json));
        var raw;
        try {
          raw = Curry._1(decode$1, json);
        }
        catch (raw__msg){
          var _msg = Caml_js_exceptions.internalToOCamlException(raw__msg);
          if (_msg.RE_EXN_ID === Json_decode.DecodeError) {
            return ;
          }
          throw _msg;
        }
        console.log("!!!!!");
        return Curry._1(responseHandler, raw._0);
      });
  return $$Promise.flatMapOk(sendRequestPrim(match._0, {
                  _0: request,
                  [Symbol.for("name")]: "Command"
                }), (function (result) {
                if (typeof result !== "number") {
                  if (result.TAG === /* Initialize */0) {
                    return $$Promise.resolved({
                                TAG: 1,
                                _0: {
                                  TAG: 3,
                                  _0: "Got `Initialize` when expecting `CommandDone`",
                                  [Symbol.for("name")]: "LSPInternalError"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                  } else {
                    return $$Promise.resolved({
                                TAG: 1,
                                _0: {
                                  TAG: 7,
                                  _0: result._0,
                                  [Symbol.for("name")]: "LSPServerCannotDecodeRequest"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                  }
                }
                subscription.dispose();
                return $$Promise.resolved({
                            TAG: 0,
                            _0: undefined,
                            [Symbol.for("name")]: "Ok"
                          });
              }));
}

var Module = {
  Handle: Handle,
  find: find,
  start: start,
  stop: stop,
  sendRequest: sendRequest$1,
  getVersion: getVersion,
  isConnected: isConnected,
  onError: onError
};

var LSP = {
  LSPReq: LSPReq,
  LSPRes: LSPRes,
  LSPNtf: LSPNtf,
  Module: Module,
  Handle: Handle,
  find: find,
  start: start,
  stop: stop,
  sendRequest: sendRequest$1,
  getVersion: getVersion,
  isConnected: isConnected,
  onError: onError
};

exports.$$Error = $$Error;
exports.Emacs = Emacs;
exports.LSP = LSP;
/* allDone Not a pure module */
