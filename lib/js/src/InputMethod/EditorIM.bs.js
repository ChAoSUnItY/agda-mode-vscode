// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");

function Impl(Editor) {
  var log = function (param) {
    
  };
  var make = function (editor, range) {
    var $$document = Curry._1(Editor.getDocument, editor);
    var start = Curry._2(Editor.pointAtOffset, $$document, range[0]);
    var end_ = Curry._2(Editor.pointAtOffset, $$document, range[1]);
    return {
            range: range,
            decoration: [Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, start, end_))],
            buffer: Buffer$AgdaModeVscode.make(undefined)
          };
  };
  var withIn = function (instance, offset) {
    var match = instance.range;
    if (match[0] <= offset) {
      return offset <= match[1];
    } else {
      return false;
    }
  };
  var redocorate = function (instance, editor) {
    var $$document = Curry._1(Editor.getDocument, editor);
    Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
    instance.decoration = [];
    var match = instance.range;
    var start = Curry._2(Editor.pointAtOffset, $$document, match[0]);
    var end_ = Curry._2(Editor.pointAtOffset, $$document, match[1]);
    instance.decoration = [Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, start, end_))];
    
  };
  var destroy = function (instance) {
    Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
    instance.decoration = [];
    
  };
  var Instance = {
    make: make,
    withIn: withIn,
    redocorate: redocorate,
    destroy: destroy
  };
  var fromEditorChangeEvent = function (change) {
    return {
            offset: change.offset,
            insertedText: change.insertedText,
            replacedTextLength: change.replacedTextLength
          };
  };
  var checkCursorPositions = function (self, $$document, points) {
    var offsets = Belt_Array.map(points, Curry._1(Editor.offsetAtPoint, $$document));
    Curry._1(log, "\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                      return String(prim);
                    }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, (function (i) {
                        return "(" + (String(i.range[0]) + (", " + (String(i.range[1]) + ")")));
                      }))))));
    self.instances = Belt_Array.keep(self.instances, (function (instance) {
            var survived = Belt_Array.some(offsets, (function (param) {
                    return withIn(instance, param);
                  }));
            if (!survived) {
              destroy(instance);
            }
            return survived;
          }));
    self.cursorsToBeChecked = undefined;
    if (self.instances.length === 0) {
      Curry._1(self.eventEmitter.emit, /* Deactivate */1);
      return Curry._1(self.eventEmitterTest.emit, /* Deactivate */2);
    }
    
  };
  var updateView = function (self) {
    return Belt_Option.forEach(Belt_Array.get(self.instances, 0), (function (instance) {
                  return Curry._1(self.eventEmitter.emit, /* Update */Caml_chrome_debugger.variant("Update", 1, [
                                Buffer$AgdaModeVscode.toSequence(instance.buffer),
                                instance.buffer.translation,
                                instance.buffer.candidateIndex
                              ]));
                }));
  };
  var toRewrites = function (instances, f) {
    var accum = {
      contents: 0
    };
    return Belt_Array.keepMap(instances, (function (instance) {
                  var match = instance.range;
                  var end_ = match[1];
                  var start = match[0];
                  instance.range = /* tuple */[
                    start + accum.contents | 0,
                    end_ + accum.contents | 0
                  ];
                  return Belt_Option.map(Curry._1(f, instance), (function (replacement) {
                                var delta = replacement.length - (end_ - start | 0) | 0;
                                accum.contents = accum.contents + delta | 0;
                                return {
                                        rangeBefore: instance.range,
                                        rangeAfter: /* tuple */[
                                          instance.range[0],
                                          instance.range[1] + delta | 0
                                        ],
                                        text: replacement,
                                        instance: instance
                                      };
                              }));
                }));
  };
  var applyRewrites = function (self, editor, rewrites) {
    var $$document = Curry._1(Editor.getDocument, editor);
    self.busy = true;
    return $$Promise.get(Util$AgdaModeVscode.oneByOne(Belt_Array.map(rewrites, (function (param, param$1) {
                          var instance = param.instance;
                          var text = param.text;
                          var rangeAfter = param.rangeAfter;
                          var rangeBefore = param.rangeBefore;
                          var editorRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, $$document, rangeBefore[0]), Curry._2(Editor.pointAtOffset, $$document, rangeBefore[1]));
                          return $$Promise.map($$Promise.flatMap(Curry._2(Editor.deleteText, $$document, editorRange), (function (param) {
                                            return Curry._3(Editor.insertText, $$document, Curry._1(Editor.$$Range.start, editorRange), text);
                                          })), (function (param) {
                                        if (instance !== undefined) {
                                          instance.range = rangeAfter;
                                          return redocorate(instance, editor);
                                        }
                                        
                                      }));
                        }))), (function (param) {
                  Curry._1(self.eventEmitterTest.emit, /* Change */0);
                  self.busy = false;
                  var points = self.cursorsToBeChecked;
                  if (points !== undefined) {
                    return checkCursorPositions(self, $$document, points);
                  }
                  
                }));
  };
  var updateInstanceOffsets = function (instances, changes) {
    var changes$1 = changes.sort((function (x, y) {
            return Caml_primitive.caml_int_compare(x.offset, y.offset);
          }));
    var go = function (_accum, _param) {
      while(true) {
        var param = _param;
        var accum = _accum;
        var match = param[0];
        if (match) {
          var match$1 = param[1];
          if (!match$1) {
            return /* [] */0;
          }
          var is = match$1[1];
          var instance = match$1[0];
          var cs = match[1];
          var change = match[0];
          var match$2 = instance.range;
          var end_ = match$2[1];
          var start = match$2[0];
          var delta = change.insertedText.length - change.replacedTextLength | 0;
          if (withIn(instance, change.offset)) {
            instance.range = /* tuple */[
              accum + start | 0,
              (accum + end_ | 0) + delta | 0
            ];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* tuple */[
                        instance,
                        {
                          offset: change.offset + accum | 0,
                          insertedText: change.insertedText,
                          replacedTextLength: change.replacedTextLength
                        }
                      ],
                      go(accum + delta | 0, /* tuple */[
                            cs,
                            is
                          ])
                    ]);
          }
          if (change.offset < instance.range[0]) {
            _param = /* tuple */[
              cs,
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  instance,
                  is
                ])
            ];
            _accum = accum + delta | 0;
            continue ;
          }
          instance.range = /* tuple */[
            accum + start | 0,
            accum + end_ | 0
          ];
          return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* tuple */[
                      instance,
                      undefined
                    ],
                    go(accum, /* tuple */[
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              change,
                              cs
                            ]),
                          is
                        ])
                  ]);
        }
        var match$3 = param[1];
        if (match$3) {
          return Belt_List.map(/* :: */Caml_chrome_debugger.simpleVariant("::", [
                        match$3[0],
                        match$3[1]
                      ]), (function (i) {
                        return /* tuple */[
                                i,
                                undefined
                              ];
                      }));
        } else {
          return /* [] */0;
        }
      };
    };
    var instancesWithChanges = Belt_List.toArray(go(0, /* tuple */[
              Belt_List.fromArray(changes$1),
              Belt_List.fromArray(instances)
            ]));
    var rewrites = [];
    var accum = {
      contents: 0
    };
    var instances$1 = Belt_Array.keepMap(instancesWithChanges, (function (param) {
            var change = param[1];
            var instance = param[0];
            if (change === undefined) {
              return instance;
            }
            var match = Buffer$AgdaModeVscode.update(instance.buffer, instance.range[0], change);
            var buffer = match[0];
            Belt_Option.forEach(match[1], (function (text) {
                    var match = instance.range;
                    var end_ = match[1];
                    var start = match[0];
                    var delta = text.length - (end_ - start | 0) | 0;
                    rewrites.push({
                          rangeBefore: /* tuple */[
                            start + accum.contents | 0,
                            end_ + accum.contents | 0
                          ],
                          rangeAfter: /* tuple */[
                            start + accum.contents | 0,
                            (end_ + accum.contents | 0) + delta | 0
                          ],
                          text: text,
                          instance: buffer.translation.further ? instance : undefined
                        });
                    accum.contents = accum.contents + delta | 0;
                    
                  }));
            if (buffer.translation.further) {
              instance.buffer = buffer;
              return instance;
            } else {
              destroy(instance);
              return ;
            }
          }));
    return /* tuple */[
            instances$1,
            rewrites
          ];
  };
  var activate = function (self, editor, ranges) {
    self.activated = true;
    Curry._1(self.eventEmitterTest.emit, /* Activate */1);
    Curry._2(Editor.setContext, "agdaModeTyping", true);
    self.instances = Belt_Array.map(ranges.sort((function (x, y) {
                return Caml_primitive.caml_int_compare(x[0], y[0]);
              })), (function (param) {
            return make(editor, param);
          }));
    self.handles.push(Curry._1(Editor.onChangeCursorPosition, (function (points) {
                if (self.busy) {
                  self.cursorsToBeChecked = points;
                  return ;
                } else {
                  return checkCursorPositions(self, Curry._1(Editor.getDocument, editor), points);
                }
              })));
    self.handles.push(Curry._1(Editor.onChange, (function (changes) {
                if (!(!self.busy && changes.length !== 0)) {
                  return ;
                }
                var changes$1 = Belt_Array.map(changes, fromEditorChangeEvent);
                var match = updateInstanceOffsets(self.instances, changes$1);
                self.instances = match[0];
                applyRewrites(self, editor, match[1]);
                return updateView(self);
              })));
    
  };
  var deactivate = function (self) {
    Curry._2(Editor.setContext, "agdaModeTyping", false);
    Curry._1(self.eventEmitterTest.emit, /* Deactivate */2);
    Belt_Array.forEach(self.instances, destroy);
    self.instances = [];
    self.activated = false;
    self.cursorsToBeChecked = undefined;
    self.busy = false;
    Belt_Array.forEach(self.handles, Editor.Disposable.dispose);
    self.handles = [];
    
  };
  var make$1 = function (eventEmitterTest) {
    return {
            instances: [],
            activated: false,
            cursorsToBeChecked: undefined,
            busy: false,
            handles: [],
            eventEmitter: Event$AgdaModeVscode.make(undefined),
            eventEmitterTest: eventEmitterTest
          };
  };
  var moveUp = function (self, editor) {
    var rewrites = toRewrites(self.instances, (function (instance) {
            instance.buffer = Buffer$AgdaModeVscode.moveUp(instance.buffer);
            return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveRight = function (self, editor) {
    var rewrites = toRewrites(self.instances, (function (instance) {
            instance.buffer = Buffer$AgdaModeVscode.moveRight(instance.buffer);
            return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveDown = function (self, editor) {
    var rewrites = toRewrites(self.instances, (function (instance) {
            instance.buffer = Buffer$AgdaModeVscode.moveDown(instance.buffer);
            return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var moveLeft = function (self, editor) {
    var rewrites = toRewrites(self.instances, (function (instance) {
            instance.buffer = Buffer$AgdaModeVscode.moveLeft(instance.buffer);
            return Belt_Array.get(instance.buffer.translation.candidateSymbols, instance.buffer.candidateIndex);
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var chooseSymbol = function (self, editor, symbol) {
    var rewrites = toRewrites(self.instances, (function (param) {
            return symbol;
          }));
    applyRewrites(self, editor, rewrites);
    return updateView(self);
  };
  var insertBackslash = function (editor) {
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, Curry._1(Editor.getDocument, editor), point, "\\");
                  
                }));
  };
  var insertChar = function (editor, $$char) {
    var $$char$1 = $$char.charAt(0);
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, Curry._1(Editor.getDocument, editor), point, $$char$1);
                  
                }));
  };
  return {
          printLog: false,
          log: log,
          Instance: Instance,
          fromEditorChangeEvent: fromEditorChangeEvent,
          checkCursorPositions: checkCursorPositions,
          updateView: updateView,
          toRewrites: toRewrites,
          applyRewrites: applyRewrites,
          updateInstanceOffsets: updateInstanceOffsets,
          activate: activate,
          deactivate: deactivate,
          make: make$1,
          moveUp: moveUp,
          moveRight: moveRight,
          moveDown: moveDown,
          moveLeft: moveLeft,
          chooseSymbol: chooseSymbol,
          insertBackslash: insertBackslash,
          insertChar: insertChar
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
