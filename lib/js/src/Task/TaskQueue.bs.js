// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function getNextTask(self) {
  var match = self.view;
  var match$1 = self.agda;
  var match$2 = self.main;
  if (match !== undefined) {
    if (match) {
      self.view = match[1];
      return Caml_option.some(match[0]);
    } else {
      return ;
    }
  }
  if (typeof match$1 === "number") {
    if (match$2) {
      self.main = match$2[1];
      return Caml_option.some(match$2[0]);
    } else {
      return ;
    }
  }
  if (match$1.tag) {
    var match$3 = match$1[1];
    var resolve = match$1[0];
    if (match$3) {
      self.agda = /* Ending */Caml_chrome_debugger.variant("Ending", 1, [
          resolve,
          match$3[1]
        ]);
      return Caml_option.some(match$3[0]);
    } else {
      self.agda = /* Free */0;
      Curry._1(resolve, undefined);
      return ;
    }
  }
  var match$4 = match$1[0];
  if (match$4) {
    self.agda = /* Pending */Caml_chrome_debugger.variant("Pending", 0, [match$4[1]]);
    return Caml_option.some(match$4[0]);
  }
  
}

function make(execute) {
  return {
          main: /* [] */0,
          agda: /* Free */0,
          view: undefined,
          execute: execute,
          busy: false,
          shouldDestroy: undefined
        };
}

function kickStart(self) {
  if (self.busy) {
    return ;
  }
  var task = getNextTask(self);
  if (task !== undefined) {
    self.busy = true;
    return $$Promise.get(Curry._3(self.execute, self, kickStart, Caml_option.valFromOption(task)), (function (keepRunning) {
                  self.busy = false;
                  if (keepRunning) {
                    return kickStart(self);
                  }
                  
                }));
  }
  var resolve = self.shouldDestroy;
  if (resolve !== undefined) {
    return Curry._1(resolve, undefined);
  }
  
}

function destroy(self) {
  if (!self.busy) {
    return $$Promise.resolved(undefined);
  }
  var match = $$Promise.pending(undefined);
  self.shouldDestroy = match[1];
  return match[0];
}

function forceDestroy(self) {
  self.main = /* [] */0;
  self.agda = /* Free */0;
  self.view = undefined;
  return $$Promise.resolved(undefined);
}

function addTasksToBack(self, tasks) {
  self.main = Belt_List.concat(self.main, tasks);
  
}

function addTasksToFront(self, tasks) {
  self.main = Belt_List.concat(tasks, self.main);
  
}

function toString(taskToString, param) {
  var main = param.main;
  var agda = param.agda;
  var view = param.view;
  var main$1 = "Main " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(main, taskToString));
  var agda$1;
  agda$1 = typeof agda === "number" ? "" : (
      agda.tag ? "Agda# " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(agda[1], taskToString)) : "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(agda[0], taskToString))
    );
  var view$1 = view !== undefined ? "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(view, taskToString)) : "";
  return main$1 + ("\n" + (agda$1 + ("\n" + view$1)));
}

function agdaIsOccupied(self) {
  var match = self.agda;
  if (typeof match === "number") {
    return false;
  } else {
    return true;
  }
}

function acquireAgda(self) {
  var match = self.agda;
  if (typeof match === "number") {
    self.agda = /* Pending */Caml_chrome_debugger.variant("Pending", 0, [/* [] */0]);
    return ;
  } else {
    console.log("[ panic ] The Agda task queue has already been acquired");
    return ;
  }
}

function releaseAgda(self) {
  var remainingTasks = self.agda;
  if (typeof remainingTasks === "number") {
    return $$Promise.resolved(undefined);
  }
  if (remainingTasks.tag) {
    console.log("[ panic ] The Agda task queue has been released by someone else");
    return $$Promise.resolved(undefined);
  }
  var match = $$Promise.pending(undefined);
  self.agda = /* Ending */Caml_chrome_debugger.variant("Ending", 1, [
      match[1],
      remainingTasks[0]
    ]);
  kickStart(self);
  return match[0];
}

function addTasksToAgda(self, tasks) {
  var agda = self.agda;
  if (typeof agda === "number") {
    console.log("[ panic ] Cannot add task to the Agda task queue before acquiring it");
    return ;
  }
  if (!agda.tag) {
    self.agda = /* Pending */Caml_chrome_debugger.variant("Pending", 0, [Belt_List.concat(agda[0], tasks)]);
    return ;
  }
  console.log("[ panic ] Cannot add task to the Agda task queue when it's ending");
  
}

function viewIsOccupied(self) {
  return Belt_Option.isSome(self.view);
}

function acquireView(self) {
  var match = self.view;
  if (match !== undefined) {
    console.log("[ panic ] The View task queue has already been acquired");
    return ;
  } else {
    self.view = /* [] */0;
    return ;
  }
}

function releaseView(self) {
  var remainingTasks = self.view;
  if (remainingTasks !== undefined) {
    self.main = Belt_List.concat(remainingTasks, self.main);
    self.view = undefined;
    return ;
  }
  
}

function addTasksToView(self, tasks) {
  var view = self.view;
  if (view !== undefined) {
    self.view = Belt_List.concat(view, tasks);
    return ;
  } else {
    console.log("[ panic ] Cannot add task to the View task queue before acquiring it");
    return ;
  }
}

exports.getNextTask = getNextTask;
exports.make = make;
exports.kickStart = kickStart;
exports.destroy = destroy;
exports.forceDestroy = forceDestroy;
exports.addTasksToBack = addTasksToBack;
exports.addTasksToFront = addTasksToFront;
exports.toString = toString;
exports.agdaIsOccupied = agdaIsOccupied;
exports.acquireAgda = acquireAgda;
exports.releaseAgda = releaseAgda;
exports.addTasksToAgda = addTasksToAgda;
exports.viewIsOccupied = viewIsOccupied;
exports.acquireView = acquireView;
exports.releaseView = releaseView;
exports.addTasksToView = addTasksToView;
/* Promise Not a pure module */
