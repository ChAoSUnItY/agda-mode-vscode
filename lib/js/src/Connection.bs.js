// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Request$AgdaModeVscode = require("./Request.bs.js");
var Connection__LSP$AgdaModeVscode = require("./Connection/Connection__LSP.bs.js");
var Connection__Emacs$AgdaModeVscode = require("./Connection/Connection__Emacs.bs.js");

var singleton = {
  contents: undefined
};

function toStatus(conn) {
  if (conn.TAG === /* Emacs */0) {
    var version = Connection__Emacs$AgdaModeVscode.getVersion(conn._0);
    return {
            TAG: 0,
            _0: version,
            [Symbol.for("name")]: "Emacs"
          };
  }
  var match = Connection__LSP$AgdaModeVscode.getStatus(conn._0);
  return {
          TAG: 1,
          _0: match[0],
          _1: match[1],
          [Symbol.for("name")]: "LSP"
        };
}

function start(useLSP, viaTCP) {
  var conn = singleton.contents;
  if (conn !== undefined) {
    return $$Promise.resolved({
                TAG: 0,
                _0: toStatus(conn),
                [Symbol.for("name")]: "Ok"
              });
  } else if (useLSP) {
    return $$Promise.map(Connection__LSP$AgdaModeVscode.make(viaTCP), (function (result) {
                  if (result.TAG !== /* Ok */0) {
                    return {
                            TAG: 1,
                            _0: {
                              TAG: 3,
                              _0: result._0,
                              [Symbol.for("name")]: "LSP"
                            },
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  var conn = result._0;
                  var match = Connection__LSP$AgdaModeVscode.getStatus(conn);
                  singleton.contents = {
                    TAG: 1,
                    _0: conn,
                    [Symbol.for("name")]: "LSP"
                  };
                  return {
                          TAG: 0,
                          _0: {
                            TAG: 1,
                            _0: match[0],
                            _1: match[1],
                            [Symbol.for("name")]: "LSP"
                          },
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  } else {
    return $$Promise.map(Connection__Emacs$AgdaModeVscode.make(undefined), (function (result) {
                  if (result.TAG !== /* Ok */0) {
                    return {
                            TAG: 1,
                            _0: result._0,
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  var conn = result._0;
                  singleton.contents = {
                    TAG: 0,
                    _0: conn,
                    [Symbol.for("name")]: "Emacs"
                  };
                  var version = Connection__Emacs$AgdaModeVscode.getVersion(conn);
                  return {
                          TAG: 0,
                          _0: {
                            TAG: 0,
                            _0: version,
                            [Symbol.for("name")]: "Emacs"
                          },
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  }
}

function stop(param) {
  var match = singleton.contents;
  if (match === undefined) {
    return $$Promise.resolved(undefined);
  }
  if (match.TAG === /* Emacs */0) {
    singleton.contents = undefined;
    return Connection__Emacs$AgdaModeVscode.destroy(match._0);
  }
  singleton.contents = undefined;
  return Connection__LSP$AgdaModeVscode.destroy(match._0);
}

function sendRequest(useLSP, viaTCP, $$document, request, handler) {
  var encodeRequest = function ($$document, version) {
    var filepath = Parser$AgdaModeVscode.filepath($$document.fileName);
    var libraryPath = Config$AgdaModeVscode.getLibraryPath(undefined);
    var highlightingMethod = Config$AgdaModeVscode.getHighlightingMethod(undefined);
    var backend = Config$AgdaModeVscode.getBackend(undefined);
    return Request$AgdaModeVscode.encode($$document, version, filepath, backend, libraryPath, highlightingMethod, request);
  };
  var match = singleton.contents;
  if (match === undefined) {
    return $$Promise.flatMapOk(start(useLSP, viaTCP), (function (param) {
                  return sendRequest(useLSP, viaTCP, $$document, request, handler);
                }));
  }
  if (match.TAG === /* Emacs */0) {
    var conn = match._0;
    var version = Connection__Emacs$AgdaModeVscode.getVersion(conn);
    return $$Promise.mapOk(Connection__Emacs$AgdaModeVscode.sendRequest(conn, encodeRequest($$document, version), handler), (function (param) {
                  return toStatus({
                              TAG: 0,
                              _0: conn,
                              [Symbol.for("name")]: "Emacs"
                            });
                }));
  }
  var conn$1 = match._0;
  var handlerLSP = function (result) {
    if (result.TAG === /* Ok */0) {
      return Curry._1(handler, {
                  TAG: 0,
                  _0: result._0,
                  [Symbol.for("name")]: "Ok"
                });
    } else {
      return Curry._1(handler, {
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: result._0,
                    [Symbol.for("name")]: "LSP"
                  },
                  [Symbol.for("name")]: "Error"
                });
    }
  };
  var match$1 = Connection__LSP$AgdaModeVscode.getStatus(conn$1);
  return $$Promise.map(Connection__LSP$AgdaModeVscode.sendRequest(conn$1, encodeRequest($$document, match$1[1]), handlerLSP), (function (result) {
                if (result.TAG === /* Ok */0) {
                  return {
                          TAG: 0,
                          _0: toStatus({
                                TAG: 1,
                                _0: conn$1,
                                [Symbol.for("name")]: "LSP"
                              }),
                          [Symbol.for("name")]: "Ok"
                        };
                } else {
                  return {
                          TAG: 1,
                          _0: {
                            TAG: 3,
                            _0: result._0,
                            [Symbol.for("name")]: "LSP"
                          },
                          [Symbol.for("name")]: "Error"
                        };
                }
              }));
}

function reconnect(param) {
  return $$Promise.resolved(undefined);
}

var Module = {
  start: start,
  reconnect: reconnect,
  stop: stop,
  sendRequest: sendRequest
};

var $$Error;

var Scheduler;

var Emacs;

var LSP;

exports.$$Error = $$Error;
exports.Scheduler = Scheduler;
exports.Emacs = Emacs;
exports.LSP = LSP;
exports.Module = Module;
exports.start = start;
exports.reconnect = reconnect;
exports.stop = stop;
exports.sendRequest = sendRequest;
/* Promise Not a pure module */
