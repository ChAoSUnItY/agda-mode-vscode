// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");

function getNextTask(self) {
  var match = self.view;
  var match$1 = self.agda;
  var match$2 = self.main;
  if (typeof match === "number") {
    if (typeof match$1 === "number") {
      if (match$2) {
        self.main = match$2.tl;
        return match$2.hd;
      } else {
        return ;
      }
    }
    if (match$1.TAG) {
      var match$3 = match$1._1;
      var resolve = match$1._0;
      if (match$3) {
        self.agda = {
          TAG: 1,
          _0: resolve,
          _1: match$3.tl,
          [Symbol.for("name")]: "Closing"
        };
        return match$3.hd;
      } else {
        self.agda = /* Free */0;
        Curry._1(resolve, undefined);
        return ;
      }
    }
    var match$4 = match$1._0;
    if (match$4) {
      self.agda = {
        TAG: 0,
        _0: match$4.tl,
        [Symbol.for("name")]: "Pending"
      };
      return match$4.hd;
    } else {
      return ;
    }
  } else {
    if (match.TAG) {
      var match$5 = match._1;
      var resolve$1 = match._0;
      if (match$5) {
        self.view = {
          TAG: 1,
          _0: resolve$1,
          _1: match$5.tl,
          [Symbol.for("name")]: "Closing"
        };
        return match$5.hd;
      } else {
        self.view = /* Free */0;
        Curry._1(resolve$1, undefined);
        return ;
      }
    }
    var match$6 = match._0;
    if (match$6) {
      self.view = {
        TAG: 0,
        _0: match$6.tl,
        [Symbol.for("name")]: "Pending"
      };
      return match$6.hd;
    } else {
      return ;
    }
  }
}

function make(execute) {
  return {
          main: /* [] */0,
          agda: /* Free */0,
          view: /* Free */0,
          execute: execute,
          busy: undefined,
          shouldResolveWhenEmptied: undefined
        };
}

function kickStart(self) {
  if (!Belt_Option.isNone(self.busy)) {
    return ;
  }
  var task = getNextTask(self);
  if (task !== undefined) {
    if (typeof task !== "number" && task.TAG === /* AgdaRequest */1) {
      return $$Promise.get(Curry._2(self.execute, self, task), (function (keepRunning) {
                    if (keepRunning) {
                      return kickStart(self);
                    }
                    
                  }));
    }
    self.busy = task;
    return $$Promise.get(Curry._2(self.execute, self, task), (function (keepRunning) {
                  self.busy = undefined;
                  if (keepRunning) {
                    return kickStart(self);
                  }
                  
                }));
  }
  var resolve = self.shouldResolveWhenEmptied;
  if (resolve !== undefined) {
    return Curry._1(resolve, undefined);
  }
  
}

function onEmptied(self) {
  if (!Belt_Option.isSome(self.busy)) {
    return $$Promise.resolved(undefined);
  }
  var match = $$Promise.pending(undefined);
  self.shouldResolveWhenEmptied = match[1];
  return match[0];
}

function forceDestroy(self) {
  self.main = /* [] */0;
  self.agda = /* Free */0;
  self.view = /* Free */0;
  return $$Promise.resolved(undefined);
}

function addToTheBack(self, tasks) {
  self.main = Belt_List.concat(self.main, tasks);
  return kickStart(self);
}

function addToTheFront(self, tasks) {
  var match = self.view;
  var match$1 = self.agda;
  if (typeof match === "number") {
    if (typeof match$1 === "number") {
      self.main = Belt_List.concat(tasks, self.main);
    } else if (match$1.TAG) {
      self.agda = {
        TAG: 1,
        _0: match$1._0,
        _1: Belt_List.concat(tasks, match$1._1),
        [Symbol.for("name")]: "Closing"
      };
    } else {
      self.agda = {
        TAG: 0,
        _0: Belt_List.concat(tasks, match$1._0),
        [Symbol.for("name")]: "Pending"
      };
    }
  } else if (match.TAG) {
    self.view = {
      TAG: 1,
      _0: match._0,
      _1: Belt_List.concat(tasks, match._1),
      [Symbol.for("name")]: "Closing"
    };
  } else {
    self.view = {
      TAG: 0,
      _0: Belt_List.concat(tasks, match._0),
      [Symbol.for("name")]: "Pending"
    };
  }
  return kickStart(self);
}

function toString(taskToString, param) {
  var main = param.main;
  var agda = param.agda;
  var view = param.view;
  var main$1 = "Main " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(main, taskToString));
  var agda$1;
  agda$1 = typeof agda === "number" ? "" : (
      agda.TAG ? "Agda# " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(agda._1, taskToString)) : "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(agda._0, taskToString))
    );
  var view$1;
  view$1 = typeof view === "number" ? "" : (
      view.TAG ? "View# " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(view._1, taskToString)) : "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(view._0, taskToString))
    );
  return main$1 + ("\n" + (agda$1 + ("\n" + view$1)));
}

function isOccupied(self) {
  var match = self.agda;
  if (typeof match === "number") {
    return false;
  } else {
    return true;
  }
}

function close(self) {
  var remainingTasks = self.agda;
  if (typeof remainingTasks === "number") {
    return $$Promise.resolved(undefined);
  }
  if (remainingTasks.TAG) {
    console.log("[ panic ] The Agda task queue has been released by someone else");
    return $$Promise.resolved(undefined);
  }
  var match = $$Promise.pending(undefined);
  self.agda = {
    TAG: 1,
    _0: match[1],
    _1: remainingTasks._0,
    [Symbol.for("name")]: "Closing"
  };
  kickStart(self);
  return match[0];
}

function addToTheBack$1(self, tasks) {
  var agda = self.agda;
  if (typeof agda === "number") {
    self.agda = {
      TAG: 0,
      _0: tasks,
      [Symbol.for("name")]: "Pending"
    };
    return kickStart(self);
  }
  if (agda.TAG) {
    console.log("[ panic ] Cannot add task to the Agda task queue after it's been marked closed");
    return ;
  }
  self.agda = {
    TAG: 0,
    _0: Belt_List.concat(agda._0, tasks),
    [Symbol.for("name")]: "Pending"
  };
  return kickStart(self);
}

var Agda = {
  isOccupied: isOccupied,
  close: close,
  addToTheBack: addToTheBack$1
};

function isOccupied$1(self) {
  var match = self.view;
  if (typeof match === "number") {
    return false;
  } else {
    return true;
  }
}

function close$1(self) {
  var remainingTasks = self.view;
  if (typeof remainingTasks === "number") {
    return $$Promise.resolved(undefined);
  }
  if (remainingTasks.TAG) {
    console.log("[ panic ] The View task queue has been released by someone else");
    return $$Promise.resolved(undefined);
  }
  var match = $$Promise.pending(undefined);
  self.view = {
    TAG: 1,
    _0: match[1],
    _1: remainingTasks._0,
    [Symbol.for("name")]: "Closing"
  };
  kickStart(self);
  return match[0];
}

function addToTheBack$2(self, tasks) {
  var view = self.view;
  if (typeof view === "number") {
    self.view = {
      TAG: 0,
      _0: tasks,
      [Symbol.for("name")]: "Pending"
    };
    return kickStart(self);
  }
  if (view.TAG) {
    console.log("[ panic ] Cannot add task to the View task queue after it's been marked closed");
    return ;
  }
  self.view = {
    TAG: 0,
    _0: Belt_List.concat(view._0, tasks),
    [Symbol.for("name")]: "Pending"
  };
  return kickStart(self);
}

var View = {
  isOccupied: isOccupied$1,
  close: close$1,
  addToTheBack: addToTheBack$2
};

exports.getNextTask = getNextTask;
exports.make = make;
exports.kickStart = kickStart;
exports.onEmptied = onEmptied;
exports.forceDestroy = forceDestroy;
exports.addToTheBack = addToTheBack;
exports.addToTheFront = addToTheFront;
exports.toString = toString;
exports.Agda = Agda;
exports.View = View;
/* Promise Not a pure module */
