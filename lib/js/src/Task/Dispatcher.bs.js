// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var make = function (param) {
    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
              /* tuple */[
                /* Command */2,
                /* [] */0
              ],
              /* [] */0
            ]);
  };
  var spawn = function (queues, source) {
    return /* :: */Caml_chrome_debugger.simpleVariant("::", [
              /* tuple */[
                source,
                /* [] */0
              ],
              queues
            ]);
  };
  var remove = function (queues, target) {
    var lastQueueMatched = {
      contents: undefined
    };
    return Belt_List.keepMap(queues, (function (param) {
                  var queue = param[1];
                  var source = param[0];
                  if (Caml_obj.caml_equal(source, target) && Belt_Option.isNone(lastQueueMatched.contents)) {
                    lastQueueMatched.contents = queue;
                    return ;
                  }
                  var queue$prime = lastQueueMatched.contents;
                  if (queue$prime !== undefined) {
                    lastQueueMatched.contents = undefined;
                    return /* tuple */[
                            source,
                            Belt_List.concat(queue$prime, queue)
                          ];
                  } else {
                    return /* tuple */[
                            source,
                            queue
                          ];
                  }
                }));
  };
  var addTasks = function (queues, target, tasks) {
    var concatenated = {
      contents: false
    };
    return Belt_List.keepMap(queues, (function (param) {
                  var queue = param[1];
                  var source = param[0];
                  if (Caml_obj.caml_equal(source, target) && !concatenated.contents) {
                    concatenated.contents = true;
                    return /* tuple */[
                            source,
                            Belt_List.concat(queue, tasks)
                          ];
                  } else {
                    return /* tuple */[
                            source,
                            queue
                          ];
                  }
                }));
  };
  var countBySource = function (queues, target) {
    return Belt_List.reduce(queues, 0, (function (accum, param) {
                  if (Caml_obj.caml_equal(param[0], target)) {
                    return accum + 1 | 0;
                  } else {
                    return accum;
                  }
                }));
  };
  var log = function (queues) {
    var strings = Belt_List.toArray(Belt_List.map(queues, (function (param) {
                switch (param[0]) {
                  case /* Agda */0 :
                      return "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* View */1 :
                      return "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Command */2 :
                      return "Comm " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Misc */3 :
                      return "Misc " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  
                }
              })));
    console.log(strings.join("\n"));
    
  };
  var getNextTask = function (blocking, queues) {
    if (!queues) {
      return ;
    }
    var match = queues[0];
    var match$1 = match[1];
    var _source = match[0];
    if (match$1) {
      return /* tuple */[
              match$1[0],
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    _source,
                    match$1[1]
                  ],
                  queues[1]
                ])
            ];
    } else if (blocking) {
      return ;
    } else {
      return Belt_Option.map(getNextTask(blocking, queues[1]), (function (param) {
                    return /* tuple */[
                            param[0],
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                /* tuple */[
                                  _source,
                                  /* [] */0
                                ],
                                param[1]
                              ])
                          ];
                  }));
    }
  };
  var taskSize = function (queues) {
    return Belt_List.reduce(queues, 0, (function (accum, param) {
                  return accum + Belt_List.length(param[1]) | 0;
                }));
  };
  var MultiQueue = {
    make: make,
    spawn: spawn,
    remove: remove,
    addTasks: addTasks,
    countBySource: countBySource,
    log: log,
    getNextTask: getNextTask,
    taskSize: taskSize
  };
  var make$1 = function (param) {
    return {
            blocking: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  /* Command */2,
                  /* [] */0
                ],
                /* [] */0
              ]),
            critical: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  /* Command */2,
                  /* [] */0
                ],
                /* [] */0
              ]),
            statusBlocking: /* Idle */1,
            statusCritical: /* Idle */1
          };
  };
  var spawn$1 = function (self, target) {
    self.blocking = spawn(self.blocking, target);
    
  };
  var remove$1 = function (self, target) {
    self.blocking = remove(self.blocking, target);
    
  };
  var addTasks$1 = function (self, target, tasks) {
    self.blocking = addTasks(self.blocking, target, tasks);
    
  };
  var countBySource$1 = function (self, target) {
    return countBySource(self.blocking, target);
  };
  var logQueues = function (self) {
    return log(self.blocking);
  };
  var getNextTask$1 = function (self) {
    return getNextTask(true, self.blocking);
  };
  var addMiscTasks = function (self, tasks) {
    spawn$1(self, /* Misc */3);
    addTasks$1(self, /* Misc */3, tasks);
    remove$1(self, /* Misc */3);
    return $$Promise.resolved(true);
  };
  var Blocking = {
    spawn: spawn$1,
    remove: remove$1,
    addTasks: addTasks$1,
    countBySource: countBySource$1,
    logQueues: logQueues,
    getNextTask: getNextTask$1,
    addMiscTasks: addMiscTasks
  };
  var spawn$2 = function (self, target) {
    self.critical = spawn(self.critical, target);
    
  };
  var remove$2 = function (self, target) {
    self.critical = remove(self.critical, target);
    
  };
  var addTasks$2 = function (self, target, tasks) {
    self.critical = addTasks(self.critical, target, tasks);
    
  };
  var countBySource$2 = function (self, target) {
    return countBySource(self.critical, target);
  };
  var logQueues$1 = function (self) {
    return log(self.critical);
  };
  var getNextTask$2 = function (self) {
    return getNextTask(false, self.critical);
  };
  var addMiscTasks$1 = function (self, tasks) {
    spawn$2(self, /* Misc */3);
    addTasks$2(self, /* Misc */3, tasks);
    remove$2(self, /* Misc */3);
    return $$Promise.resolved(true);
  };
  var Critical = {
    spawn: spawn$2,
    remove: remove$2,
    addTasks: addTasks$2,
    countBySource: countBySource$2,
    logQueues: logQueues$1,
    getNextTask: getNextTask$2,
    addMiscTasks: addMiscTasks$1
  };
  var sendAgdaRequest = function (runTasks, state, req) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        console.log(">>> " + Response$AgdaModeVscode.toString(response));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response));
      }
      console.log(">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap(Curry._2(Task.State.sendRequestToAgda, state, req), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var isCritical = function (param) {
    if (typeof param === "number") {
      if (param === /* Escape */8) {
        return true;
      } else {
        return false;
      }
    } else if (param.tag === /* InputSymbol */4) {
      return true;
    } else {
      return false;
    }
  };
  var executeTask = function (self, state, task) {
    console.log("\n\nTask: " + Curry._1(Task.toString, task));
    log(self.critical);
    console.log("-------------------------------");
    log(self.blocking);
    if (typeof task === "number") {
      return $$Promise.map(Curry._1(Task.State.destroy, state), (function (param) {
                    return false;
                  }));
    }
    switch (task.tag | 0) {
      case /* DispatchCommand */0 :
          var tasks = Curry._1(CommandHandler.handle, task[0]);
          addTasks$2(self, /* Command */2, tasks);
          return $$Promise.resolved(true);
      case /* SendRequest */1 :
          if (countBySource(self.blocking, /* Agda */0) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawn$1(self, /* Agda */0);
            $$Promise.get(sendAgdaRequest((function (tasks) {
                        log(self.blocking);
                        addTasks$1(self, /* Agda */0, tasks);
                        return kickStart(self, state);
                      }), state, task[0]), (function (param) {
                    return remove$1(self, /* Agda */0);
                  }));
            return $$Promise.resolved(true);
          }
      case /* ViewReq */2 :
          var request = task[0];
          if (typeof request !== "number") {
            var match = request[1];
            if (typeof match !== "number" && match.tag) {
              var callback = task[1];
              var request_000 = request[0];
              var request_001 = /* Query */Caml_chrome_debugger.variant("Query", 1, [
                  match[0],
                  match[1]
                ]);
              var request$1 = /* Plain */Caml_chrome_debugger.simpleVariant("Plain", [
                  request_000,
                  request_001
                ]);
              if (countBySource(self.blocking, /* View */1) > 0) {
                return $$Promise.resolved(false);
              } else {
                spawn$1(self, /* View */1);
                return $$Promise.map($$Promise.map(Curry._2(Task.State.sendRequestToView, state, request$1), (function (response) {
                                  return addTasks$1(self, /* View */1, Curry._1(callback, response));
                                })), (function (param) {
                              remove$1(self, /* View */1);
                              return true;
                            }));
              }
            }
            
          }
          var callback$1 = task[1];
          spawn$2(self, /* View */1);
          return $$Promise.map($$Promise.map(Curry._2(Task.State.sendRequestToView, state, request), (function (response) {
                            return addTasks$2(self, /* View */1, Curry._1(callback$1, response));
                          })), (function (param) {
                        remove$2(self, /* View */1);
                        return true;
                      }));
      case /* ViewEvent */3 :
          var tasks$1 = task[0] ? /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* Terminate */0,
                /* [] */0
              ]) : /* [] */0;
          return addMiscTasks$1(self, tasks$1);
      case /* Error */4 :
          var tasks$2 = Curry._1(ErrorHandler.handle, task[0]);
          return addMiscTasks$1(self, tasks$2);
      case /* Goal */5 :
          var tasks$3 = Curry._1(GoalHandler.handle, task[0]);
          return addMiscTasks(self, tasks$3);
      case /* WithState */6 :
          spawn$1(self, /* Misc */3);
          return $$Promise.map($$Promise.tap($$Promise.map(Curry._1(task[0], state), (function (param) {
                                return addTasks$1(self, /* Misc */3, param);
                              })), (function (param) {
                            return remove$1(self, /* Misc */3);
                          })), (function (param) {
                        return true;
                      }));
      case /* Debug */7 :
          console.log("DEBUG " + task[0]);
          return $$Promise.resolved(true);
      
    }
  };
  var kickStart = function (self, state) {
    var match = self.statusCritical;
    if (match) {
      var match$1 = getNextTask(false, self.critical);
      if (match$1 !== undefined) {
        self.critical = match$1[1];
        self.statusCritical = /* Busy */0;
        $$Promise.get(executeTask(self, state, match$1[0]), (function (keepRunning) {
                self.statusCritical = /* Idle */1;
                if (keepRunning) {
                  return kickStart(self, state);
                }
                
              }));
      }
      
    }
    var match$2 = self.statusBlocking;
    if (!match$2) {
      return ;
    }
    var match$3 = getNextTask(true, self.blocking);
    if (match$3 !== undefined) {
      self.blocking = match$3[1];
      self.statusBlocking = /* Busy */0;
      return $$Promise.get(executeTask(self, state, match$3[0]), (function (keepRunning) {
                    self.statusBlocking = /* Idle */1;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    
  };
  var dispatchCommand = function (self, state, command) {
    addTasks$2(self, /* Command */2, /* :: */Caml_chrome_debugger.simpleVariant("::", [
            /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
            /* [] */0
          ]));
    return kickStart(self, state);
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          MultiQueue: MultiQueue,
          make: make$1,
          Blocking: Blocking,
          Critical: Critical,
          sendAgdaRequest: sendAgdaRequest,
          isCritical: isCritical,
          executeTask: executeTask,
          kickStart: kickStart,
          dispatchCommand: dispatchCommand,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
