// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var IM$AgdaModeVscode = require("./InputMethod/IM.bs.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var State$AgdaModeVscode = require("./State.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Command$AgdaModeVscode = require("./Command.bs.js");
var Registry$AgdaModeVscode = require("./Registry.bs.js");
var Connection$AgdaModeVscode = require("./Connection.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var State__Command$AgdaModeVscode = require("./State/State__Command.bs.js");
var ViewController$AgdaModeVscode = require("./ViewController.bs.js");
var Connection__Error$AgdaModeVscode = require("./Connection/Connection__Error.bs.js");
var State__InputMethod$AgdaModeVscode = require("./State/State__InputMethod.bs.js");

function isAgda(fileName) {
  var fileName$1 = Parser$AgdaModeVscode.filepath(fileName);
  return /\.agda$|\.lagda/i.test(fileName$1);
}

function onOpenEditor(callback) {
  Belt_Option.forEach(Vscode.window.activeTextEditor, callback);
  return Vscode.window.onDidChangeActiveTextEditor(function (next) {
              return Belt_Option.forEach(next, callback);
            });
}

function onCloseDocument(callback) {
  return Vscode.workspace.onDidCloseTextDocument(callback);
}

function onTriggerCommand(callback) {
  return Belt_Array.map(Command$AgdaModeVscode.names, (function (param) {
                var command = param[0];
                return Vscode.commands.registerCommand("agda-mode." + param[1], (function (param) {
                              return Belt_Option.map(Vscode.window.activeTextEditor, (function (editor) {
                                            var fileName = Parser$AgdaModeVscode.filepath(editor.document.fileName);
                                            if (isAgda(fileName)) {
                                              return Curry._2(callback, command, editor);
                                            } else {
                                              return $$Promise.resolved(undefined);
                                            }
                                          }));
                            }));
              }));
}

var Inputs = {
  onOpenEditor: onOpenEditor,
  onCloseDocument: onCloseDocument,
  onTriggerCommand: onTriggerCommand
};

function initiateConnection(devMode) {
  if (Registry$AgdaModeVscode.isEmpty(undefined)) {
    Vscode.commands.executeCommand("setContext", "agdaMode", true);
  }
  if (!Config$AgdaModeVscode.useAgdaLanguageServer(undefined)) {
    return $$Promise.mapOk(Connection$AgdaModeVscode.Emacs.make(undefined), (function (conn) {
                  return {
                          TAG: 0,
                          _0: conn,
                          _1: Connection$AgdaModeVscode.Emacs.getVersion(conn),
                          [Symbol.for("name")]: "Emacs"
                        };
                }));
  }
  if (Registry$AgdaModeVscode.isEmpty(undefined)) {
    return $$Promise.flatMapError($$Promise.mapOk(Connection$AgdaModeVscode.LSP.start(devMode), (function (param) {
                      var method = param[1];
                      var version = param[0];
                      if (method.TAG === /* ViaStdIO */0) {
                        console.log("[LSP] Server started via stdio on \"" + method._1 + "\". Agda version: " + version);
                      } else {
                        console.log("[LSP] Server started via TCP on port " + String(method._0) + ". Agda version: " + version);
                      }
                      return {
                              TAG: 1,
                              _0: version,
                              _1: method,
                              [Symbol.for("name")]: "LSP"
                            };
                    })), (function (error) {
                  console.log("[LSP] Connection failed, switching to the Agda executable instead: " + Connection__Error$AgdaModeVscode.toString(error)[0] + "\n" + Connection__Error$AgdaModeVscode.toString(error)[1]);
                  return $$Promise.mapOk(Connection$AgdaModeVscode.Emacs.make(undefined), (function (conn) {
                                return {
                                        TAG: 0,
                                        _0: conn,
                                        _1: Connection$AgdaModeVscode.Emacs.getVersion(conn),
                                        [Symbol.for("name")]: "Emacs"
                                      };
                              }));
                }));
  }
  var match = Connection$AgdaModeVscode.LSP.getVersion(undefined);
  if (match !== undefined) {
    return $$Promise.resolved({
                TAG: 0,
                _0: {
                  TAG: 1,
                  _0: match[0],
                  _1: match[1],
                  [Symbol.for("name")]: "LSP"
                },
                [Symbol.for("name")]: "Ok"
              });
  } else {
    return $$Promise.mapOk(Connection$AgdaModeVscode.Emacs.make(undefined), (function (conn) {
                  return {
                          TAG: 0,
                          _0: conn,
                          _1: Connection$AgdaModeVscode.Emacs.getVersion(conn),
                          [Symbol.for("name")]: "Emacs"
                        };
                }));
  }
}

function initialize(debugChan, extensionPath, editor, fileName, connection) {
  var view = ViewController$AgdaModeVscode.Handle.make(extensionPath);
  $$Promise.get(ViewController$AgdaModeVscode.onceDestroyed(view), (function (param) {
          Registry$AgdaModeVscode.removeAndDestroyAll(undefined);
          
        }));
  var state = State$AgdaModeVscode.make(debugChan, editor, view, connection);
  switch (connection.TAG | 0) {
    case /* Emacs */0 :
        State$AgdaModeVscode.View.setStatus(state, "Emacs");
        break;
    case /* LSP */1 :
        if (connection._1.TAG === /* ViaStdIO */0) {
          State$AgdaModeVscode.View.setStatus(state, "LSP");
        } else {
          State$AgdaModeVscode.View.setStatus(state, "LSP (TCP)");
        }
        break;
    case /* Nothing */2 :
        State$AgdaModeVscode.View.setStatus(state, "");
        break;
    
  }
  $$Promise.get(Chan$AgdaModeVscode.once(state.onRemoveFromRegistry), (function (param) {
          return Registry$AgdaModeVscode.remove(fileName);
        }));
  var subscribe = function (disposable) {
    state.subscriptions.push(disposable);
    
  };
  var getCurrentEditor = function (param) {
    var editor = Vscode.window.activeTextEditor;
    if (editor !== undefined) {
      return Caml_option.some(Caml_option.valFromOption(editor));
    } else {
      return Belt_Array.get(Vscode.window.visibleTextEditors, 0);
    }
  };
  subscribe(ViewController$AgdaModeVscode.onEvent(state.view, (function ($$event) {
              var editor$prime = getCurrentEditor(undefined);
              if (editor$prime === undefined) {
                return ;
              }
              var fileName$prime = Caml_option.valFromOption(editor$prime).document.fileName;
              if (fileName$prime === fileName) {
                State__Command$AgdaModeVscode.dispatchCommand(state, {
                      TAG: 8,
                      _0: $$event,
                      [Symbol.for("name")]: "EventFromView"
                    });
                return ;
              }
              
            })));
  subscribe(Vscode.window.onDidChangeTextEditorSelection(function ($$event) {
            var $$document = editor.document;
            var intervals = Belt_Array.map($$event.selections, (function (selection) {
                    return [
                            Editor$AgdaModeVscode.Position.toOffset($$document, selection.start),
                            Editor$AgdaModeVscode.Position.toOffset($$document, selection.end)
                          ];
                  }));
            State__InputMethod$AgdaModeVscode.select(state, intervals);
            
          }));
  subscribe(Vscode.workspace.onDidChangeTextDocument(function ($$event) {
            var changes = IM$AgdaModeVscode.Input.fromTextDocumentChangeEvent(editor, $$event);
            State__InputMethod$AgdaModeVscode.keyUpdateEditorIM(state, changes);
            
          }));
  subscribe(Editor$AgdaModeVscode.Provider.registerDefinitionProvider(function (fileName, position) {
            var currentFileName = Parser$AgdaModeVscode.filepath(state.document.fileName);
            if (fileName === currentFileName) {
              return Decoration$AgdaModeVscode.lookupSrcLoc(state.decoration, position);
            }
            
          }));
  return Registry$AgdaModeVscode.add(fileName, state);
}

function finalize(param) {
  if (Registry$AgdaModeVscode.isEmpty(undefined)) {
    Vscode.commands.executeCommand("setContext", "agdaMode", false);
    ViewController$AgdaModeVscode.Handle.destroy(undefined);
  }
  return $$Promise.resolved(undefined);
}

function activateWithoutContext(subscriptions, extensionPath, devMode) {
  var debugChan = Chan$AgdaModeVscode.make(undefined);
  var x = onOpenEditor(function (editor) {
        var fileName = editor.document.fileName;
        if (isAgda(fileName)) {
          return Belt_Option.forEach(Registry$AgdaModeVscode.get(fileName), (function (state) {
                        state.editor = editor;
                        state.document = editor.document;
                        State__Command$AgdaModeVscode.dispatchCommand(state, /* Refresh */3);
                        
                      }));
        }
        
      });
  subscriptions.push(x);
  var x$1 = Vscode.workspace.onDidCloseTextDocument(function ($$document) {
        var fileName = $$document.fileName;
        if (isAgda(fileName)) {
          Registry$AgdaModeVscode.removeAndDestroy(fileName);
          finalize(undefined);
          return ;
        }
        
      });
  subscriptions.push(x$1);
  var xs = onTriggerCommand(function (command, editor) {
        console.log("[ command ] " + Command$AgdaModeVscode.toString(command));
        var fileName = editor.document.fileName;
        return $$Promise.flatMap($$Promise.flatMap(typeof command === "number" && (command === 2 || command === 1) ? $$Promise.flatMap(Registry$AgdaModeVscode.removeAndDestroy(fileName), finalize) : $$Promise.resolved(undefined), (function (param) {
                          if (typeof command === "number") {
                            switch (command) {
                              case /* Load */0 :
                              case /* Restart */2 :
                                  break;
                              default:
                                return $$Promise.resolved(undefined);
                            }
                          } else {
                            if (command.TAG !== /* InputMethod */13) {
                              return $$Promise.resolved(undefined);
                            }
                            var match = command._0;
                            if (typeof match !== "number") {
                              return $$Promise.resolved(undefined);
                            }
                            if (match !== 0) {
                              return $$Promise.resolved(undefined);
                            }
                            
                          }
                          var match$1 = Registry$AgdaModeVscode.get(fileName);
                          if (match$1 !== undefined) {
                            return $$Promise.resolved(undefined);
                          } else {
                            return $$Promise.map($$Promise.map(initiateConnection(devMode), (function (result) {
                                              if (result.TAG === /* Ok */0) {
                                                return result._0;
                                              } else {
                                                return {
                                                        TAG: 2,
                                                        _0: result._0,
                                                        [Symbol.for("name")]: "Nothing"
                                                      };
                                              }
                                            })), (function (param) {
                                          return initialize(debugChan, extensionPath, editor, fileName, param);
                                        }));
                          }
                        })), (function (param) {
                      var state = Registry$AgdaModeVscode.get(fileName);
                      if (state !== undefined) {
                        return State__Command$AgdaModeVscode.dispatchCommand(state, command);
                      } else {
                        return $$Promise.resolved(undefined);
                      }
                    }));
      });
  Caml_splice_call.spliceObjApply(subscriptions, "push", [xs]);
  return debugChan;
}

function activate(context) {
  var subscriptions = context.subscriptions;
  var extensionPath = context.extensionPath;
  var devMode = VSCode.ExtensionContext.extensionMode(context) === /* Development */1;
  return activateWithoutContext(subscriptions, extensionPath, devMode);
}

function deactivate(param) {
  
}

exports.isAgda = isAgda;
exports.Inputs = Inputs;
exports.initiateConnection = initiateConnection;
exports.initialize = initialize;
exports.finalize = finalize;
exports.activateWithoutContext = activateWithoutContext;
exports.activate = activate;
exports.deactivate = deactivate;
/* VSCode Not a pure module */
