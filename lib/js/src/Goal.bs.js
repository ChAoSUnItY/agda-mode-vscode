// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var SourceFile$AgdaModeVscode = require("./Parser/SourceFile.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var make = function (editor, diff) {
    var originalRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, diff.originalRange[0]), Curry._2(Editor.pointAtOffset, editor, diff.originalRange[1]));
    var modifiedRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, diff.modifiedRange[0]), Curry._2(Editor.pointAtOffset, editor, diff.modifiedRange[1]));
    return (function (param) {
        return $$Promise.map(Curry._3(Editor.setText, editor, originalRange, diff.content), (function (param) {
                      var decorations = Curry._3(Decoration.decorateHole, editor, modifiedRange, diff.index);
                      return {
                              index: diff.index,
                              range: modifiedRange,
                              decorations: decorations
                            };
                    }));
      });
  };
  var makeMany = function (editor, indices) {
    var filePath = Belt_Option.getWithDefault(Curry._1(Editor.getFileName, editor), "unnamed.agda");
    var source = Curry._1(Editor.getText, editor);
    var diffs = SourceFile$AgdaModeVscode.parse(indices, filePath, source);
    return Util$AgdaModeVscode.oneByOne(Belt_Array.map(diffs, (function (param) {
                      return make(editor, param);
                    })));
  };
  var getContent = function (self, editor) {
    var range = Curry._2(Editor.$$Range.make, Curry._3(Editor.Point.translate, Curry._1(Editor.$$Range.start, self.range), 0, 2), Curry._3(Editor.Point.translate, Curry._1(Editor.$$Range.end_, self.range), 0, -2));
    return Parser$AgdaModeVscode.userInput(Curry._2(Editor.getTextInRange, editor, range));
  };
  var buildHaskellRange = function (editor, self, old, filepath) {
    var start = Curry._1(Editor.$$Range.start, self.range);
    var startIndex = Curry._2(Editor.offsetAtPoint, editor, start);
    var end_ = Curry._1(Editor.$$Range.end_, self.range);
    var endIndex = Curry._2(Editor.offsetAtPoint, editor, end_);
    var startIndex$prime = String(startIndex + 3 | 0);
    var startRow = String(Curry._1(Editor.Point.line, start) + 1 | 0);
    var startColumn = String(Curry._1(Editor.Point.column, start) + 3 | 0);
    var startPart = "" + (String(startIndex$prime) + (" " + (String(startRow) + (" " + (String(startColumn) + "")))));
    var endIndex$prime = String(endIndex - 3 | 0);
    var endRow = String(Curry._1(Editor.Point.line, end_) + 1 | 0);
    var endColumn = String(Curry._1(Editor.Point.column, end_) - 1 | 0);
    var endPart = "" + (String(endIndex$prime) + (" " + (String(endRow) + (" " + (String(endColumn) + "")))));
    if (old) {
      return "(Range [Interval (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(startPart) + (") (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(endPart) + ")])")))))));
    } else {
      return "(intervalsToRange (Just (mkAbsolute \"" + (String(filepath) + ("\")) [Interval (Pn () " + (String(startPart) + (") (Pn () " + (String(endPart) + ")])")))));
    }
  };
  var destroy = function (self) {
    return Belt_Array.forEach(self.decorations, Editor.Decoration.destroy);
  };
  return {
          Decoration: Decoration,
          make: make,
          makeMany: makeMany,
          getContent: getContent,
          buildHaskellRange: buildHaskellRange,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
