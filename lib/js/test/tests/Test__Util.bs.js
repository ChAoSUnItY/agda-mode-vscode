// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

var Exn = Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

function getValue(string) {
  return string[0];
}

function fromChangeObject(obj) {
  if (obj.added) {
    return /* Added */Caml_chrome_debugger.variant("Added", 0, [obj.value]);
  } else if (obj.removed) {
    return /* Removed */Caml_chrome_debugger.variant("Removed", 1, [obj.value]);
  } else {
    return /* NoChange */Caml_chrome_debugger.variant("NoChange", 2, [obj.value]);
  }
}

function wordsWithSpace(a, b) {
  return Belt_Array.map(Diff.diffWordsWithSpace(a, b), fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  Belt_Array.forEach(diffs, (function (diff) {
          if (!Belt_Option.isNone(change.contents)) {
            return ;
          }
          switch (diff.tag | 0) {
            case /* Added */0 :
                change.contents = /* Added */Caml_chrome_debugger.variant("Added", 0, [diff[0]]);
                return ;
            case /* Removed */1 :
                change.contents = /* Removed */Caml_chrome_debugger.variant("Removed", 1, [diff[0]]);
                return ;
            case /* NoChange */2 :
                count.contents = count.contents + diff[0].length | 0;
                return ;
            
          }
        }));
  return Belt_Option.map(change.contents, (function (change) {
                return /* tuple */[
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(dirname) {
  var readdir = Util.promisify((function (prim, prim$1) {
          Fs.readdir(prim, prim$1);
          
        }));
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return readdir(dirname).then((function (paths) {
                return Promise.resolve(Belt_Array.map(Belt_Array.keep(paths, isInFile), toBasename));
              }));
}

function getGoldenFilepathsSync(dirname) {
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return Belt_Array.map(Belt_Array.keep(Fs.readdirSync(dirname), isInFile), toBasename);
}

var FileMissing = Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function map(param, f) {
  return /* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
            param[0],
            Curry._1(f, param[1]),
            param[2]
          ]);
}

function readFile(filepath) {
  var readFile$1 = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          
        }));
  return Promise.all([
                readFile$1(filepath + ".in"),
                readFile$1(filepath + ".out")
              ]).then((function (param) {
                if (param.length !== 2) {
                  return Promise.reject([
                              FileMissing,
                              filepath
                            ]);
                }
                var input = param[0];
                var output = param[1];
                return Promise.resolve(/* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
                              filepath,
                              input.toString(),
                              output.toString()
                            ]));
              }));
}

function compare(param) {
  var actual = param[1].trim();
  var expected = param[2].trim();
  Belt_Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff[0];
          var change = value.length > 100 ? value.substr(0, 100) + " ..." : value;
          var expected$prime = expected.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var actual$prime = actual.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var message = "\n\nexpected => " + (expected$prime + ("\n\nactual   => " + (actual$prime + "\n\nchange => ")));
          switch (diff.tag | 0) {
            case /* Added */0 :
                return Assert$BsMocha.fail(message + (" added \"" + (change + ("\"\n at position " + String(count)))));
            case /* Removed */1 :
                return Assert$BsMocha.fail(message + (" removed \"" + (change + ("\"\n\n at position " + String(count)))));
            case /* NoChange */2 :
                return ;
            
          }
        }));
  return Promise.resolve(undefined);
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  map: map,
  readFile: readFile,
  compare: compare
};

function serialize(xs) {
  return Caml_splice_call.spliceObjApply("", "concat", [Belt_Array.map(xs, (function (x) {
                      return x + "\n";
                    }))]);
}

function serializeWith(f, xs) {
  return serialize(Belt_Array.map(xs, f));
}

exports.Exn = Exn;
exports.Golden = Golden;
exports.serialize = serialize;
exports.serializeWith = serializeWith;
/* fs Not a pure module */
