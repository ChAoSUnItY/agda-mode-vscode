// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Dispatcher$AgdaModeVscode = require("./Dispatcher.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Dispatcher = Dispatcher$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var make = function (state) {
    return {
            queues: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  /* Command */3,
                  /* [] */0
                ],
                /* [] */0
              ]),
            status: /* Idle */1
          };
  };
  var getNextTask = function (self) {
    var match = self.queues;
    if (!match) {
      return ;
    }
    var match$1 = match[0];
    var match$2 = match$1[1];
    if (match$2) {
      return /* tuple */[
              match$2[0],
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    match$1[0],
                    match$2[1]
                  ],
                  match[1]
                ])
            ];
    }
    
  };
  var spawnQueue = function (self, source) {
    self.queues = /* :: */Caml_chrome_debugger.simpleVariant("::", [
        /* tuple */[
          source,
          /* [] */0
        ],
        self.queues
      ]);
    
  };
  var removeQueue = function (self, target) {
    var lastQueueMatched = {
      contents: undefined
    };
    self.queues = Belt_List.keepMap(self.queues, (function (param) {
            var queue = param[1];
            var source = param[0];
            if (source === target && Belt_Option.isNone(lastQueueMatched.contents)) {
              lastQueueMatched.contents = queue;
              return ;
            }
            var queue$prime = lastQueueMatched.contents;
            if (queue$prime !== undefined) {
              lastQueueMatched.contents = undefined;
              return /* tuple */[
                      source,
                      Belt_List.concat(queue$prime, queue)
                    ];
            } else {
              return /* tuple */[
                      source,
                      queue
                    ];
            }
          }));
    
  };
  var addTasksToQueue = function (self, target, tasks) {
    var concatenated = {
      contents: false
    };
    self.queues = Belt_List.keepMap(self.queues, (function (param) {
            var queue = param[1];
            var source = param[0];
            if (source === target && !concatenated.contents) {
              concatenated.contents = true;
              return /* tuple */[
                      source,
                      Belt_List.concat(queue, tasks)
                    ];
            } else {
              return /* tuple */[
                      source,
                      queue
                    ];
            }
          }));
    
  };
  var countSource = function (self, target) {
    return Belt_List.reduce(self.queues, 0, (function (accum, param) {
                  if (param[0] === target) {
                    return accum + 1 | 0;
                  } else {
                    return accum;
                  }
                }));
  };
  var logQueues = function (self) {
    var queues = Belt_List.toArray(Belt_List.map(self.queues, (function (param) {
                switch (param[0]) {
                  case /* Agda */0 :
                      return "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* View */1 :
                      return "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* WithState */2 :
                      return "With " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Command */3 :
                      return "Comm " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  
                }
              })));
    console.log("\n===============================\n" + queues.join("\n"));
    
  };
  var executeTask = function (self, state, task) {
    console.log("Task: " + Curry._1(Task.toString, task));
    if (typeof task === "number") {
      return $$Promise.resolved(true);
    }
    switch (task.tag | 0) {
      case /* SendRequest */1 :
          if (countSource(self, /* Agda */0) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawnQueue(self, /* Agda */0);
            $$Promise.get(Curry._3(Dispatcher.sendAgdaRequest, (function (tasks) {
                        logQueues(self);
                        return addTasksToQueue(self, /* Agda */0, tasks);
                      }), state, task[0]), (function (param) {
                    logQueues(self);
                    return removeQueue(self, /* Agda */0);
                  }));
            return $$Promise.resolved(true);
          }
      case /* WithState */6 :
          spawnQueue(self, /* WithState */2);
          return $$Promise.map($$Promise.tap($$Promise.map(Curry._1(task[0], state), (function (tasks) {
                                return addTasksToQueue(self, /* WithState */2, tasks);
                              })), (function (param) {
                            return removeQueue(self, /* WithState */2);
                          })), (function (param) {
                        return true;
                      }));
      case /* Debug */7 :
          console.log("DEBUG " + task[0]);
          return $$Promise.resolved(true);
      default:
        return $$Promise.resolved(true);
    }
  };
  var kickStart = function (self, state) {
    logQueues(self);
    var match = self.status;
    if (!match) {
      return ;
    }
    var match$1 = getNextTask(self);
    if (match$1 !== undefined) {
      self.status = /* Busy */0;
      self.queues = match$1[1];
      return $$Promise.get(executeTask(self, state, match$1[0]), (function (keepRunning) {
                    self.status = /* Idle */1;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    
  };
  var dispatchCommand = function (self, state, command) {
    var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
    var tasks = Curry._1(CommandHandler.handle, command);
    self.queues = Belt_List.map(self.queues, (function (param) {
            var queue = param[1];
            var source = param[0];
            if (source === /* Command */3) {
              return /* tuple */[
                      source,
                      Belt_List.concat(queue, tasks)
                    ];
            } else {
              return /* tuple */[
                      source,
                      queue
                    ];
            }
          }));
    return kickStart(self, state);
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Dispatcher: Dispatcher,
          Task: Task,
          make: make,
          getNextTask: getNextTask,
          spawnQueue: spawnQueue,
          removeQueue: removeQueue,
          addTasksToQueue: addTasksToQueue,
          countSource: countSource,
          logQueues: logQueues,
          executeTask: executeTask,
          kickStart: kickStart,
          dispatchCommand: dispatchCommand,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
