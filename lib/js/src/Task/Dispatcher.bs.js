// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var TaskQueue$AgdaModeVscode = require("./TaskQueue.bs.js");
var Connection$AgdaModeVscode = require("../Connection.bs.js");
var Decoration$AgdaModeVscode = require("../Decoration.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var sendAgdaRequest = function (runTasks, runTasksLater, state, request) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        if (response.tag) {
          var response$1 = response[1];
          var priority = response[0];
          console.log(">>> " + (String(priority) + (" " + Response$AgdaModeVscode.toString(response$1))));
          var tasks = Curry._1(ResponseHandler.handle, response$1);
          return Curry._2(runTasksLater, priority, tasks);
        }
        var response$2 = response[0];
        console.log(">>> " + Response$AgdaModeVscode.toString(response$2));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response$2));
      }
      console.log(">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap($$Promise.mapOk(Curry._1(Task.State.connect, state), (function (connection) {
                          var version = connection.metadata.version;
                          var filepath = Belt_Option.getWithDefault(Curry._1(Editor.getFileName, state.editor), "");
                          var libraryPath = Curry._1(Editor.Config.getLibraryPath, undefined);
                          var highlightingMethod = Curry._1(Editor.Config.getHighlightingMethod, undefined);
                          var backend = Curry._1(Editor.Config.getBackend, undefined);
                          var encoded = Curry._7(Task.$$Request.encode, state.editor, version, filepath, backend, libraryPath, highlightingMethod, request);
                          console.log("<<<", encoded);
                          Connection$AgdaModeVscode.send(encoded, connection);
                          return connection;
                        })), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var log = function (param) {
    
  };
  var make = function (param) {
    return {
            queues: TaskQueue$AgdaModeVscode.make(undefined),
            busy: false,
            shouldDestroy: undefined
          };
  };
  var addTasks = function (self, tasks) {
    self.queues = TaskQueue$AgdaModeVscode.addTasksToMain(self.queues, tasks);
    
  };
  var addTasksToAgda = function (self, tasks) {
    self.queues = TaskQueue$AgdaModeVscode.addTasksToAgda(self.queues, tasks);
    
  };
  var addTasksToView = function (self, tasks) {
    self.queues = TaskQueue$AgdaModeVscode.addTasksToView(self.queues, tasks);
    
  };
  var getNextTask = function (self) {
    var match = TaskQueue$AgdaModeVscode.getNextTask(self.queues);
    self.queues = match[1];
    return match[0];
  };
  var agdaOccupied = function (self) {
    return Belt_Option.isSome(self.queues.agda);
  };
  var acquireAgda = function (self) {
    self.queues = TaskQueue$AgdaModeVscode.acquireAgda(self.queues);
    
  };
  var releaseAgda = function (self) {
    self.queues = TaskQueue$AgdaModeVscode.releaseAgda(self.queues);
    
  };
  var viewOccupied = function (self) {
    return Belt_Option.isSome(self.queues.view);
  };
  var acquireView = function (self) {
    self.queues = TaskQueue$AgdaModeVscode.acquireView(self.queues);
    
  };
  var releaseView = function (self) {
    self.queues = TaskQueue$AgdaModeVscode.releaseView(self.queues);
    
  };
  var Queues = {
    addTasks: addTasks,
    addTasksToAgda: addTasksToAgda,
    addTasksToView: addTasksToView,
    getNextTask: getNextTask,
    agdaOccupied: agdaOccupied,
    acquireAgda: acquireAgda,
    releaseAgda: releaseAgda,
    viewOccupied: viewOccupied,
    acquireView: acquireView,
    releaseView: releaseView
  };
  var executeTask = function (self, state, task) {
    if (typeof task === "number") {
      switch (task) {
        case /* SuicideByCop */0 :
            Curry._1(Task.State.emitKillMePlz, state);
            return $$Promise.resolved(false);
        case /* RemoveAllHighlightings */1 :
            Belt_Array.forEach(Belt_Array.map(state.decorations, (function (prim) {
                        return prim[0];
                      })), Editor.Decoration.destroy);
            state.decorations = [];
            return $$Promise.resolved(true);
        case /* RefreshAllHighlightings */2 :
            Belt_Array.forEach(state.decorations, (function (param) {
                    return Curry._3(Editor.Decoration.decorate, state.editor, param[0], [param[1]]);
                  }));
            console.log("refreshing goals");
            Belt_Array.forEach(state.goals, (function (goal) {
                    return Curry._2(Task.Goal.refreshDecoration, goal, state.editor);
                  }));
            return $$Promise.resolved(true);
        
      }
    } else {
      switch (task.tag | 0) {
        case /* DispatchCommand */0 :
            var tasks = Curry._1(CommandHandler.handle, task[0]);
            addTasks(self, tasks);
            return $$Promise.resolved(true);
        case /* SendRequest */1 :
            if (Belt_Option.isSome(self.queues.agda)) {
              console.log("[ panic ] There can only be 1 Agda request at a time!");
              return $$Promise.resolved(false);
            }
            acquireAgda(self);
            var lastTasks = [];
            $$Promise.get($$Promise.map(sendAgdaRequest((function (tasks) {
                            addTasksToAgda(self, tasks);
                            return kickStart(self, state);
                          }), (function (priority, tasks) {
                            lastTasks.push(/* tuple */[
                                  priority,
                                  tasks
                                ]);
                            
                          }), state, task[0]), (function (param) {
                        var tasks = Belt_List.concatMany(Belt_Array.map(lastTasks.sort((function (x, y) {
                                        return Caml_primitive.caml_int_compare(x[0], y[0]);
                                      })), (function (prim) {
                                    return prim[1];
                                  })));
                        addTasksToAgda(self, tasks);
                        releaseAgda(self);
                        return kickStart(self, state);
                      })), (function (param) {
                    return releaseAgda(self);
                  }));
            return $$Promise.resolved(true);
        case /* SendEventToView */2 :
            return $$Promise.map(Curry._2(Task.State.sendEventToView, state, task[0]), (function (param) {
                          return true;
                        }));
        case /* SendRequestToView */3 :
            var callback = task[1];
            if (Belt_Option.isSome(self.queues.view)) {
              return $$Promise.resolved(false);
            } else {
              acquireView(self);
              return $$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                            if (response !== undefined) {
                              addTasksToView(self, Curry._1(callback, response));
                              releaseView(self);
                              return true;
                            } else {
                              return true;
                            }
                          }));
            }
        case /* AddHighlightings */4 :
            Belt_Array.forEach(task[0], (function (highlighting) {
                    var decorations = Curry._2(Decoration.decorateHighlighting, state.editor, highlighting);
                    state.decorations = Belt_Array.concat(state.decorations, decorations);
                    
                  }));
            return $$Promise.resolved(true);
        case /* Error */5 :
            var tasks$1 = Curry._1(ErrorHandler.handle, task[0]);
            addTasks(self, tasks$1);
            return $$Promise.resolved(true);
        case /* Goal */6 :
            var tasks$2 = Curry._1(GoalHandler.handle, task[0]);
            addTasks(self, tasks$2);
            return $$Promise.resolved(true);
        case /* WithState */7 :
            Curry._1(task[0], state);
            return $$Promise.resolved(true);
        case /* WithStateP */8 :
            return $$Promise.map($$Promise.map(Curry._1(task[0], state), (function (param) {
                              return addTasks(self, param);
                            })), (function (param) {
                          return true;
                        }));
        case /* Debug */9 :
            console.log("DEBUG " + task[0]);
            return $$Promise.resolved(true);
        
      }
    }
  };
  var kickStart = function (self, state) {
    if (self.busy) {
      return ;
    }
    var task = getNextTask(self);
    if (task !== undefined) {
      self.busy = true;
      return $$Promise.get(executeTask(self, state, task), (function (keepRunning) {
                    self.busy = false;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    var resolve = self.shouldDestroy;
    if (resolve !== undefined) {
      return Curry._1(resolve, undefined);
    }
    
  };
  var destroy = function (self) {
    if (!self.busy) {
      return $$Promise.resolved(undefined);
    }
    var match = $$Promise.pending(undefined);
    self.shouldDestroy = match[1];
    return match[0];
  };
  var forceDestroy = function (self) {
    self.queues = TaskQueue$AgdaModeVscode.make(undefined);
    return $$Promise.resolved(undefined);
  };
  var Runner = {
    make: make,
    Queues: Queues,
    executeTask: executeTask,
    kickStart: kickStart,
    destroy: destroy,
    forceDestroy: forceDestroy
  };
  var make$1 = function (param) {
    return {
            blocking: make(undefined),
            critical: make(undefined)
          };
  };
  var dispatchCommand = function (self, state, command) {
    Curry._1(log, "\n\n" + (TaskQueue$AgdaModeVscode.toString(Task.toString, self.critical.queues) + ("\n----------------------------\n" + TaskQueue$AgdaModeVscode.toString(Task.toString, self.blocking.queues))));
    var exit = 0;
    if (typeof command === "number") {
      switch (command) {
        case /* NextGoal */8 :
        case /* PreviousGoal */9 :
        case /* Escape */15 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    } else {
      switch (command.tag | 0) {
        case /* EventFromView */8 :
        case /* InputMethod */13 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          addTasks(self.blocking, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.blocking, state);
      case 2 :
          addTasks(self.critical, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.critical, state);
      
    }
  };
  var destroy$1 = function (self) {
    return $$Promise.flatMap(destroy(self.critical), (function (param) {
                  return destroy(self.blocking);
                }));
  };
  var forceDestroy$1 = function (self) {
    return $$Promise.flatMap(forceDestroy(self.critical), (function (param) {
                  return forceDestroy(self.blocking);
                }));
  };
  return {
          Decoration: Decoration,
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          sendAgdaRequest: sendAgdaRequest,
          printLog: false,
          log: log,
          Runner: Runner,
          make: make$1,
          dispatchCommand: dispatchCommand,
          destroy: destroy$1,
          forceDestroy: forceDestroy$1
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
