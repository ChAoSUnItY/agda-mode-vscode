// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var VSCode = require("rescript-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("rescript/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var IntervalTree = require("@flatten-js/interval-tree").default;
var Highlighting__Agda$AgdaModeVscode = require("./Highlighting/Highlighting__Agda.bs.js");

function toString(param) {
  var column = param.column;
  return String(param.line) + ":" + String(column[0]) + "-" + String(column[1]);
}

function toVsCodeRange(param) {
  var column = param.column;
  var line = param.line;
  return new Vscode.Range(new Vscode.Position(line, column[0]), new Vscode.Position(line, column[1]));
}

function splitRange(doc, range) {
  var startingLine = range.start.line;
  var endingLine = range.end.line;
  var ranges = [];
  for(var i = startingLine; i <= endingLine; ++i){
    var startingPoint = i === startingLine ? range.start : new Vscode.Position(i, 0);
    var endingPoint;
    if (i === endingLine) {
      endingPoint = range.end;
    } else {
      var offset = doc.offsetAt(new Vscode.Position(i + 1 | 0, 0)) - 1 | 0;
      endingPoint = doc.positionAt(offset);
    }
    ranges.push({
          line: startingPoint.line,
          column: [
            startingPoint.character,
            endingPoint.character
          ]
        });
  }
  return ranges;
}

var SingleLineRange = {
  toString: toString,
  toVsCodeRange: toVsCodeRange,
  splitRange: splitRange
};

function toString$1(token) {
  var tokenType = Curry._1(Highlighting__Agda$AgdaModeVscode.Aspect.TokenType.toString, token.type_);
  var modifiers = Util$AgdaModeVscode.Pretty.array(Belt_Option.mapWithDefault(token.modifiers, [], (function (xs) {
              return Belt_Array.map(xs, Highlighting__Agda$AgdaModeVscode.Aspect.TokenModifier.toString);
            })));
  return "(" + toString(token.range) + ") " + tokenType + " " + modifiers;
}

var SemanticToken = {
  SingleLineRange: SingleLineRange,
  toString: toString$1
};

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function decorateHighlightings(editor, infos) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  var infos$1 = Belt_Array.map(infos.items, (function (item) {
          var highlighting = item.value;
          var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.start);
          var end_ = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.end_);
          var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, [
                start,
                end_
              ]);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(infos$1, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  var srcLocs = Belt_Array.keepMap(infos$1, (function (param) {
          var range = param[0];
          return Belt_Option.map(param[2], (function (param) {
                        return {
                                range: range,
                                filepath: param[0],
                                offset: param[1]
                              };
                      }));
        }));
  var backgroundColorDict = {};
  var foregroundColorDict = {};
  var addFaceToDict = function (face, range) {
    if (face.TAG === /* Background */0) {
      var color = face._0;
      var ranges = Js_dict.get(backgroundColorDict, color);
      if (ranges !== undefined) {
        ranges.push(range);
      } else {
        backgroundColorDict[color] = [range];
      }
      return ;
    }
    var color$1 = face._0;
    var ranges$1 = Js_dict.get(foregroundColorDict, color$1);
    if (ranges$1 !== undefined) {
      ranges$1.push(range);
    } else {
      foregroundColorDict[color$1] = [range];
    }
    
  };
  Belt_Array.forEach(aspects, (function (param) {
          var range = param[1];
          var style = Highlighting__Agda$AgdaModeVscode.Aspect.toStyle(param[0]);
          if (!style) {
            return ;
          }
          var theme = VSCode.ColorTheme.kind(Vscode.window.activeColorTheme);
          if (theme === /* Dark */1) {
            return addFaceToDict(style._1, range);
          } else {
            return addFaceToDict(style._0, range);
          }
        }));
  var backgroundDecorations = Belt_Array.map(Js_dict.entries(backgroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.highlightBackgroundWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  var foregroundDecorations = Belt_Array.map(Js_dict.entries(foregroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.decorateTextWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  return [
          foregroundDecorations.concat(backgroundDecorations),
          srcLocs
        ];
}

function make(param) {
  var match = $$Promise.pending(undefined);
  return {
          tempFilePaths: [],
          infos: new IntervalTree(),
          decorations: [],
          srcLocs: [],
          semanticTokens: match[0],
          resolveSemanticTokens: match[1]
        };
}

function clear(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Belt_Array.forEach(self.tempFilePaths, (function (format) {
          Fs.unlink(format._0, (function (param) {
                  
                }));
          
        }));
  self.tempFilePaths = [];
  self.infos = new IntervalTree();
  return clear(self);
}

function redecorate(self, editor) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addViaPipe(self, infos) {
  return Belt_Array.forEach(infos, (function (info) {
                var alreadyExists = self.infos.intersect_any([
                      info.start,
                      info.end_ - 1 | 0
                    ]);
                if (!alreadyExists) {
                  self.infos.insert([
                        info.start,
                        info.end_ - 1 | 0
                      ], info);
                  return ;
                }
                
              }));
}

function addViaFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 0,
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
  
}

function addViaJSONFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 1,
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
  
}

var readFile = Util.promisify(function (prim0, prim1) {
      Fs.readFile(prim0, prim1);
      
    });

function readAndParse(format) {
  if (format.TAG === /* Emacs */0) {
    var filepath = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var match = Belt_Array.get(Parser$AgdaModeVscode.SExpression.parse(x._0.toString()), 0);
                  var tokens;
                  if (match !== undefined) {
                    if (match.TAG === /* Ok */0) {
                      var xs = match._0;
                      tokens = xs.TAG === /* A */0 ? [] : xs._0;
                    } else {
                      tokens = [];
                    }
                  } else {
                    tokens = [];
                  }
                  var match$1 = Belt_Array.get(tokens, 0);
                  var keepHighlighting = match$1 !== undefined && match$1.TAG === /* A */0 && match$1._0 === "remove" ? false : true;
                  var infos = Belt_Array.keepMap(tokens.slice(1), Highlighting__Agda$AgdaModeVscode.Info.parse);
                  return {
                          _0: keepHighlighting,
                          _1: infos,
                          [Symbol.for("name")]: "Infos"
                        };
                }));
  } else {
    var filepath$1 = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath$1))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var raw = x._0.toString();
                  var json;
                  try {
                    json = JSON.parse(raw);
                  }
                  catch (_e){
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  return Highlighting__Agda$AgdaModeVscode.Infos.decode(json);
                }));
  }
}

function readTempFiles(self) {
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), (function (xs) {
                    return Belt_Array.concatMany(Belt_Array.map(xs, Highlighting__Agda$AgdaModeVscode.Infos.toInfos));
                  })), (function (infos) {
                addViaPipe(self, infos);
                self.tempFilePaths = [];
                
              }));
}

function lookupSrcLoc(self, point) {
  return Belt_Option.map(Caml_option.undefined_to_opt(self.srcLocs.find(function (srcLoc) {
                      return srcLoc.range.contains(point);
                    })), (function (srcLoc) {
                return $$Promise.map(Vscode.workspace.openTextDocument(srcLoc.filepath), (function ($$document) {
                              var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                              var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                              var offset = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, srcLoc.offset - 1 | 0);
                              var position = Editor$AgdaModeVscode.Position.fromOffset($$document, offset);
                              return [[
                                        srcLoc.range,
                                        srcLoc.filepath,
                                        position
                                      ]];
                            }));
              }));
}

function classify(change, token) {
  var removedRange = change.range;
  var regex = /\r\n|\r|\n/;
  var lines = change.text.split(regex);
  var lineDetalOfRemovedRange = removedRange.end.line - removedRange.start.line | 0;
  var lineDelta = (lines.length - 1 | 0) - lineDetalOfRemovedRange | 0;
  var match;
  if (lineDelta > 0) {
    match = [
      lineDelta,
      -removedRange.end.character | 0
    ];
  } else if (lineDelta < 0) {
    var columnDelta = removedRange.end.character - removedRange.start.character | 0;
    match = [
      lineDelta,
      -columnDelta | 0
    ];
  } else {
    var columnDeltaOfRemovedRange = removedRange.end.character - removedRange.start.character | 0;
    var match$1 = Belt_Array.get(lines, lineDelta);
    var columnDelta$1;
    if (match$1 !== undefined) {
      var line = Caml_option.valFromOption(match$1);
      columnDelta$1 = line !== undefined ? line.length - columnDeltaOfRemovedRange | 0 : 0;
    } else {
      columnDelta$1 = 0;
    }
    match = [
      0,
      columnDelta$1
    ];
  }
  var lineDelta$1 = match[0];
  var tokenRange = toVsCodeRange(token.range);
  if (tokenRange.end.isBeforeOrEqual(removedRange.start)) {
    return /* NoOp */0;
  } else if (removedRange.contains(tokenRange) || tokenRange.start.isBefore(removedRange.start) && tokenRange.end.isAfter(removedRange.end)) {
    return /* Remove */1;
  } else if (token.range.line === removedRange.end.line) {
    return {
            TAG: 0,
            _0: lineDelta$1,
            _1: match[1],
            [Symbol.for("name")]: "Move"
          };
  } else {
    return {
            TAG: 1,
            _0: lineDelta$1,
            [Symbol.for("name")]: "MoveLinesOnly"
          };
  }
}

function update(self, $$event) {
  var changes = $$event.contentChanges;
  var applyChange = function (tokens, change) {
    return Belt_Array.concatMany(Belt_Array.map(tokens, (function (token) {
                      var action = classify(change, token);
                      if (typeof action === "number") {
                        if (action === /* NoOp */0) {
                          return [token];
                        } else {
                          return [];
                        }
                      }
                      if (action.TAG !== /* Move */0) {
                        return [{
                                  range: {
                                    line: token.range.line + action._0 | 0,
                                    column: token.range.column
                                  },
                                  type_: token.type_,
                                  modifiers: token.modifiers
                                }];
                      }
                      var columnDelta = action._1;
                      return [{
                                range: {
                                  line: token.range.line + action._0 | 0,
                                  column: [
                                    token.range.column[0] + columnDelta | 0,
                                    token.range.column[1] + columnDelta | 0
                                  ]
                                },
                                type_: token.type_,
                                modifiers: token.modifiers
                              }];
                    })));
  };
  return $$Promise.get(self.semanticTokens, (function (semanticTokensRef) {
                Belt_Array.forEach(changes, (function (change) {
                        semanticTokensRef.contents = applyChange(semanticTokensRef.contents, change);
                        
                      }));
                return Curry._1(self.resolveSemanticTokens, semanticTokensRef);
              }));
}

function get(self) {
  return self.semanticTokens;
}

function apply(self, editor) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  var tokens = Belt_Array.keepMap(Belt_Array.concatMany(Belt_Array.map(self.infos.items, (function (item) {
                  var highlighting = item.value;
                  var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.start);
                  var end_ = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.end_);
                  var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, [
                        start,
                        end_
                      ]);
                  var ranges = splitRange(editor.document, range);
                  return Belt_Array.map(ranges, (function (range) {
                                return [
                                        range,
                                        highlighting.aspects
                                      ];
                              }));
                }))), (function (param) {
          var range = param[0];
          var tokenTypeAccum = [];
          var tokenModifiersAccum = [];
          Belt_Array.forEach(Belt_Array.keepMap(param[1], Highlighting__Agda$AgdaModeVscode.Aspect.toTokenTypeAndModifiers), (function (param) {
                  tokenTypeAccum.push(param[0]);
                  Caml_splice_call.spliceObjApply(tokenModifiersAccum, "push", [param[1]]);
                  
                }));
          return Belt_Option.map(Belt_Array.get(tokenTypeAccum, 0), (function (type_) {
                        return {
                                range: range,
                                type_: type_,
                                modifiers: tokenModifiersAccum
                              };
                      }));
        }));
  if (tokens.length === 0) {
    var match = $$Promise.pending(undefined);
    self.semanticTokens = match[0];
    self.resolveSemanticTokens = match[1];
  } else {
    Curry._1(self.resolveSemanticTokens, {
          contents: tokens
        });
    $$Promise.get(self.semanticTokens, (function (semanticTokensRef) {
            semanticTokensRef.contents = tokens;
            
          }));
  }
  return tokens;
}

function apply$1(self, editor) {
  return $$Promise.map(readTempFiles(self), (function (param) {
                if (Config$AgdaModeVscode.Highlighting.getSemanticHighlighting(undefined)) {
                  apply(self, editor);
                  self.infos = new IntervalTree();
                  return ;
                } else {
                  var match = decorateHighlightings(editor, self.infos);
                  self.infos = new IntervalTree();
                  self.srcLocs = match[1];
                  self.decorations = Belt_Array.concat(self.decorations, match[0]);
                  return ;
                }
              }));
}

var Module_SemanticHighlighting = {
  update: update,
  get: get,
  apply: apply
};

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  addViaPipe: addViaPipe,
  addViaFile: addViaFile,
  addViaJSONFile: addViaJSONFile,
  apply: apply$1,
  clear: clear,
  redecorate: redecorate,
  lookupSrcLoc: lookupSrcLoc,
  SemanticHighlighting: Module_SemanticHighlighting
};

var SemanticHighlighting = Module_SemanticHighlighting;

exports.SemanticToken = SemanticToken;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.addViaPipe = addViaPipe;
exports.addViaFile = addViaFile;
exports.addViaJSONFile = addViaJSONFile;
exports.apply = apply$1;
exports.clear = clear;
exports.redecorate = redecorate;
exports.lookupSrcLoc = lookupSrcLoc;
exports.SemanticHighlighting = SemanticHighlighting;
/* readFile Not a pure module */
