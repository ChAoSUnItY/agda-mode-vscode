// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function decorateHole(editor, param, index) {
  var end_ = param[1];
  var start = param[0];
  var $$document = editor.document;
  var backgroundRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end_));
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var indexRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end_ - 2 | 0));
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function offsetToPoint($$document, utf16indices, eolIndices, offset) {
  var offset$1 = Editor$AgdaModeVscode.Indices.convert(utf16indices, offset);
  var offset$2 = Editor$AgdaModeVscode.Indices.convert(eolIndices, offset$1);
  return $$document.positionAt(offset$2);
}

function offsetToPointSlow($$document, offset) {
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var utf16indices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeUTF16SurrogatePairIndices(text));
  var offset$1 = Editor$AgdaModeVscode.Indices.convert(utf16indices, offset);
  return $$document.positionAt(offset$1);
}

function decorateHighlightings(editor, highlightings) {
  console.time("$$$ Decoration / aspects");
  console.time("$$$ Decoration / aspects / offset conversion");
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var utf16indices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeUTF16SurrogatePairIndices(text));
  var eolIndices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeCRLFIndices(text));
  var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
          var start = offsetToPoint($$document, utf16indices, eolIndices, highlighting.start);
          var end_ = offsetToPoint($$document, utf16indices, eolIndices, highlighting.end_);
          var range = new Vscode.Range(start, end_);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  console.timeEnd("$$$ Decoration / aspects / offset conversion");
  console.time("$$$ Decoration / aspects / scrlocs conversion");
  var srcLocs = Belt_Array.keepMap(highlightings$1, (function (param) {
          var range = param[0];
          return Belt_Option.map(param[2], (function (param) {
                        return {
                                range: range,
                                filepath: param[0],
                                offset: param[1]
                              };
                      }));
        }));
  console.timeEnd("$$$ Decoration / aspects / scrlocs conversion");
  console.time("$$$ Decoration / aspects / dict bundling");
  var backgroundColorDict = {};
  var foregroundColorDict = {};
  var addFaceToDict = function (face, range) {
    if (face.TAG) {
      var color = face._0;
      var ranges = Js_dict.get(foregroundColorDict, color);
      if (ranges !== undefined) {
        ranges.push(range);
      } else {
        foregroundColorDict[color] = [range];
      }
      return ;
    }
    var color$1 = face._0;
    var ranges$1 = Js_dict.get(backgroundColorDict, color$1);
    if (ranges$1 !== undefined) {
      ranges$1.push(range);
    } else {
      backgroundColorDict[color$1] = [range];
    }
    
  };
  console.timeEnd("$$$ Decoration / aspects / dict bundling");
  console.timeEnd("$$$ Decoration / aspects");
  console.time("$$$ Decoration / dicts");
  Belt_Array.forEach(aspects, (function (param) {
          var range = param[1];
          var style = Highlighting$AgdaModeVscode.Aspect.toStyle(param[0]);
          if (!style) {
            return ;
          }
          var theme = VSCode.ColorTheme.kind(Vscode.window.activeColorTheme);
          if (theme === /* Dark */1) {
            return addFaceToDict(style._1, range);
          } else {
            return addFaceToDict(style._0, range);
          }
        }));
  console.timeEnd("$$$ Decoration / dicts");
  console.time("$$$ Decoration / apply");
  var backgroundDecorations = Belt_Array.map(Js_dict.entries(backgroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.highlightBackgroundWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  var foregroundDecorations = Belt_Array.map(Js_dict.entries(foregroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.decorateTextWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  console.timeEnd("$$$ Decoration / apply");
  return [
          foregroundDecorations.concat(backgroundDecorations),
          srcLocs
        ];
}

function lines(doc, range) {
  var startingLine = range.start.line;
  var endingLine = range.end.line;
  var ranges = [];
  for(var i = startingLine; i <= endingLine; ++i){
    var startingPoint = i === startingLine ? range.start : new Vscode.Position(i, 0);
    var endingPoint;
    if (i === endingLine) {
      endingPoint = range.end;
    } else {
      var offset = doc.offsetAt(new Vscode.Position(i + 1 | 0, 0)) - 1 | 0;
      endingPoint = doc.positionAt(offset);
    }
    ranges.push(new Vscode.Range(startingPoint, endingPoint));
  }
  return ranges;
}

function generateSemanticTokens(editor, highlightings, push) {
  console.log("GENERATE");
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var utf16indices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeUTF16SurrogatePairIndices(text));
  var eolIndices = Editor$AgdaModeVscode.Indices.make(Editor$AgdaModeVscode.computeCRLFIndices(text));
  var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
          var start = offsetToPoint($$document, utf16indices, eolIndices, highlighting.start);
          var end_ = offsetToPoint($$document, utf16indices, eolIndices, highlighting.end_);
          var range = new Vscode.Range(start, end_);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  Belt_Array.forEach(aspects, (function (param) {
          var ranges = lines(editor.document, param[1]);
          var match = Highlighting$AgdaModeVscode.Aspect.toTokenTypeAndModifiers(param[0]);
          var tokenType = Curry._1(Highlighting$AgdaModeVscode.Aspect.TokenType.toString, match[0]);
          var tokenModifier = Belt_Option.map(match[1], (function (x) {
                  return Belt_Array.map(x, Highlighting$AgdaModeVscode.Aspect.TokenModifier.toString);
                }));
          return Belt_Array.forEach(ranges, (function (range) {
                        return Curry._3(push, range, tokenType, tokenModifier);
                      }));
        }));
  return $$Promise.resolved(undefined);
}

function make(param) {
  return {
          tempFilePaths: [],
          highlightings: [],
          decorations: [],
          srcLocs: []
        };
}

function removeAppliedDecorations(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Belt_Array.forEach(self.tempFilePaths, (function (filepath) {
          Fs.unlink(filepath, (function (param) {
                  
                }));
          
        }));
  self.tempFilePaths = [];
  self.highlightings = [];
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function refresh(editor, self) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addDirectly(self, highlightings) {
  self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
  
}

function addIndirectly(self, filepath) {
  self.tempFilePaths.push(filepath);
  
}

var readFile = Util.promisify(function (prim, prim$1) {
      Fs.readFile(prim, prim$1);
      
    });

function readAndParse(filepath) {
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (content) {
                if (content.TAG) {
                  return [];
                }
                var expressions = Parser$AgdaModeVscode.SExpression.parse(content._0.toString());
                Belt_Array.keepMap(expressions, (function (error) {
                        if (error.TAG) {
                          return error._0;
                        }
                        
                      }));
                return Belt_Array.concatMany(Belt_Array.keepMap(expressions, (function (param) {
                                  if (param.TAG) {
                                    return ;
                                  }
                                  var xs = param._0;
                                  if (xs.TAG) {
                                    return Highlighting$AgdaModeVscode.parseIndirectHighlightings(xs._0);
                                  } else {
                                    return [];
                                  }
                                })));
              }));
}

function readTempFiles(self) {
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), Belt_Array.concatMany), (function (highlightings) {
                self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
                self.tempFilePaths = [];
                
              }));
}

function applyHighlightings(self, editor) {
  var match = decorateHighlightings(editor, self.highlightings);
  self.highlightings = [];
  self.srcLocs = match[1];
  self.decorations = Belt_Array.concat(self.decorations, match[0]);
  
}

function lookupSrcLoc(self, point) {
  return Belt_Option.map(Caml_option.undefined_to_opt(self.srcLocs.find(function (srcLoc) {
                      return srcLoc.range.contains(point);
                    })), (function (srcLoc) {
                return $$Promise.map(Vscode.workspace.openTextDocument(srcLoc.filepath), (function ($$document) {
                              var point = offsetToPointSlow($$document, srcLoc.offset - 1 | 0);
                              return [[
                                        srcLoc.range,
                                        srcLoc.filepath,
                                        point
                                      ]];
                            }));
              }));
}

var VSRange;

exports.VSRange = VSRange;
exports.decorateHole = decorateHole;
exports.offsetToPoint = offsetToPoint;
exports.offsetToPointSlow = offsetToPointSlow;
exports.decorateHighlightings = decorateHighlightings;
exports.lines = lines;
exports.generateSemanticTokens = generateSemanticTokens;
exports.make = make;
exports.removeAppliedDecorations = removeAppliedDecorations;
exports.destroy = destroy;
exports.refresh = refresh;
exports.addDirectly = addDirectly;
exports.addIndirectly = addIndirectly;
exports.readFile = readFile;
exports.readAndParse = readAndParse;
exports.readTempFiles = readTempFiles;
exports.applyHighlightings = applyHighlightings;
exports.lookupSrcLoc = lookupSrcLoc;
/* readFile Not a pure module */
