// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var SourceFile$AgdaModeVscode = require("./Parser/SourceFile.bs.js");

function generateDiffs($$document, indices) {
  var filePath = Parser$AgdaModeVscode.filepath($$document.fileName);
  var source = Editor$AgdaModeVscode.$$Text.getAll($$document);
  return SourceFile$AgdaModeVscode.parse(indices, filePath, source);
}

function makeMany(editor, indices) {
  var $$document = editor.document;
  var diffs = generateDiffs($$document, indices);
  var delta = {
    contents: 0
  };
  var replacements = Belt_Array.map(Belt_Array.keep(diffs, (function (diff) {
              return diff.changed;
            })), (function (diff) {
          var range = new Vscode.Range($$document.positionAt(diff.originalRange[0] - delta.contents | 0), $$document.positionAt(diff.originalRange[1] - delta.contents | 0));
          delta.contents = (delta.contents + (diff.modifiedRange[1] - diff.modifiedRange[0] | 0) | 0) - (diff.originalRange[1] - diff.originalRange[0] | 0) | 0;
          var text = diff.content;
          return [
                  range,
                  text
                ];
        }));
  return $$Promise.map(Editor$AgdaModeVscode.$$Text.batchReplace($$document, replacements), (function (param) {
                return Belt_Array.map(diffs, (function (diff) {
                              var match = Decoration$AgdaModeVscode.decorateHole(editor, diff.modifiedRange, diff.index);
                              return {
                                      index: diff.index,
                                      range: diff.modifiedRange,
                                      decorationBackground: match[0],
                                      decorationIndex: match[1]
                                    };
                            }));
              }));
}

function updateRanges(goals, $$document) {
  var indices = Belt_Array.map(goals, (function (goal) {
          return goal.index;
        }));
  var diffs = generateDiffs($$document, indices);
  return Belt_Array.forEachWithIndex(diffs, (function (i, diff) {
                var goal = Belt_Array.get(goals, i);
                if (goal !== undefined) {
                  goal.range = diff.modifiedRange;
                  return ;
                }
                
              }));
}

function getInnerRange(self, $$document) {
  return new Vscode.Range($$document.positionAt(self.range[0] + 2 | 0), $$document.positionAt(self.range[1] - 2 | 0));
}

function getOuterRange(self, $$document) {
  return new Vscode.Range($$document.positionAt(self.range[0]), $$document.positionAt(self.range[1]));
}

function getContent(self, $$document) {
  var innerRange = getInnerRange(self, $$document);
  return Parser$AgdaModeVscode.userInput(Editor$AgdaModeVscode.$$Text.get($$document, innerRange));
}

function setContent(self, $$document, text) {
  var innerRange = getInnerRange(self, $$document);
  return Editor$AgdaModeVscode.$$Text.replace($$document, innerRange, " " + (text + " "));
}

function setCursor(self, editor) {
  var match = self.range;
  var point = editor.document.positionAt(match[0] + 3 | 0);
  editor.selection = new Vscode.Selection(point, point);
  
}

function buildHaskellRange($$document, self, old, filepath) {
  var match = self.range;
  var end_ = match[1];
  var start = match[0];
  var startPoint = $$document.positionAt(start);
  var endPoint = $$document.positionAt(end_);
  var startIndex = String(start + 3 | 0);
  var startRow = String(startPoint.line + 1 | 0);
  var startColumn = String(startPoint.character + 3 | 0);
  var startPart = "" + startIndex + " " + startRow + " " + startColumn;
  var endIndex$prime = String(end_ - 3 | 0);
  var endRow = String(endPoint.line + 1 | 0);
  var endColumn = String(endPoint.character - 1 | 0);
  var endPart = "" + endIndex$prime + " " + endRow + " " + endColumn;
  if (old) {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + filepath + "\")) " + startPart + ") (Pn (Just (mkAbsolute \"" + filepath + "\")) " + endPart + ")])";
  } else {
    return "(intervalsToRange (Just (mkAbsolute \"" + filepath + "\")) [Interval (Pn () " + startPart + ") (Pn () " + endPart + ")])";
  }
}

function refreshDecoration(self, editor) {
  var range = getOuterRange(self, editor.document);
  Editor$AgdaModeVscode.Decoration.decorate(editor, self.decorationBackground, [range]);
  var range$1 = new Vscode.Range(range.start, range.end.translate(0, -2));
  return Editor$AgdaModeVscode.Decoration.decorate(editor, self.decorationIndex, [range$1]);
}

function destroy(self) {
  Editor$AgdaModeVscode.Decoration.destroy(self.decorationBackground);
  return Editor$AgdaModeVscode.Decoration.destroy(self.decorationIndex);
}

var VSRange;

exports.VSRange = VSRange;
exports.generateDiffs = generateDiffs;
exports.makeMany = makeMany;
exports.updateRanges = updateRanges;
exports.getInnerRange = getInnerRange;
exports.getOuterRange = getOuterRange;
exports.getContent = getContent;
exports.setContent = setContent;
exports.setCursor = setCursor;
exports.buildHaskellRange = buildHaskellRange;
exports.refreshDecoration = refreshDecoration;
exports.destroy = destroy;
/* vscode Not a pure module */
