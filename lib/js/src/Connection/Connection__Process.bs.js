// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Child_process = require("child_process");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");

function toString(x) {
  if (typeof x === "number") {
    return [
            "Process hanging",
            "The program has not been responding for more than 1 sec"
          ];
  }
  switch (x.TAG | 0) {
    case /* PathMalformed */0 :
        return [
                "Path malformed",
                x._0
              ];
    case /* NotFound */1 :
        return [
                "Command not found",
                Util$AgdaModeVscode.JsError.toString(x._0)
              ];
    case /* ShellError */2 :
        return [
                "Error from the shell",
                Util$AgdaModeVscode.JsError.toString(x._0)
              ];
    case /* ProcessError */3 :
        return [
                "Error from the stderr",
                x._0
              ];
    case /* WrongProcess */4 :
        return [
                "Wrong process",
                x._0
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function run(path, validator) {
  var parseError = function (error) {
    return Belt_Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                  var message = Belt_Option.getWithDefault(err.message, "");
                  if (/No such file or directory/.test(message) || /command not found/.test(message)) {
                    return {
                            TAG: 1,
                            _0: err,
                            [Symbol.for("name")]: "NotFound"
                          };
                  } else {
                    return {
                            TAG: 2,
                            _0: err,
                            [Symbol.for("name")]: "ShellError"
                          };
                  }
                }));
  };
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  if (path === "") {
    Curry._1(resolve, {
          TAG: 1,
          _0: {
            TAG: 0,
            _0: "the path must not be empty",
            [Symbol.for("name")]: "PathMalformed"
          },
          [Symbol.for("name")]: "Error"
        });
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: /* ProcessHanging */0,
                      [Symbol.for("name")]: "Error"
                    });
        }), 20000);
  Child_process.exec(path, (function (error, stdout, stderr) {
          clearTimeout(hangTimeout);
          Belt_Option.forEach(parseError(error), (function (err) {
                  return Curry._1(resolve, {
                              TAG: 1,
                              _0: err,
                              [Symbol.for("name")]: "Error"
                            });
                }));
          var stderr$1 = stderr.toString();
          if (stderr$1 !== "") {
            Curry._1(resolve, {
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: stderr$1,
                    [Symbol.for("name")]: "ProcessError"
                  },
                  [Symbol.for("name")]: "Error"
                });
          }
          var stdout$1 = stdout.toString();
          var err = Curry._1(validator, stdout$1);
          if (err.TAG === /* Ok */0) {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: err._0,
                        [Symbol.for("name")]: "Ok"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: {
                          TAG: 4,
                          _0: err._0,
                          [Symbol.for("name")]: "WrongProcess"
                        },
                        [Symbol.for("name")]: "Error"
                      });
          }
        }));
  return match[0];
}

var Validation = {
  $$Error: $$Error,
  run: run
};

exports.Validation = Validation;
/* Promise Not a pure module */
