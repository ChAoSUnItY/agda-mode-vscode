// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function fromOffset($$document, offset) {
  return $$document.positionAt(offset);
}

function toOffset($$document, position) {
  return $$document.offsetAt(position);
}

var Position = {
  fromOffset: fromOffset,
  toOffset: toOffset
};

function fromInterval($$document, interval) {
  return new Vscode.Range($$document.positionAt(interval[0]), $$document.positionAt(interval[1]));
}

function toInterval($$document, range) {
  return [
          $$document.offsetAt(range.start),
          $$document.offsetAt(range.end)
        ];
}

var $$Range = {
  fromInterval: fromInterval,
  toInterval: toInterval
};

function decorate(editor, decoration, ranges) {
  editor.setDecorations(decoration, ranges);
  
}

function highlightBackgroundPrim(editor, backgroundColor, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    backgroundColor: backgroundColor,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function highlightBackground(editor, style, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), ranges);
}

function highlightBackgroundWithColor(editor, color, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.string(color), ranges);
}

function decorateTextPrim(editor, color, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    color: color,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function decorateText(editor, style, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), ranges);
}

function decorateTextWithColor(editor, color, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.string(color), ranges);
}

function overlayTextPrim(editor, color, text, range) {
  var after = {
    color: color,
    contentText: text
  };
  var options = {
    after: after
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function overlayText(editor, style, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), text, range);
}

function overlayTextWithColor(editor, color, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.string(color), text, range);
}

function underlineText(editor, range) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedOpen */3);
  var options = {
    rangeBehavior: rangeBehavior,
    textDecoration: "underline dotted"
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function destroy(prim) {
  prim.dispose();
  
}

var Decoration = {
  decorate: decorate,
  highlightBackgroundPrim: highlightBackgroundPrim,
  highlightBackground: highlightBackground,
  highlightBackgroundWithColor: highlightBackgroundWithColor,
  decorateTextPrim: decorateTextPrim,
  decorateText: decorateText,
  decorateTextWithColor: decorateTextWithColor,
  overlayTextPrim: overlayTextPrim,
  overlayText: overlayText,
  overlayTextWithColor: overlayTextWithColor,
  underlineText: underlineText,
  destroy: destroy
};

function set(editor, point) {
  var selection = new Vscode.Selection(point, point);
  editor.selection = selection;
  
}

function setMany(editor, points) {
  var selections = Belt_Array.map(points, (function (point) {
          return new Vscode.Selection(point, point);
        }));
  editor.selections = selections;
  
}

function get(editor) {
  return editor.selection.active;
}

function getMany(editor) {
  return Belt_Array.map(editor.selections, (function (prim) {
                return prim.active;
              }));
}

var Cursor = {
  set: set,
  setMany: setMany,
  get: get,
  getMany: getMany
};

function set$1(editor, range) {
  var selection = new Vscode.Selection(range.start, range.end);
  editor.selection = selection;
  
}

function setMany$1(editor, ranges) {
  var selections = Belt_Array.map(ranges, (function (range) {
          return new Vscode.Selection(range.start, range.end);
        }));
  editor.selections = selections;
  
}

function get$1(editor) {
  var selection = editor.selection;
  return new Vscode.Range(selection.start, selection.end);
}

function getMany$1(editor) {
  return Belt_Array.map(editor.selections, (function (selection) {
                return new Vscode.Range(selection.start, selection.end);
              }));
}

var $$Selection = {
  set: set$1,
  setMany: setMany$1,
  get: get$1,
  getMany: getMany$1
};

function get$2($$document, range) {
  return $$document.getText(Caml_option.some(range));
}

function getAll($$document) {
  return $$document.getText(undefined);
}

function replace($$document, range, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.replace($$document.uri, range, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchReplace($$document, replacements) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  Belt_Array.forEach(replacements, (function (param) {
          workspaceEdit.replace($$document.uri, param[0], param[1], undefined);
          
        }));
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchReplace$prime(editor, replacements) {
  return editor.edit((function (editBuilder) {
                return Belt_Array.forEach(replacements, (function (param) {
                              editBuilder.replace(param[0], param[1]);
                              
                            }));
              }), undefined);
}

function insert($$document, point, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.insert($$document.uri, point, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchInsert($$document, points, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  var textEdits = Belt_Array.map(points, (function (point) {
          return Vscode.TextEdit.insert(point, text);
        }));
  workspaceEdit.set($$document.uri, textEdits);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchInsert$prime(editor, points, text) {
  return editor.edit((function (editBuilder) {
                return Belt_Array.forEach(points, (function (point) {
                              editBuilder.insert(point, text);
                              
                            }));
              }), undefined);
}

function $$delete($$document, range) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.delete($$document.uri, range, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

var $$Text = {
  get: get$2,
  getAll: getAll,
  replace: replace,
  batchReplace: batchReplace,
  batchReplace$prime: batchReplace$prime,
  insert: insert,
  batchInsert: batchInsert,
  batchInsert$prime: batchInsert$prime,
  $$delete: $$delete
};

var characterWidth = (function (string) {return [...string].length});

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = text.charCodeAt(i) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = text.charCodeAt(i + 1 | 0) | 0;
      if (nextCharCode >= 56320 && charCode <= 57343) {
        surrogatePairs.push(i);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function computeCRLFIndices(text) {
  var regexp = /\r\n/g;
  var matchAll = (function (regexp, string) {
      let match;
      let result = [];
      while ((match = regexp.exec(string)) !== null) {
        result.push(match.index);
      }
      return result;
    });
  return matchAll(regexp, text);
}

function make(indicesUTF16) {
  var indicesUTF8 = Belt_Array.mapWithIndex(indicesUTF16, (function (i, x) {
          return x - i | 0;
        }));
  var intervals = Belt_Array.mapWithIndex(indicesUTF8, (function (i, rightEndpoint) {
          var x = Belt_Array.get(indicesUTF8, i - 1 | 0);
          var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
          return [
                  leftEndpoint,
                  rightEndpoint
                ];
        }));
  return {
          intervals: intervals,
          cursor: 0
        };
}

function convert(self, index) {
  while(true) {
    var match = Belt_Array.get(self.intervals, self.cursor);
    if (match === undefined) {
      return index + self.cursor | 0;
    }
    if (index < match[0]) {
      self.cursor = 0;
      continue ;
    }
    if (index <= match[1]) {
      return index + self.cursor | 0;
    }
    self.cursor = self.cursor + 1 | 0;
    continue ;
  };
}

function expose(self) {
  return [
          self.intervals,
          self.cursor
        ];
}

var Indices = {
  make: make,
  convert: convert,
  expose: expose
};

function toUTF8Offset($$document, offset) {
  var range = new Vscode.Range(new Vscode.Position(0, 0), $$document.positionAt(offset));
  return characterWidth($$document.getText(Caml_option.some(range)));
}

function focus($$document) {
  Vscode.window.showTextDocument($$document, /* Beside */1, undefined);
  
}

function reveal(editor, range) {
  return VSCode.TextEditor.revealRange(editor, range, /* InCenterIfOutsideViewport */3);
}

function registerProvider(definitionProvider, hoverProvider) {
  var documentSelector = [VSCode.StringOr.string("agda")];
  var definitionProvider$1 = {
    provideDefinition: (function (textDocument, point, param) {
        return VSCode.ProviderResult.map(Curry._2(definitionProvider, textDocument.fileName, point), (function (pairs) {
                      return VSCode.LocationLinkOrLocation.locationLinks(Belt_Array.map(pairs, (function (param) {
                                        var targetPos = param[2];
                                        return {
                                                originSelectionRange: Caml_option.some(param[0]),
                                                targetRange: new Vscode.Range(targetPos, targetPos),
                                                targetSelectionRange: undefined,
                                                targetUri: Vscode.Uri.file(param[1])
                                              };
                                      })));
                    }));
      })
  };
  var hoverProvider$1 = {
    provideHover: (function (textDocument, point, param) {
        return VSCode.ProviderResult.map(Curry._2(hoverProvider, textDocument.fileName, point), (function (param) {
                      var markdownStrings = Belt_Array.map(param[0], (function (string) {
                              return new Vscode.MarkdownString(string, true);
                            }));
                      return new Vscode.Hover(markdownStrings, param[1]);
                    }));
      })
  };
  return [
          Vscode.languages.registerDefinitionProvider(documentSelector, definitionProvider$1),
          Vscode.languages.registerHoverProvider(documentSelector, hoverProvider$1)
        ];
}

var SemanticsTokens = {};

var SemanticTokensLegend = {};

var SemanticTokensBuilder = {};

var DocumentSemanticTokensProvider = {};

var Languages = {};

var Mock = {
  SemanticsTokens: SemanticsTokens,
  SemanticTokensLegend: SemanticTokensLegend,
  SemanticTokensBuilder: SemanticTokensBuilder,
  DocumentSemanticTokensProvider: DocumentSemanticTokensProvider,
  Languages: Languages
};

function registerTestingProvider(prodider, param) {
  var documentSelector = [VSCode.StringOr.string("agda")];
  var semanticTokensLegend = new Vscode.SemanticTokensLegend(param[0], param[1]);
  var documentSemanticTokensProvider = {
    provideDocumentSemanticTokens: (function (textDocument, param) {
        var builder = new Vscode.SemanticTokensBuilder(semanticTokensLegend);
        var pushLegend = function (param, param$1, param$2) {
          builder.push(param, param$1, param$2);
          
        };
        return VSCode.ProviderResult.map(Curry._2(prodider, textDocument.fileName, pushLegend), (function (param) {
                      return builder.build();
                    }));
      })
  };
  return [Vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentSemanticTokensProvider, semanticTokensLegend)];
}

var Provider = {
  registerProvider: registerProvider,
  Mock: Mock,
  registerTestingProvider: registerTestingProvider
};

var VSRange;

exports.VSRange = VSRange;
exports.Position = Position;
exports.$$Range = $$Range;
exports.Decoration = Decoration;
exports.Cursor = Cursor;
exports.$$Selection = $$Selection;
exports.$$Text = $$Text;
exports.characterWidth = characterWidth;
exports.computeUTF16SurrogatePairIndices = computeUTF16SurrogatePairIndices;
exports.computeCRLFIndices = computeCRLFIndices;
exports.Indices = Indices;
exports.toUTF8Offset = toUTF8Offset;
exports.focus = focus;
exports.reveal = reveal;
exports.Provider = Provider;
/* VSCode Not a pure module */
