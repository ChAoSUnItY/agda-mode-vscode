// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Untildify = require("untildify");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Parser$AgdaModeVscode = require("../Parser.bs.js");
var Process$AgdaModeVscode = require("../Process.bs.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Connection__Scheduler$AgdaModeVscode = require("./Connection__Scheduler.bs.js");

function destroy(self) {
  Chan$AgdaModeVscode.destroy(self.chan);
  self.encountedFirstPrompt = false;
  return Process$AgdaModeVscode.destroy(self.process);
}

function wire(self) {
  var toResponse = Curry._1(Parser$AgdaModeVscode.Incr.Gen.flatMap, (function (x) {
          if (x.TAG !== /* Ok */0) {
            return {
                    _0: {
                      TAG: 1,
                      _0: x._0,
                      [Symbol.for("name")]: "Error"
                    },
                    [Symbol.for("name")]: "Yield"
                  };
          }
          var tokens = x._0;
          if (tokens.TAG === /* A */0 && tokens._0 === "Agda2>") {
            return /* Stop */0;
          } else {
            return {
                    _0: Response$AgdaModeVscode.Prioritized.parse(tokens),
                    [Symbol.for("name")]: "Yield"
                  };
          }
        }));
  var mapError = function (x) {
    return Curry._2(Parser$AgdaModeVscode.Incr.Gen.map, (function (x) {
                  if (x.TAG === /* Ok */0) {
                    return {
                            TAG: 0,
                            _0: x._0,
                            [Symbol.for("name")]: "Ok"
                          };
                  }
                  var match = x._0;
                  return {
                          TAG: 1,
                          _0: {
                            TAG: 0,
                            _0: match[0],
                            _1: match[1],
                            [Symbol.for("name")]: "SExpression"
                          },
                          [Symbol.for("name")]: "Error"
                        };
                }), x);
  };
  var pipeline = Parser$AgdaModeVscode.SExpression.makeIncr(function (x) {
        var res = Curry._1(toResponse, mapError(x));
        if (res) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: {
                        _0: res._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else if (self.encountedFirstPrompt) {
          return Chan$AgdaModeVscode.emit(self.chan, {
                      TAG: 0,
                      _0: /* Stop */0,
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          self.encountedFirstPrompt = true;
          return ;
        }
      });
  Process$AgdaModeVscode.onOutput(self.process, (function (x) {
          switch (x.TAG | 0) {
            case /* Stdout */0 :
                return Belt_Array.forEach(Parser$AgdaModeVscode.split(x._0), (function (param) {
                              return Parser$AgdaModeVscode.Incr.feed(pipeline, param);
                            }));
            case /* Stderr */1 :
                return ;
            case /* Error */2 :
                return Chan$AgdaModeVscode.emit(self.chan, {
                            TAG: 1,
                            _0: {
                              TAG: 2,
                              _0: x._0,
                              [Symbol.for("name")]: "Process"
                            },
                            [Symbol.for("name")]: "Error"
                          });
            
          }
        }));
  
}

function make(param) {
  var getPath = function (param) {
    var storedPath = Config$AgdaModeVscode.getAgdaPath(undefined);
    if (!(storedPath === "" || storedPath === ".")) {
      return $$Promise.resolved({
                  TAG: 0,
                  _0: storedPath,
                  [Symbol.for("name")]: "Ok"
                });
    }
    var agdaVersion = Config$AgdaModeVscode.getAgdaVersion(undefined);
    return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.PathSearch.run(agdaVersion), (function (prim) {
                      return prim.trim();
                    })), (function (e) {
                  return {
                          TAG: 0,
                          _0: e,
                          [Symbol.for("name")]: "PathSearch"
                        };
                }));
  };
  var setPath = function (metadata) {
    return $$Promise.map(Config$AgdaModeVscode.setAgdaPath(metadata.path), (function (param) {
                  return {
                          TAG: 0,
                          _0: metadata,
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  };
  var args = ["--interaction"];
  return $$Promise.tapOk($$Promise.mapOk($$Promise.flatMapOk($$Promise.flatMapOk(getPath(undefined), (function (path) {
                            var validator = function (output) {
                              var match_ = output.match(/Agda version (.*)/);
                              if (match_ === null) {
                                return {
                                        TAG: 1,
                                        _0: "Cannot read Agda version",
                                        [Symbol.for("name")]: "Error"
                                      };
                              }
                              var version = Belt_Array.get(match_, 1);
                              if (version !== undefined) {
                                return {
                                        TAG: 0,
                                        _0: version,
                                        [Symbol.for("name")]: "Ok"
                                      };
                              } else {
                                return {
                                        TAG: 1,
                                        _0: "Cannot read Agda version",
                                        [Symbol.for("name")]: "Error"
                                      };
                              }
                            };
                            var path$1 = Untildify(path);
                            return $$Promise.mapError($$Promise.mapOk(Process$AgdaModeVscode.Validation.run("\"" + (path$1 + "\" -V"), validator), (function (version) {
                                              return {
                                                      path: path$1,
                                                      args: args,
                                                      version: version
                                                    };
                                            })), (function (e) {
                                          return {
                                                  TAG: 1,
                                                  _0: e,
                                                  [Symbol.for("name")]: "Validation"
                                                };
                                        }));
                          })), setPath), (function (metadata) {
                    return {
                            metadata: metadata,
                            process: Process$AgdaModeVscode.make(metadata.path, metadata.args),
                            chan: Chan$AgdaModeVscode.make(undefined),
                            encountedFirstPrompt: false
                          };
                  })), wire);
}

function sendRequestPrim(conn, encoded) {
  Process$AgdaModeVscode.send(conn.process, encoded);
  
}

function onResponse(conn, callback) {
  var scheduler = Connection__Scheduler$AgdaModeVscode.make(undefined);
  var match = $$Promise.pending(undefined);
  var stopListener = match[1];
  var listener = function (x) {
    if (x.TAG === /* Ok */0) {
      var match = x._0;
      if (match) {
        var error = match._0;
        if (error.TAG === /* Ok */0) {
          var response = error._0;
          if (response.TAG === /* NonLast */0) {
            return Connection__Scheduler$AgdaModeVscode.runNonLast(scheduler, callback, response._0);
          } else {
            return Connection__Scheduler$AgdaModeVscode.addLast(scheduler, response._0, response._1);
          }
        }
        Curry._1(callback, {
              TAG: 1,
              _0: {
                TAG: 4,
                _0: error._0,
                [Symbol.for("name")]: "ResponseParseError"
              },
              [Symbol.for("name")]: "Error"
            });
        return ;
      }
      Curry._1(stopListener, undefined);
      return Connection__Scheduler$AgdaModeVscode.runLast(scheduler, callback);
    }
    Curry._1(callback, {
          TAG: 1,
          _0: x._0,
          [Symbol.for("name")]: "Error"
        });
    
  };
  var listenerHandle = {
    contents: undefined
  };
  listenerHandle.contents = Chan$AgdaModeVscode.on(conn.chan, listener);
  return $$Promise.tap(match[0], (function (param) {
                return Belt_Option.forEach(listenerHandle.contents, (function (destroyListener) {
                              return Curry._1(destroyListener, undefined);
                            }));
              }));
}

function sendRequest(conn, request, handler) {
  var promise = onResponse(conn, handler);
  sendRequestPrim(conn, request);
  return $$Promise.map(promise, (function (param) {
                return {
                        TAG: 0,
                        _0: undefined,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function getVersion(conn) {
  return conn.metadata.version;
}

var Module = {
  make: make,
  destroy: destroy,
  sendRequest: sendRequest,
  getVersion: getVersion
};

var $$Error;

var Scheduler;

exports.$$Error = $$Error;
exports.Scheduler = Scheduler;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.sendRequest = sendRequest;
exports.getVersion = getVersion;
/* Promise Not a pure module */
