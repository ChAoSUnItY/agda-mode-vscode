// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var make = function (param) {
    return {
            queues: /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  /* Command */2,
                  /* [] */0
                ],
                /* [] */0
              ]),
            status: /* Idle */1
          };
  };
  var getNextTask = function (self) {
    var match = self.queues;
    if (!match) {
      return ;
    }
    var match$1 = match[0];
    var match$2 = match$1[1];
    if (match$2) {
      return /* tuple */[
              match$2[0],
              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* tuple */[
                    match$1[0],
                    match$2[1]
                  ],
                  match[1]
                ])
            ];
    }
    
  };
  var spawnQueue = function (self, source) {
    self.queues = /* :: */Caml_chrome_debugger.simpleVariant("::", [
        /* tuple */[
          source,
          /* [] */0
        ],
        self.queues
      ]);
    
  };
  var removeQueue = function (self, target) {
    var lastQueueMatched = {
      contents: undefined
    };
    self.queues = Belt_List.keepMap(self.queues, (function (param) {
            var queue = param[1];
            var source = param[0];
            if (source === target && Belt_Option.isNone(lastQueueMatched.contents)) {
              lastQueueMatched.contents = queue;
              return ;
            }
            var queue$prime = lastQueueMatched.contents;
            if (queue$prime !== undefined) {
              lastQueueMatched.contents = undefined;
              return /* tuple */[
                      source,
                      Belt_List.concat(queue$prime, queue)
                    ];
            } else {
              return /* tuple */[
                      source,
                      queue
                    ];
            }
          }));
    
  };
  var addTasksToQueue = function (self, target, tasks) {
    var concatenated = {
      contents: false
    };
    self.queues = Belt_List.keepMap(self.queues, (function (param) {
            var queue = param[1];
            var source = param[0];
            if (source === target && !concatenated.contents) {
              concatenated.contents = true;
              return /* tuple */[
                      source,
                      Belt_List.concat(queue, tasks)
                    ];
            } else {
              return /* tuple */[
                      source,
                      queue
                    ];
            }
          }));
    
  };
  var countSource = function (self, target) {
    return Belt_List.reduce(self.queues, 0, (function (accum, param) {
                  if (param[0] === target) {
                    return accum + 1 | 0;
                  } else {
                    return accum;
                  }
                }));
  };
  var logQueues = function (self) {
    var queues = Belt_List.toArray(Belt_List.map(self.queues, (function (param) {
                switch (param[0]) {
                  case /* Agda */0 :
                      return "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* View */1 :
                      return "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Command */2 :
                      return "Comm " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  case /* Misc */3 :
                      return "Misc " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], Task.toString));
                  
                }
              })));
    console.log("\n===============================\n" + queues.join("\n"));
    
  };
  var addMiscTasks = function (self, tasks) {
    spawnQueue(self, /* Misc */3);
    addTasksToQueue(self, /* Misc */3, tasks);
    removeQueue(self, /* Misc */3);
    return $$Promise.resolved(true);
  };
  var sendAgdaRequest = function (runTasks, state, req) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        console.log(">>> " + Response$AgdaModeVscode.toString(response));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response));
      }
      console.log(">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap(Curry._2(Task.State.sendRequestToAgda, state, req), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var executeTask = function (self, state, task) {
    console.log("Task: " + Curry._1(Task.toString, task));
    if (typeof task === "number") {
      return $$Promise.map(Curry._1(Task.State.destroy, state), (function (param) {
                    return false;
                  }));
    }
    switch (task.tag | 0) {
      case /* DispatchCommand */0 :
          var tasks = Curry._1(CommandHandler.handle, task[0]);
          addTasksToQueue(self, /* Command */2, tasks);
          return $$Promise.resolved(true);
      case /* SendRequest */1 :
          if (countSource(self, /* Agda */0) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawnQueue(self, /* Agda */0);
            $$Promise.get(sendAgdaRequest((function (tasks) {
                        logQueues(self);
                        addTasksToQueue(self, /* Agda */0, tasks);
                        return kickStart(self, state);
                      }), state, task[0]), (function (param) {
                    logQueues(self);
                    return removeQueue(self, /* Agda */0);
                  }));
            return $$Promise.resolved(true);
          }
      case /* ViewReq */2 :
          var callback = task[1];
          if (countSource(self, /* View */1) > 0) {
            return $$Promise.resolved(false);
          } else {
            spawnQueue(self, /* View */1);
            return $$Promise.map($$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                              return addTasksToQueue(self, /* View */1, Curry._1(callback, response));
                            })), (function (param) {
                          removeQueue(self, /* View */1);
                          return true;
                        }));
          }
      case /* ViewEvent */3 :
          var tasks$1 = task[0] ? /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* Terminate */0,
                /* [] */0
              ]) : /* [] */0;
          return addMiscTasks(self, tasks$1);
      case /* Error */4 :
          var tasks$2 = Curry._1(ErrorHandler.handle, task[0]);
          return addMiscTasks(self, tasks$2);
      case /* Goal */5 :
          var tasks$3 = Curry._1(GoalHandler.handle, task[0]);
          return addMiscTasks(self, tasks$3);
      case /* WithState */6 :
          spawnQueue(self, /* Misc */3);
          return $$Promise.map($$Promise.tap($$Promise.map(Curry._1(task[0], state), (function (tasks) {
                                return addTasksToQueue(self, /* Misc */3, tasks);
                              })), (function (param) {
                            return removeQueue(self, /* Misc */3);
                          })), (function (param) {
                        return true;
                      }));
      case /* Debug */7 :
          console.log("DEBUG " + task[0]);
          return $$Promise.resolved(true);
      
    }
  };
  var kickStart = function (self, state) {
    logQueues(self);
    var match = self.status;
    if (!match) {
      return ;
    }
    var match$1 = getNextTask(self);
    if (match$1 !== undefined) {
      self.status = /* Busy */0;
      self.queues = match$1[1];
      return $$Promise.get(executeTask(self, state, match$1[0]), (function (keepRunning) {
                    self.status = /* Idle */1;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    
  };
  var dispatchCommand = function (self, state, command) {
    var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
    var tasks = Curry._1(CommandHandler.handle, command);
    addTasksToQueue(self, /* Command */2, tasks);
    return kickStart(self, state);
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          make: make,
          getNextTask: getNextTask,
          spawnQueue: spawnQueue,
          removeQueue: removeQueue,
          addTasksToQueue: addTasksToQueue,
          countSource: countSource,
          logQueues: logQueues,
          addMiscTasks: addMiscTasks,
          sendAgdaRequest: sendAgdaRequest,
          executeTask: executeTask,
          kickStart: kickStart,
          dispatchCommand: dispatchCommand,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
