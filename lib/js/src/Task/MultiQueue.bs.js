// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(param) {
  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
            /* tuple */[
              /* Command */2,
              /* [] */0
            ],
            /* [] */0
          ]);
}

function spawn(queues, source) {
  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
            /* tuple */[
              source,
              /* [] */0
            ],
            queues
          ]);
}

function remove(queues, target) {
  var lastQueueMatched = {
    contents: undefined
  };
  return Belt_List.keepMap(queues, (function (param) {
                var queue = param[1];
                var source = param[0];
                if (Caml_obj.caml_equal(source, target) && Belt_Option.isNone(lastQueueMatched.contents)) {
                  lastQueueMatched.contents = queue;
                  return ;
                }
                var queue$prime = lastQueueMatched.contents;
                if (queue$prime !== undefined) {
                  lastQueueMatched.contents = undefined;
                  return /* tuple */[
                          source,
                          Belt_List.concat(queue$prime, queue)
                        ];
                } else {
                  return /* tuple */[
                          source,
                          queue
                        ];
                }
              }));
}

function addTasks(queues, target, tasks) {
  var concatenated = {
    contents: false
  };
  return Belt_List.keepMap(queues, (function (param) {
                var queue = param[1];
                var source = param[0];
                if (Caml_obj.caml_equal(source, target) && !concatenated.contents) {
                  concatenated.contents = true;
                  return /* tuple */[
                          source,
                          Belt_List.concat(queue, tasks)
                        ];
                } else {
                  return /* tuple */[
                          source,
                          queue
                        ];
                }
              }));
}

function countBySource(queues, target) {
  return Belt_List.reduce(queues, 0, (function (accum, param) {
                if (Caml_obj.caml_equal(param[0], target)) {
                  return accum + 1 | 0;
                } else {
                  return accum;
                }
              }));
}

function toString(taskToString, queues) {
  var strings = Belt_List.toArray(Belt_List.map(queues, (function (param) {
              switch (param[0]) {
                case /* Agda */0 :
                    return "Agda " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], taskToString));
                case /* View */1 :
                    return "View " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], taskToString));
                case /* Command */2 :
                    return "Comm " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], taskToString));
                case /* Misc */3 :
                    return "Misc " + Util$AgdaModeVscode.Pretty.list(Belt_List.map(param[1], taskToString));
                
              }
            })));
  return strings.join("\n");
}

function getNextTask(blocking, queues) {
  if (!queues) {
    return ;
  }
  var match = queues[0];
  var match$1 = match[1];
  var _source = match[0];
  if (match$1) {
    return /* tuple */[
            match$1[0],
            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                /* tuple */[
                  _source,
                  match$1[1]
                ],
                queues[1]
              ])
          ];
  } else if (blocking) {
    return ;
  } else {
    return Belt_Option.map(getNextTask(blocking, queues[1]), (function (param) {
                  return /* tuple */[
                          param[0],
                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                              /* tuple */[
                                _source,
                                /* [] */0
                              ],
                              param[1]
                            ])
                        ];
                }));
  }
}

exports.make = make;
exports.spawn = spawn;
exports.remove = remove;
exports.addTasks = addTasks;
exports.countBySource = countBySource;
exports.toString = toString;
exports.getNextTask = getNextTask;
/* Util-AgdaModeVscode Not a pure module */
