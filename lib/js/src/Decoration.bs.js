// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Highlighting__Agda$AgdaModeVscode = require("./Highlighting/Highlighting__Agda.bs.js");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function fromInfostoDecorations(infosWithRanges, editor) {
  var aspects = Belt_Array.concatMany(Belt_Array.map(AVLTree$AgdaModeVscode.toArray(infosWithRanges), (function (param) {
              var range = param[1];
              return Belt_Array.map(param[0].aspects, (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  return Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.keepMap(aspects, (function (param) {
                    var range = param[1];
                    return Belt_Option.map(Highlighting__Decoration$AgdaModeVscode.fromAspect(param[0]), (function (x) {
                                  return [
                                          x,
                                          range
                                        ];
                                }));
                  })), editor);
}

function make(param) {
  return {
          infos: Highlighting__Agda$AgdaModeVscode.Infos.make(undefined),
          decorations: [],
          semanticTokens: [],
          updated: false,
          requestsForTokens: []
        };
}

function clear(self) {
  self.infos = Highlighting__Agda$AgdaModeVscode.Infos.make(undefined);
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Highlighting__Agda$AgdaModeVscode.Infos.destroy(self.infos);
  return clear(self);
}

function redecorate(self, editor) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addViaPipe(self, editor, infos) {
  return Highlighting__Agda$AgdaModeVscode.Infos.insert(self.infos, editor, infos);
}

function addViaFile(self, filepath) {
  return Highlighting__Agda$AgdaModeVscode.Infos.addEmacsFilePath(self.infos, filepath);
}

function addViaJSONFile(self, filepath) {
  return Highlighting__Agda$AgdaModeVscode.Infos.addJSONFilePath(self.infos, filepath);
}

function lookupSrcLoc(self, offset) {
  return Belt_Option.map(Belt_Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(Highlighting__Agda$AgdaModeVscode.Infos.get(self.infos), offset), (function (param) {
                    var range = param[1];
                    return Belt_Option.map(param[0].source, (function (param) {
                                  return [
                                          range,
                                          param[0],
                                          param[1]
                                        ];
                                }));
                  })), (function (param) {
                var offset = param[2];
                var filepath = param[1];
                var range = param[0];
                return $$Promise.map(Vscode.workspace.openTextDocument(filepath), (function ($$document) {
                              var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                              var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                              var offset$1 = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, offset - 1 | 0);
                              var position = Editor$AgdaModeVscode.Position.fromOffset($$document, offset$1);
                              return [[
                                        range,
                                        filepath,
                                        position
                                      ]];
                            }));
              }));
}

function resolveRequestsForTokens(isUpdate, self) {
  Belt_Array.forEach(self.requestsForTokens, (function (resolve) {
          return Curry._1(resolve, self.semanticTokens);
        }));
  if (isUpdate) {
    self.updated = true;
  } else {
    self.updated = false;
  }
  self.requestsForTokens = [];
  
}

function classify(change, token) {
  var removedRange = change.range;
  var regex = /\r\n|\r|\n/;
  var lines = change.text.split(regex);
  var lineDetalOfRemovedRange = removedRange.end.line - removedRange.start.line | 0;
  var lineDelta = (lines.length - 1 | 0) - lineDetalOfRemovedRange | 0;
  var match;
  if (lineDelta > 0) {
    match = [
      lineDelta,
      -removedRange.end.character | 0
    ];
  } else if (lineDelta < 0) {
    var columnDelta = removedRange.end.character - removedRange.start.character | 0;
    match = [
      lineDelta,
      -columnDelta | 0
    ];
  } else {
    var columnDeltaOfRemovedRange = removedRange.end.character - removedRange.start.character | 0;
    var match$1 = Belt_Array.get(lines, lineDelta);
    var columnDelta$1;
    if (match$1 !== undefined) {
      var line = Caml_option.valFromOption(match$1);
      columnDelta$1 = line !== undefined ? line.length - columnDeltaOfRemovedRange | 0 : 0;
    } else {
      columnDelta$1 = 0;
    }
    match = [
      0,
      columnDelta$1
    ];
  }
  var lineDelta$1 = match[0];
  var tokenRange = Curry._1(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange, token.range);
  if (tokenRange.end.isBeforeOrEqual(removedRange.start)) {
    return /* NoOp */0;
  } else if (removedRange.contains(tokenRange) || tokenRange.start.isBefore(removedRange.start) && tokenRange.end.isAfter(removedRange.end)) {
    return /* Remove */1;
  } else if (token.range.line === removedRange.end.line) {
    return {
            TAG: 0,
            _0: lineDelta$1,
            _1: match[1],
            [Symbol.for("name")]: "Move"
          };
  } else if (lineDelta$1 === 0) {
    return /* NoOp */0;
  } else {
    return {
            TAG: 1,
            _0: lineDelta$1,
            [Symbol.for("name")]: "MoveLinesOnly"
          };
  }
}

function update(self, $$event) {
  var changes = $$event.contentChanges;
  var applyChange = function (tokens, change) {
    return Belt_Array.concatMany(Belt_Array.map(tokens, (function (token) {
                      var action = classify(change, token);
                      if (typeof action === "number") {
                        if (action === /* NoOp */0) {
                          return [token];
                        } else {
                          return [];
                        }
                      }
                      if (action.TAG !== /* Move */0) {
                        return [{
                                  range: {
                                    line: token.range.line + action._0 | 0,
                                    column: token.range.column
                                  },
                                  type_: token.type_,
                                  modifiers: token.modifiers
                                }];
                      }
                      var columnDelta = action._1;
                      return [{
                                range: {
                                  line: token.range.line + action._0 | 0,
                                  column: [
                                    token.range.column[0] + columnDelta | 0,
                                    token.range.column[1] + columnDelta | 0
                                  ]
                                },
                                type_: token.type_,
                                modifiers: token.modifiers
                              }];
                    })));
  };
  Belt_Array.forEach(changes, (function (change) {
          self.semanticTokens = applyChange(self.semanticTokens, change);
          
        }));
  return resolveRequestsForTokens(true, self);
}

function toSemanticTokensAndDecorations(self, editor) {
  var match = Belt_Array.unzip(Belt_Array.keepMap(Belt_Array.concatMany(Belt_Array.map(AVLTree$AgdaModeVscode.toArray(Highlighting__Agda$AgdaModeVscode.Infos.get(self.infos)), (function (param) {
                      var info = param[0];
                      var ranges = Curry._2(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange, editor.document, param[1]);
                      return Belt_Array.map(ranges, (function (range) {
                                    return [
                                            info.aspects,
                                            range
                                          ];
                                  }));
                    }))), (function (param) {
              var range = param[1];
              var match = Belt_Array.unzip(Belt_Array.map(param[0], Highlighting__SemanticToken$AgdaModeVscode.fromAspect));
              var match$1 = Belt_Array.unzip(match[0]);
              var tokenTypes = Belt_Array.keepMap(match$1[0], (function (x) {
                      return x;
                    }));
              var tokenModifiers = Belt_Array.concatMany(match$1[1]);
              var backgrounds = Belt_Array.keepMap(match[1], (function (x) {
                      return Belt_Option.map(x, (function (x) {
                                    return [
                                            x,
                                            Curry._1(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange, range)
                                          ];
                                  }));
                    }));
              var token = Belt_Option.map(Belt_Array.get(tokenTypes, 0), (function (tokenType) {
                      return {
                              range: range,
                              type_: tokenType,
                              modifiers: tokenModifiers
                            };
                    }));
              return [
                      token,
                      backgrounds
                    ];
            })));
  var tokens = Belt_Array.keepMap(match[0], (function (x) {
          return x;
        }));
  var backgrounds = Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.concatMany(match[1]), editor);
  return [
          tokens,
          backgrounds
        ];
}

function requestSemanticTokens(self) {
  if (self.updated) {
    return $$Promise.resolved(self.semanticTokens);
  }
  var match = $$Promise.pending(undefined);
  self.requestsForTokens.push(match[1]);
  return match[0];
}

function apply(self, editor) {
  return $$Promise.map(Highlighting__Agda$AgdaModeVscode.Infos.readTempFiles(self.infos, editor), (function (param) {
                if (Config$AgdaModeVscode.Highlighting.getSemanticHighlighting(undefined)) {
                  var match = toSemanticTokensAndDecorations(self, editor);
                  self.semanticTokens = match[0];
                  resolveRequestsForTokens(false, self);
                  self.decorations = Belt_Array.concat(self.decorations, match[1]);
                  return ;
                }
                var decorations = fromInfostoDecorations(Highlighting__Agda$AgdaModeVscode.Infos.get(self.infos), editor);
                self.decorations = Belt_Array.concat(self.decorations, decorations);
                
              }));
}

var Module_SemanticHighlighting = {
  update: update,
  toSemanticTokensAndDecorations: toSemanticTokensAndDecorations,
  requestSemanticTokens: requestSemanticTokens
};

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  addViaPipe: addViaPipe,
  addViaFile: addViaFile,
  addViaJSONFile: addViaJSONFile,
  apply: apply,
  clear: clear,
  redecorate: redecorate,
  lookupSrcLoc: lookupSrcLoc,
  SemanticHighlighting: Module_SemanticHighlighting
};

var SemanticHighlighting = Module_SemanticHighlighting;

exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.addViaPipe = addViaPipe;
exports.addViaFile = addViaFile;
exports.addViaJSONFile = addViaJSONFile;
exports.apply = apply;
exports.clear = clear;
exports.redecorate = redecorate;
exports.lookupSrcLoc = lookupSrcLoc;
exports.SemanticHighlighting = SemanticHighlighting;
/* vscode Not a pure module */
