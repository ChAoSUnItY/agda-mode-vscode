// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var TaskQueue$AgdaModeVscode = require("./TaskQueue.bs.js");
var Connection$AgdaModeVscode = require("../Connection.bs.js");
var Decoration$AgdaModeVscode = require("../Decoration.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var sendAgdaRequest = function (runTasks, runTasksLater, state, request) {
    var match_000 = function (prim) {
      console.log(prim);
      
    };
    var match_001 = function (prim, prim$1) {
      console.log(prim, prim$1);
      
    };
    var log2 = match_001;
    var log = match_000;
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        if (response.tag) {
          var response$1 = response[1];
          var priority = response[0];
          Curry._1(log, ">>> " + (String(priority) + (" " + Response$AgdaModeVscode.toString(response$1))));
          var tasks = Curry._1(ResponseHandler.handle, response$1);
          return Curry._2(runTasksLater, priority, tasks);
        }
        var response$2 = response[0];
        Curry._1(log, ">>> " + Response$AgdaModeVscode.toString(response$2));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response$2));
      }
      Curry._1(log, ">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap($$Promise.mapOk(Curry._1(Task.State.connect, state), (function (connection) {
                          var version = connection.metadata.version;
                          var filepath = Belt_Option.getWithDefault(Curry._1(Editor.getFileName, state.editor), "");
                          var libraryPath = Curry._1(Editor.Config.getLibraryPath, undefined);
                          var highlightingMethod = Curry._1(Editor.Config.getHighlightingMethod, undefined);
                          var backend = Curry._1(Editor.Config.getBackend, undefined);
                          var encoded = Curry._7(Task.$$Request.encode, state.editor, version, filepath, backend, libraryPath, highlightingMethod, request);
                          Curry._2(log2, "<<<", encoded);
                          Connection$AgdaModeVscode.send(encoded, connection);
                          return connection;
                        })), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var log = function (prim) {
    console.log(prim);
    
  };
  var executeTask = function (state, queue, kickStart, task) {
    Curry._1(log, "================ " + Curry._1(Task.toString, task));
    var keepRunning;
    if (typeof task === "number") {
      switch (task) {
        case /* SuicideByCop */0 :
            Curry._1(Task.State.emitKillMePlz, state);
            keepRunning = $$Promise.resolved(false);
            break;
        case /* RemoveAllHighlightings */1 :
            Belt_Array.forEach(Belt_Array.map(state.decorations, (function (prim) {
                        return prim[0];
                      })), Editor.Decoration.destroy);
            state.decorations = [];
            keepRunning = $$Promise.resolved(true);
            break;
        case /* RefreshAllHighlightings */2 :
            Belt_Array.forEach(state.decorations, (function (param) {
                    return Curry._3(Editor.Decoration.decorate, state.editor, param[0], [param[1]]);
                  }));
            Belt_Array.forEach(state.goals, (function (goal) {
                    return Curry._2(Task.Goal.refreshDecoration, goal, state.editor);
                  }));
            keepRunning = $$Promise.resolved(true);
            break;
        
      }
    } else {
      switch (task.tag | 0) {
        case /* DispatchCommand */0 :
            var tasks = Curry._1(CommandHandler.handle, task[0]);
            TaskQueue$AgdaModeVscode.addTasksToFront(queue, tasks);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* SendRequest */1 :
            if (TaskQueue$AgdaModeVscode.agdaIsOccupied(queue)) {
              console.log("[ panic ] There can only be 1 Agda request at a time!");
              keepRunning = $$Promise.resolved(false);
            } else {
              TaskQueue$AgdaModeVscode.acquireAgda(queue);
              var lastTasks = [];
              $$Promise.map(sendAgdaRequest((function (tasks) {
                          TaskQueue$AgdaModeVscode.addTasksToAgda(queue, tasks);
                          return Curry._1(kickStart, queue);
                        }), (function (priority, tasks) {
                          lastTasks.push(/* tuple */[
                                priority,
                                tasks
                              ]);
                          
                        }), state, task[0]), (function (param) {
                      var tasks = Belt_List.concatMany(Belt_Array.map(lastTasks.sort((function (x, y) {
                                      return Caml_primitive.caml_int_compare(x[0], y[0]);
                                    })), (function (prim) {
                                  return prim[1];
                                })));
                      TaskQueue$AgdaModeVscode.addTasksToAgda(queue, tasks);
                      TaskQueue$AgdaModeVscode.releaseAgda(queue);
                      return Curry._1(kickStart, queue);
                    }));
              keepRunning = $$Promise.resolved(true);
            }
            break;
        case /* SendEventToView */2 :
            keepRunning = $$Promise.map(Curry._2(Task.State.sendEventToView, state, task[0]), (function (param) {
                    return true;
                  }));
            break;
        case /* SendRequestToView */3 :
            var callback = task[1];
            if (TaskQueue$AgdaModeVscode.viewIsOccupied(queue)) {
              keepRunning = $$Promise.resolved(false);
            } else {
              TaskQueue$AgdaModeVscode.acquireView(queue);
              keepRunning = $$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                      if (response !== undefined) {
                        TaskQueue$AgdaModeVscode.addTasksToView(queue, Curry._1(callback, response));
                        TaskQueue$AgdaModeVscode.releaseView(queue);
                        return true;
                      } else {
                        return true;
                      }
                    }));
            }
            break;
        case /* AddHighlightings */4 :
            Belt_Array.forEach(task[0], (function (highlighting) {
                    var decorations = Curry._2(Decoration.decorateHighlighting, state.editor, highlighting);
                    state.decorations = Belt_Array.concat(state.decorations, decorations);
                    
                  }));
            keepRunning = $$Promise.resolved(true);
            break;
        case /* Error */5 :
            var tasks$1 = Curry._1(ErrorHandler.handle, task[0]);
            TaskQueue$AgdaModeVscode.addTasksToFront(queue, tasks$1);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* Goal */6 :
            var tasks$2 = Curry._1(GoalHandler.handle, task[0]);
            TaskQueue$AgdaModeVscode.addTasksToFront(queue, tasks$2);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* WithState */7 :
            Curry._1(task[0], state);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* WithStateP */8 :
            keepRunning = $$Promise.map($$Promise.map(Curry._1(task[0], state), (function (param) {
                        return TaskQueue$AgdaModeVscode.addTasksToFront(queue, param);
                      })), (function (param) {
                    return true;
                  }));
            break;
        case /* Debug */9 :
            console.log("DEBUG " + task[0]);
            keepRunning = $$Promise.resolved(true);
            break;
        
      }
    }
    Curry._1(log, TaskQueue$AgdaModeVscode.toString(Task.toString, queue));
    return keepRunning;
  };
  var make = function (state) {
    return {
            blocking: TaskQueue$AgdaModeVscode.make((function (param, param$1, param$2) {
                    return executeTask(state, param, param$1, param$2);
                  })),
            critical: TaskQueue$AgdaModeVscode.make((function (param, param$1, param$2) {
                    return executeTask(state, param, param$1, param$2);
                  }))
          };
  };
  var dispatchCommand = function (self, command) {
    var exit = 0;
    if (typeof command === "number") {
      switch (command) {
        case /* NextGoal */8 :
        case /* PreviousGoal */9 :
        case /* Escape */15 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    } else {
      switch (command.tag | 0) {
        case /* EventFromView */8 :
        case /* InputMethod */13 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          TaskQueue$AgdaModeVscode.addTasksToBack(self.blocking, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return TaskQueue$AgdaModeVscode.kickStart(self.blocking);
      case 2 :
          TaskQueue$AgdaModeVscode.addTasksToBack(self.critical, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return TaskQueue$AgdaModeVscode.kickStart(self.critical);
      
    }
  };
  var destroy = function (self) {
    return $$Promise.flatMap(TaskQueue$AgdaModeVscode.destroy(self.critical), (function (param) {
                  return TaskQueue$AgdaModeVscode.destroy(self.blocking);
                }));
  };
  var forceDestroy = function (self) {
    return $$Promise.flatMap(TaskQueue$AgdaModeVscode.forceDestroy(self.critical), (function (param) {
                  return TaskQueue$AgdaModeVscode.forceDestroy(self.blocking);
                }));
  };
  return {
          Decoration: Decoration,
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          sendAgdaRequest: sendAgdaRequest,
          printLog: true,
          log: log,
          executeTask: executeTask,
          make: make,
          dispatchCommand: dispatchCommand,
          destroy: destroy,
          forceDestroy: forceDestroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
