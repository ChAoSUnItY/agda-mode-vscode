open Belt;

module Impl = (Editor: Sig.Editor) => {
  module ErrorHandler = Handle__Error.Impl(Editor);
  module GoalHandler = Handle__Goal.Impl(Editor);
  module CommandHandler = Handle__Command.Impl(Editor);
  module ResponseHandler = Handle__Response.Impl(Editor);
  module Task = Task.Impl(Editor);
  open! Task;

  type source =
    | Agda
    | View
    | Command;

  type status =
    | Busy
    | Idle;

  type t = {
    //  `queues` represents a list of Task queues, tagged by some `source`,
    //  which is responsible for generating and pushing Tasks into its Task queue
    //
    //  For example, the initial queues should look something like this,
    //  with `Command` as the only source of Tasks
    //
    //    [ Command : [ Task0, Task1 ]
    //    ]
    //
    //  More Tasks will be added to this queue as the user gives more commands
    //
    //    [ Command : [ Task0, Task1, Task2, Task3 ]
    //    ]
    //
    //  On the other hand, Tasks are comsumed from the other end (that's how queue works, right?)
    //
    //    [ Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  However, some Tasks are special, they block other Tasks coming after them,
    //  and even generates Tasks on their own!
    //  `SendRequest(..)` (to Agda) is among one of these Tasks:
    //
    //    [ Agda    : [ Task4, Task5, Task6, .... ]
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  Tasks of Reponses from Agda will be added to this new "Agda" queue.
    //  Tasks in the "Agda" queue have higher priority than those of the "Command" queue.
    //
    //    [ Agda    : [ Task5, Task6, Task7, ... ]
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  Often, tasks in the "Agda" queue are consumed faster than they are generated by Agda.
    //  And this would cause the "Agda" queue to be empty.
    //  However, this doesn't mean that we can continue to consume Tasks in the "Command" queue,
    //  as more Tasks may will be added to the "Agda" queue.
    //
    //    [ Agda    : [ ]
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  The "Agda" queue can only be removed after the request-response cycle is completed.
    //  Tasks in the "Command" queue can then continue to be executed afterwards.
    //
    //    [ Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  If there are any remaining Tasks in the "Agda" queue after the cycle is completed:
    //
    //    [ Agda    : [ Task5, Task6, Task7 ]
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  The remaining Tasks should be concatenated to the next queue with lower priority
    //  (in this case, the "Command" queue)
    //
    //    [ Command : [ Task5, Task6, Task7, Task1, Task2, Task3 ]
    //    ]
    //
    //  Note that other Tasks in the "Agda" queue may also behave like `SendRequest(..)`.
    //  For example, it may prompt an input box and wait until the user to reply.
    //  In this case, the "Agda" queue is now blocked by the "View" queue.
    //
    //    [ View    : [ Task8 ]
    //    , Agda    : [ Task5, Task6, Task7, ... ]
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  Interestingly, the Tasks in the "Agda" queue may just be `SendRequest(..)`.
    //  Since there can only be one request to Agda at a time, the resouce is now occupied,
    //  The whole queues should be blocked, and wait until the current
    //  request-response cycle is completed.
    //
    //    [ Agda    : [ SendRequest(..), Task4 ]       (assume completed)
    //    , Command : [ Task1, Task2, Task3 ]
    //    ]
    //
    //  Then, the "Agda" queue should be removed while
    //  the remaining Tasks get concatenated to the next queue
    //
    //    [ Command : [ SendRequest(..), Task4, Task1, Task2, Task3 ]
    //    ]
    //
    //  And `SendRequest(..)` should be able to be executed and spawn a new "Agda" queue
    //
    //    [ Agda    : [ Task5, Task6, Task7, ... ]
    //    , Command : [ Task4, Task1, Task2, Task3 ]
    //    ]
    //
    mutable queues: list((source, list(Task.t))),
    // status will be set to `Busy` if there are Tasks being executed
    // A semaphore to make sure that only one `kickStart` is running at a time
    mutable status,
  };

  let getNextTask = self =>
    switch (self.queues) {
    | [] => None
    | [(_source, []), ..._queues] => None // stuck waiting for the `_source`
    | [(source, [task, ...queue]), ...queues] =>
      Some((task, [(source, queue), ...queues]))
    };

  let executeTask = (self, task) => Promise.resolved();

  // consuming Tasks in the `queues`
  let rec kickStart = self => {
    switch (self.status) {
    | Busy => () // `kickStart` is already invoked and running
    | Idle =>
      switch (getNextTask(self)) {
      | None => ()
      | Some((task, queues)) =>
        self.status = Busy; // flip the semaphore
        self.queues = queues;
        executeTask(self, task) // and start executing tasks
        ->Promise.get(() => {
            self.status = Idle; // flip the semaphore back
            kickStart(self); // and keep running
          });
      }
    };
  };
};