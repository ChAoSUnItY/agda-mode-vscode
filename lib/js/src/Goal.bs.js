// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Decoration$AgdaModeVscode = require("./Decoration.bs.js");
var SourceFile$AgdaModeVscode = require("./Parser/SourceFile.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var make = function (editor, diff, param) {
    var originalRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, diff.originalRange[0]), Curry._2(Editor.pointAtOffset, editor, diff.originalRange[1]));
    return $$Promise.map(Curry._3(Editor.replaceText, editor, originalRange, diff.content), (function (param) {
                  var match = Curry._3(Decoration.decorateHole, editor, diff.modifiedRange, diff.index);
                  return {
                          index: diff.index,
                          range: diff.modifiedRange,
                          decorationBackground: match[0],
                          decorationIndex: match[1]
                        };
                }));
  };
  var generateDiffs = function (editor, indices) {
    var filePath = Belt_Option.getWithDefault(Curry._1(Editor.getFileName, editor), "unnamed.agda");
    var source = Curry._1(Editor.getText, editor);
    return SourceFile$AgdaModeVscode.parse(indices, filePath, source);
  };
  var makeMany = function (editor, indices) {
    var diffs = generateDiffs(editor, indices);
    return Util$AgdaModeVscode.oneByOne(Belt_Array.map(diffs, (function (param, param$1) {
                      return make(editor, param, param$1);
                    })));
  };
  var updateRanges = function (goals, editor) {
    var indices = Belt_Array.map(goals, (function (goal) {
            return goal.index;
          }));
    var diffs = generateDiffs(editor, indices);
    return Belt_Array.forEachWithIndex(diffs, (function (i, diff) {
                  var goal = Belt_Array.get(goals, i);
                  if (goal !== undefined) {
                    goal.range = diff.modifiedRange;
                    return ;
                  }
                  
                }));
  };
  var getInnerRange = function (self, editor) {
    return Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, self.range[0] + 2 | 0), Curry._2(Editor.pointAtOffset, editor, self.range[1] - 2 | 0));
  };
  var getOuterRange = function (self, editor) {
    return Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, self.range[0]), Curry._2(Editor.pointAtOffset, editor, self.range[1]));
  };
  var getContent = function (self, editor) {
    var innerRange = getInnerRange(self, editor);
    return Parser$AgdaModeVscode.userInput(Curry._2(Editor.getTextInRange, editor, innerRange));
  };
  var setContent = function (self, editor, text) {
    var innerRange = getInnerRange(self, editor);
    return Curry._3(Editor.replaceText, editor, innerRange, " " + (text + " "));
  };
  var setCursor = function (self, editor) {
    var match = self.range;
    var point = Curry._2(Editor.pointAtOffset, editor, match[0] + 3 | 0);
    return Curry._2(Editor.setCursorPosition, editor, point);
  };
  var buildHaskellRange = function (editor, self, old, filepath) {
    var match = self.range;
    var end_ = match[1];
    var start = match[0];
    var startPoint = Curry._2(Editor.pointAtOffset, editor, start);
    var endPoint = Curry._2(Editor.pointAtOffset, editor, end_);
    var startIndex = String(start + 3 | 0);
    var startRow = String(Curry._1(Editor.Point.line, startPoint) + 1 | 0);
    var startColumn = String(Curry._1(Editor.Point.column, startPoint) + 3 | 0);
    var startPart = "" + (String(startIndex) + (" " + (String(startRow) + (" " + (String(startColumn) + "")))));
    var endIndex$prime = String(end_ - 3 | 0);
    var endRow = String(Curry._1(Editor.Point.line, endPoint) + 1 | 0);
    var endColumn = String(Curry._1(Editor.Point.column, endPoint) - 1 | 0);
    var endPart = "" + (String(endIndex$prime) + (" " + (String(endRow) + (" " + (String(endColumn) + "")))));
    if (old) {
      return "(Range [Interval (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(startPart) + (") (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(endPart) + ")])")))))));
    } else {
      return "(intervalsToRange (Just (mkAbsolute \"" + (String(filepath) + ("\")) [Interval (Pn () " + (String(startPart) + (") (Pn () " + (String(endPart) + ")])")))));
    }
  };
  var refreshDecoration = function (self, editor) {
    var range = getOuterRange(self, editor);
    Curry._3(Editor.Decoration.decorate, editor, self.decorationBackground, [range]);
    var range$1 = Curry._2(Editor.$$Range.make, Curry._1(Editor.$$Range.start, range), Curry._3(Editor.Point.translate, Curry._1(Editor.$$Range.end_, range), 0, -2));
    return Curry._3(Editor.Decoration.decorate, editor, self.decorationIndex, [range$1]);
  };
  var destroy = function (self) {
    Curry._1(Editor.Decoration.destroy, self.decorationBackground);
    return Curry._1(Editor.Decoration.destroy, self.decorationIndex);
  };
  return {
          Decoration: Decoration,
          make: make,
          generateDiffs: generateDiffs,
          makeMany: makeMany,
          updateRanges: updateRanges,
          getInnerRange: getInnerRange,
          getOuterRange: getOuterRange,
          getContent: getContent,
          setContent: setContent,
          setCursor: setCursor,
          buildHaskellRange: buildHaskellRange,
          refreshDecoration: refreshDecoration,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
