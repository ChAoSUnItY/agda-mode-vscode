// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var State$AgdaModeVscode = require("../State.bs.js");

function Impl(Editor) {
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var State = State$AgdaModeVscode.Impl(Editor);
  var Goal = Goal$AgdaModeVscode.Impl(Editor);
  var getOffsets = function (state) {
    return Belt_Array.map(state.goals, (function (goal) {
                  return goal.range[0] + 3 | 0;
                }));
  };
  var pointingAt = function (cursor, state) {
    var cursorOffset = cursor !== undefined ? cursor : Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
    var pointedGoals = Belt_Array.keep(state.goals, (function (goal) {
            if (goal.range[0] <= cursorOffset) {
              return cursorOffset <= goal.range[1];
            } else {
              return false;
            }
          }));
    return Belt_Array.get(pointedGoals, 0);
  };
  var caseSplitAux = function (editor, goal) {
    var start = Curry._2(Editor.pointAtOffset, editor, 0);
    var end_ = Curry._2(Editor.pointAtOffset, editor, goal.range[0]);
    var range = Curry._2(Editor.$$Range.make, start, end_);
    var textBeforeGoal = Curry._2(Editor.getTextInRange, editor, range);
    var nextWordBoundary = function (start, string) {
      var $$break = false;
      var n = 0;
      var i = start + 1 | 0;
      while(i < string.length && !$$break) {
        var $$char = string.charAt(i);
        switch ($$char) {
          case "\t" :
          case "\f" :
          case " " :
              n = n + 1 | 0;
              break;
          default:
            $$break = true;
        }
        i = i + 1 | 0;
      };
      return (start + n | 0) + 1 | 0;
    };
    var bracketCount = 0;
    var i = goal.range[0] - 1 | 0;
    while(i >= 0 && bracketCount >= 0) {
      var i$prime = i;
      if (i$prime !== 0) {
        var match = textBeforeGoal.charAt(i$prime - 1 | 0);
        switch (match) {
          case "{" :
              bracketCount = bracketCount - 1 | 0;
              break;
          case "}" :
              bracketCount = bracketCount + 1 | 0;
              break;
          default:
            
        }
      }
      i = i - 1 | 0;
    };
    var lastOpenCurlyBracketOffset = i + 1 | 0;
    var n = textBeforeGoal.lastIndexOf(";");
    var lastSemicolonOffset = (
      n !== -1 ? n : 0
    ) + 1 | 0;
    var n$1 = textBeforeGoal.lastIndexOf("where");
    var lastWhereTokenOffset = (
      n$1 !== -1 ? n$1 : 0
    ) + 5 | 0;
    var lastLineBreakOffset = Caml_primitive.caml_int_max(0, Caml_primitive.caml_int_max(textBeforeGoal.lastIndexOf("\r"), textBeforeGoal.lastIndexOf("\n"))) + 1 | 0;
    var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
    var offset = Caml_primitive.caml_int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
    var caseStart = nextWordBoundary(offset, textBeforeGoal);
    var caseEnd = goal.range[1];
    var range$1 = /* tuple */[
      caseStart,
      caseEnd
    ];
    return /* tuple */[
            inWhereClause,
            caseStart - lastLineBreakOffset | 0,
            range$1
          ];
  };
  var indentationWidth = function (editor, goal) {
    var goalStart = Curry._2(Editor.pointAtOffset, editor, goal.range[0]);
    var lineNo = Curry._1(Editor.Point.line, goalStart);
    var range = Curry._2(Editor.$$Range.make, Curry._2(Editor.Point.make, lineNo, 0), goalStart);
    var textBeforeGoal = Curry._2(Editor.getTextInRange, editor, range);
    var indentedBy = function (s) {
      var n = 0;
      for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
        var match = s.charAt(i);
        var exit = 0;
        switch (match) {
          case "\t" :
          case "\n" :
          case "\f" :
          case "\r" :
          case " " :
              exit = 1;
              break;
          default:
            
        }
        if (exit === 1 && i === n) {
          n = n + 1 | 0;
        }
        
      }
      return n;
    };
    return /* tuple */[
            indentedBy(textBeforeGoal),
            textBeforeGoal,
            range
          ];
  };
  var inWhereClause = function (editor, goal) {
    var match = indentationWidth(editor, goal);
    var range = match[2];
    var textBeforeGoal = match[1];
    var indentWidth = match[0];
    var searchStart = Curry._1(Editor.Point.column, Curry._1(Editor.$$Range.end_, range));
    var n = textBeforeGoal.lastIndexOf(";");
    var searchEnd = n !== -1 ? n + 1 | 0 : indentWidth;
    var bracketCount = 0;
    var i = searchStart - 1 | 0;
    while(i >= searchEnd && bracketCount >= 0) {
      var i$prime = i;
      if (i$prime !== 0) {
        var match$1 = textBeforeGoal.charAt(i$prime - 1 | 0);
        switch (match$1) {
          case "{" :
              bracketCount = bracketCount - 1 | 0;
              break;
          case "}" :
              bracketCount = bracketCount + 1 | 0;
              break;
          default:
            
        }
      }
      i = i - 1 | 0;
    };
    var rewriteStart = Curry._2(Editor.Point.make, Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.start, range)), i + 1 | 0);
    var rewriteEnd = Curry._2(Editor.pointAtOffset, editor, goal.range[1]);
    var rewriteRange = Curry._2(Editor.$$Range.make, rewriteStart, rewriteEnd);
    console.log(i + 1 | 0);
    console.log(indentWidth);
    var inWhereClause$1 = (i + 1 | 0) === indentWidth;
    return /* tuple */[
            inWhereClause$1,
            rewriteRange
          ];
  };
  var handle = function (indices) {
    if (typeof indices === "number") {
      switch (indices) {
        case /* UpdateRange */0 :
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                              return Curry._2(Task.Goal.updateRanges, state.goals, state.editor);
                            })]),
                      /* [] */0
                    ]);
        case /* Next */1 :
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                                  var nextGoal = {
                                    contents: undefined
                                  };
                                  var cursorOffset = Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
                                  var offsets = getOffsets(state);
                                  Belt_Array.forEach(offsets, (function (offset) {
                                          if (cursorOffset < offset && nextGoal.contents === undefined) {
                                            nextGoal.contents = offset;
                                            return ;
                                          }
                                          
                                        }));
                                  if (nextGoal.contents === undefined) {
                                    nextGoal.contents = Belt_Array.get(offsets, 0);
                                  }
                                  var offset = nextGoal.contents;
                                  if (offset !== undefined) {
                                    return Curry._2(Editor.setCursorPosition, state.editor, Curry._2(Editor.pointAtOffset, state.editor, offset));
                                  }
                                  
                                })]),
                          /* [] */0
                        ])
                    ]);
        case /* Previous */2 :
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                                  var previousGoal = {
                                    contents: undefined
                                  };
                                  var cursorOffset = Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
                                  var offsets = getOffsets(state);
                                  Belt_Array.forEach(offsets, (function (offset) {
                                          if (cursorOffset > offset) {
                                            previousGoal.contents = offset;
                                            return ;
                                          }
                                          
                                        }));
                                  if (previousGoal.contents === undefined) {
                                    previousGoal.contents = Belt_Array.get(offsets, offsets.length - 1 | 0);
                                  }
                                  var offset = previousGoal.contents;
                                  if (offset !== undefined) {
                                    return Curry._2(Editor.setCursorPosition, state.editor, Curry._2(Editor.pointAtOffset, state.editor, offset));
                                  }
                                  
                                })]),
                          /* [] */0
                        ])
                    ]);
        case /* SaveCursor */3 :
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                              var position = Curry._1(Editor.getCursorPosition, state.editor);
                              var offset = Curry._2(Editor.offsetAtPoint, state.editor, position);
                              state.cursor = offset;
                              
                            })]),
                      /* [] */0
                    ]);
        case /* RestoreCursor */4 :
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                              var offset = state.cursor;
                              if (offset === undefined) {
                                return ;
                              }
                              state.cursor = undefined;
                              var position = Curry._2(Editor.pointAtOffset, state.editor, offset);
                              var pointedGoal = pointingAt(offset, state);
                              if (pointedGoal !== undefined) {
                                if (Curry._2(Task.Goal.getContent, pointedGoal, state.editor) === "") {
                                  return Curry._2(Task.Goal.setCursor, pointedGoal, state.editor);
                                } else {
                                  return Curry._2(Editor.setCursorPosition, state.editor, position);
                                }
                              } else {
                                Curry._2(Editor.setCursorPosition, state.editor, position);
                                return Curry._1(Editor.focus, state.editor);
                              }
                            })]),
                      /* [] */0
                    ]);
        
      }
    } else {
      switch (indices.tag | 0) {
        case /* Instantiate */0 :
            var indices$1 = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                              Belt_Array.forEach(state.goals, Task.Goal.destroy);
                              return $$Promise.map(Curry._2(Task.Goal.makeMany, state.editor, indices$1), (function (goals) {
                                            state.goals = goals;
                                            return /* [] */0;
                                          }));
                            })]),
                      /* [] */0
                    ]);
        case /* Modify */1 :
            var f = indices[1];
            var goal = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                                  var content = Curry._2(Task.Goal.getContent, goal, state.editor);
                                  console.log("[ goal ][ modify ] \"" + (content + ("\" => \"" + (Curry._1(f, content) + "\""))));
                                  return $$Promise.map(Curry._3(Task.Goal.setContent, goal, state.editor, Curry._1(f, content)), (function (param) {
                                                if (param) {
                                                  return /* [] */0;
                                                } else {
                                                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                            Curry._2(Task.displayError, "Goal-related Error", "Failed to modify the content of goal #" + String(goal.index)),
                                                            /* [] */0
                                                          ]);
                                                }
                                              }));
                                })]),
                          /* [] */0
                        ])
                    ]);
        case /* SetCursor */2 :
            var offset = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithState */Caml_chrome_debugger.variant("WithState", 7, [(function (state) {
                              var point = Curry._2(Editor.pointAtOffset, state.editor, offset);
                              return Curry._2(Editor.setCursorPosition, state.editor, point);
                            })]),
                      /* [] */0
                    ]);
        case /* RemoveBoundaryAndDestroy */3 :
            var goal$1 = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                                  var innerRange = Curry._2(Task.Goal.getInnerRange, goal$1, state.editor);
                                  var outerRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, state.editor, goal$1.range[0]), Curry._2(Editor.pointAtOffset, state.editor, goal$1.range[1]));
                                  var content = $$String.trim(Curry._2(Editor.getTextInRange, state.editor, innerRange));
                                  return $$Promise.map(Curry._3(Editor.setText, state.editor, outerRange, content), (function (param) {
                                                if (param) {
                                                  Curry._1(Task.Goal.destroy, goal$1);
                                                  return /* [] */0;
                                                } else {
                                                  return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                            Curry._2(Task.displayError, "Goal-related Error", "Unable to remove the boundary of goal #" + String(goal$1.index)),
                                                            /* [] */0
                                                          ]);
                                                }
                                              }));
                                })]),
                          /* [] */0
                        ])
                    ]);
        case /* ReplaceWithLines */4 :
            var lines = indices[1];
            var goal$2 = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                              var match = indentationWidth(state.editor, goal$2);
                              var indentation = " ".repeat(match[0]);
                              var indentedLines = indentation + lines.join("\n" + indentation);
                              var start = Curry._2(Editor.pointAtOffset, state.editor, goal$2.range[0]);
                              var startLineNo = Curry._1(Editor.Point.line, start);
                              var startLineRange = Curry._2(Editor.rangeForLine, state.editor, startLineNo);
                              var start$1 = Curry._1(Editor.$$Range.start, startLineRange);
                              var end_ = Curry._2(Editor.pointAtOffset, state.editor, goal$2.range[1]);
                              var rangeToBeReplaced = Curry._2(Editor.$$Range.make, start$1, end_);
                              return $$Promise.map(Curry._3(Editor.setText, state.editor, rangeToBeReplaced, indentedLines), (function (param) {
                                            if (param) {
                                              Curry._1(Task.Goal.destroy, goal$2);
                                              return /* [] */0;
                                            } else {
                                              return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                        Curry._2(Task.displayError, "Goal-related Error", "Unable to replace the lines of goal #" + String(goal$2.index)),
                                                        /* [] */0
                                                      ]);
                                            }
                                          }));
                            })]),
                      /* [] */0
                    ]);
        case /* ReplaceWithLambda */5 :
            var lines$1 = indices[1];
            var goal$3 = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                              var match = indentationWidth(state.editor, goal$3);
                              var indentWidth = match[0];
                              var match$1 = inWhereClause(state.editor, goal$3);
                              var rewriteText = match$1[0] ? lines$1.join("\n" + " ".repeat(indentWidth)) : " " + lines$1.join("\n" + (" ".repeat(indentWidth) + "; "));
                              return $$Promise.map(Curry._3(Editor.setText, state.editor, match$1[1], rewriteText), (function (param) {
                                            if (param) {
                                              Curry._1(Task.Goal.destroy, goal$3);
                                              return /* [] */0;
                                            } else {
                                              return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                                        Curry._2(Task.displayError, "Goal-related Error", "Unable to replace the lines of goal #" + String(goal$3.index)),
                                                        /* [] */0
                                                      ]);
                                            }
                                          }));
                            })]),
                      /* [] */0
                    ]);
        case /* LocalOrGlobal */6 :
            var $$global = indices[1];
            var local = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                                  var goal = pointingAt(undefined, state);
                                  if (goal !== undefined) {
                                    return $$Promise.resolved(Curry._1(local, goal));
                                  } else {
                                    return $$Promise.resolved($$global);
                                  }
                                })]),
                          /* [] */0
                        ])
                    ]);
        case /* LocalOrGlobal2 */7 :
            var $$global$1 = indices[2];
            var localEmpty = indices[1];
            var local$1 = indices[0];
            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                      /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* UpdateRange */0]),
                      /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          /* WithStateP */Caml_chrome_debugger.variant("WithStateP", 8, [(function (state) {
                                  var goal = pointingAt(undefined, state);
                                  if (goal === undefined) {
                                    return $$Promise.resolved($$global$1);
                                  }
                                  var content = Curry._2(Task.Goal.getContent, goal, state.editor);
                                  if (content === "") {
                                    return $$Promise.resolved(Curry._1(localEmpty, goal));
                                  } else {
                                    return $$Promise.resolved(Curry._2(local$1, goal, content));
                                  }
                                })]),
                          /* [] */0
                        ])
                    ]);
        
      }
    }
  };
  return {
          Task: Task,
          State: State,
          Goal: Goal,
          getOffsets: getOffsets,
          pointingAt: pointingAt,
          caseSplitAux: caseSplitAux,
          indentationWidth: indentationWidth,
          inWhereClause: inWhereClause,
          handle: handle
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
