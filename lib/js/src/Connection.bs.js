// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Process$AgdaMode = require("agda-mode/lib/js/src/Process.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("./Util/Event.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Response$AgdaModeVscode = require("./Response.bs.js");

function toString(e) {
  switch (e.tag | 0) {
    case /* PathSearch */0 :
        return Curry._1(Process$AgdaMode.PathSearch.$$Error.toString, e[0]);
    case /* Validation */1 :
        return Curry._1(Process$AgdaMode.Validation.$$Error.toString, e[0]);
    case /* Process */2 :
        return Process$AgdaMode.$$Error.toString(e[0]);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(param) {
  if (param) {
    return "Emacs / JSON";
  } else {
    return "Emacs";
  }
}

var Protocol = {
  toString: toString$1
};

function toString$2(self) {
  var path = "* path: " + self.path;
  var args = "* args: " + Util$AgdaModeVscode.Pretty.array(self.args);
  var version = "* version: " + self.version;
  var protocol = "* protocol: " + (
    self.protocol ? "Emacs / JSON" : "Emacs"
  );
  var os = "* platform: " + Os.type();
  return "## Parse Log\n" + (path + ("\n" + (args + ("\n" + (version + ("\n" + (protocol + ("\n" + (os + "\n")))))))));
}

function make(path, args) {
  var validator = function (output) {
    var match_ = output.match(/Agda version (.*)/);
    if (match_ === null) {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read Agda version"]);
    }
    var version = Belt_Array.get(match_, 1);
    if (version !== undefined) {
      return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                  version,
                  /--interaction-json/.test(output) ? /* EmacsAndJSON */1 : /* EmacsOnly */0
                ]]);
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read Agda version"]);
    }
  };
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaMode.Validation.run(path + " -V", validator), (function (param) {
                    return {
                            path: path,
                            args: args,
                            version: param[0],
                            protocol: param[1]
                          };
                  })), (function (e) {
                return /* Validation */Caml_chrome_debugger.variant("Validation", 1, [e]);
              }));
}

var Metadata = {
  Protocol: Protocol,
  toString: toString$2,
  make: make
};

function destroy(self) {
  Curry._1(self.process.disconnect, undefined);
  Curry._1(self.emitter.destroy, undefined);
  self.encountedFirstPrompt = false;
  
}

function wire(self) {
  var toResponse = Curry._1(Parser$AgdaModeVscode.Incr.$$Event.flatMap, (function (parseError) {
          if (parseError.tag) {
            return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [/* Error */Caml_chrome_debugger.variant("Error", 1, [parseError[0]])]);
          }
          var tokens = parseError[0];
          if (tokens.tag || tokens[0] !== "Agda2>") {
            return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [Response$AgdaModeVscode.parse(tokens)]);
          } else {
            return /* Stop */0;
          }
        }));
  var mapError = function (x) {
    return Curry._2(Parser$AgdaModeVscode.Incr.$$Event.map, (function (x) {
                  if (!x.tag) {
                    return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [x[0]]);
                  }
                  var match = x[0];
                  return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                                match[0],
                                match[1]
                              ])]);
                }), x);
  };
  var pipeline = Parser$AgdaModeVscode.SExpression.makeIncr((function (x) {
          var res = Curry._1(toResponse, mapError(x));
          if (res) {
            return Curry._1(self.emitter.emit, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* Yield */Caml_chrome_debugger.simpleVariant("Yield", [res[0]])]));
          } else if (self.encountedFirstPrompt) {
            return Curry._1(self.emitter.emit, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* Stop */0]));
          } else {
            self.encountedFirstPrompt = true;
            return ;
          }
        }));
  var onData = function (rawText) {
    if (rawText.tag) {
      return Curry._1(self.emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 1, [rawText[0]]));
    } else {
      return Belt_Array.forEach(Parser$AgdaModeVscode.split(rawText[0]), (function (param) {
                    return Parser$AgdaModeVscode.Incr.feed(pipeline, param);
                  }));
    }
  };
  Curry._1(self.process.emitter.on, onData);
  
}

function make$1(fromConfig, toConfig) {
  var getPath = function (param) {
    var storedPath = Belt_Option.mapWithDefault(Curry._1(fromConfig, undefined), "", (function (prim) {
            return prim.trim();
          }));
    if (storedPath === "" || storedPath === ".") {
      return $$Promise.mapError($$Promise.mapOk(Process$AgdaMode.PathSearch.run("agda"), (function (prim) {
                        return prim.trim();
                      })), (function (e) {
                    return /* PathSearch */Caml_chrome_debugger.variant("PathSearch", 0, [e]);
                  }));
    } else {
      return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [storedPath]));
    }
  };
  var args = ["--interaction"];
  return $$Promise.tapOk($$Promise.mapOk($$Promise.tapOk($$Promise.flatMapOk(getPath(undefined), (function (path) {
                            return make(path, args);
                          })), (function (metadata) {
                        Curry._1(toConfig, metadata.path);
                        
                      })), (function (metadata) {
                    return {
                            metadata: metadata,
                            process: Process$AgdaMode.make(metadata.path, metadata.args),
                            emitter: Event$AgdaModeVscode.make(undefined),
                            encountedFirstPrompt: false
                          };
                  })), wire);
}

function send(request, self) {
  Curry._1(self.process.send, request);
  
}

var Process;

exports.Process = Process;
exports.$$Error = $$Error;
exports.Metadata = Metadata;
exports.destroy = destroy;
exports.wire = wire;
exports.make = make$1;
exports.send = send;
/* os Not a pure module */
