// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var State$AgdaModeVscode = require("../State.bs.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Task__View$AgdaModeVscode = require("./Task__View.bs.js");
var Task__Error$AgdaModeVscode = require("./Task__Error.bs.js");
var Task__Command$AgdaModeVscode = require("./Task__Command.bs.js");
var Task__Response$AgdaModeVscode = require("./Task__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Task__Error$AgdaModeVscode.Impl(Editor);
  var ViewHandler = Task__View$AgdaModeVscode.Impl(Editor);
  var TaskCommand = Task__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Task__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var State = State$AgdaModeVscode.Impl(Editor);
  var dispatchCommand = function (self, command) {
    return Curry._1(self.onAddCommand.emit, command);
  };
  var runTask = function (self, state, task) {
    if (typeof task === "number") {
      console.log("[ task ][ terminate ] ");
      Curry._1(State.destroy, state);
      return $$Promise.resolved(/* Concluded */1);
    }
    switch (task.tag | 0) {
      case /* SendRequest */0 :
          console.log("[ task ][ send request ]");
          var destructor = {
            contents: undefined
          };
          var stop = function (param) {
            self.pendingResponse = false;
            return Belt_Option.forEach(destructor.contents, (function (f) {
                          return Curry._1(f, undefined);
                        }));
          };
          var handler = function (error) {
            if (error.tag) {
              stop(undefined);
              Curry._1(self.onResponse.emit, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])]));
              return Curry._1(self.onResponse.emit, undefined);
            }
            var match = error[0];
            if (match) {
              var error$1 = match[0];
              if (!error$1.tag) {
                return Curry._1(self.onResponse.emit, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [error$1[0]]));
              }
              stop(undefined);
              Curry._1(self.onResponse.emit, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])]));
              return Curry._1(self.onResponse.emit, undefined);
            }
            stop(undefined);
            return Curry._1(self.onResponse.emit, undefined);
          };
          return $$Promise.flatMap(Curry._2(State.sendRequest, state, task[0]), (function (connection) {
                        if (connection.tag) {
                          var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                          return $$Promise.resolved(/* Derived */Caml_chrome_debugger.simpleVariant("Derived", [tasks]));
                        }
                        destructor.contents = Curry._1(connection[0].emitter.on, handler);
                        return $$Promise.resolved(/* Pending */0);
                      }));
      case /* ViewReq */1 :
          console.log("< >");
          return $$Promise.map(Curry._2(State.sendRequestToView, state, task[0]), (function (param) {
                        return /* Concluded */1;
                      }));
      case /* ViewRes */2 :
          var tasks = Curry._1(ViewHandler.handle, task[0]);
          return $$Promise.resolved(/* Derived */Caml_chrome_debugger.simpleVariant("Derived", [tasks]));
      case /* WithState */3 :
          return $$Promise.map(Curry._1(task[0], state), (function (tasks) {
                        return /* Derived */Caml_chrome_debugger.simpleVariant("Derived", [tasks]);
                      }));
      
    }
  };
  var make = function (state) {
    var onAddCommand = Event$AgdaModeVscode.make(undefined);
    var onResponse = Event$AgdaModeVscode.make(undefined);
    var onChangeStatus = Event$AgdaModeVscode.make(undefined);
    var queue = {
      contents: []
    };
    var self = {
      onAddCommand: onAddCommand,
      onResponse: onResponse,
      pendingResponse: false,
      onChangeStatus: onChangeStatus,
      status: /* Idle */1
    };
    var getNextTask = function (param) {
      if (self.pendingResponse) {
        return ;
      } else {
        return Caml_option.undefined_to_opt(queue.contents.shift());
      }
    };
    var pushDerivedTasks = function (tasks) {
      queue.contents = queue.contents.concat(Belt_List.toArray(tasks));
      
    };
    var runTasksInQueues = function (param) {
      if (self.pendingResponse) {
        var destructor = {
          contents: undefined
        };
        destructor.contents = Curry._1(self.onResponse.on, (function (param) {
                if (param !== undefined) {
                  if (param.tag) {
                    return pushDerivedTasks(Curry._1(ErrorHandler.handle, param[0]));
                  }
                  var response = param[0];
                  console.log("Response " + Response$AgdaModeVscode.toString(response));
                  return pushDerivedTasks(Curry._1(ResponseHandler.handle, response));
                }
                console.log("status: " + Pervasives.string_of_bool(self.pendingResponse));
                runTasksInQueues(undefined);
                return Belt_Option.forEach(destructor.contents, (function (f) {
                              return Curry._1(f, undefined);
                            }));
              }));
        return ;
      }
      var nextTask = getNextTask(undefined);
      if (nextTask !== undefined) {
        return $$Promise.get(runTask(self, state, nextTask), (function (tasks) {
                      if (typeof tasks === "number") {
                        if (tasks !== 0) {
                          console.log("Concluded");
                          return runTasksInQueues(undefined);
                        } else {
                          console.log("Pending");
                          self.pendingResponse = true;
                          return runTasksInQueues(undefined);
                        }
                      } else {
                        console.log("Derived");
                        pushDerivedTasks(tasks[0]);
                        return runTasksInQueues(undefined);
                      }
                    }));
      } else {
        self.status = /* Idle */1;
        return Curry._1(self.onChangeStatus.emit, /* Idle */1);
      }
    };
    Curry._1(onAddCommand.on, (function (command) {
            pushDerivedTasks(Curry._1(TaskCommand.dispatch, command));
            if (self.status === /* Idle */1) {
              self.status = /* Busy */0;
              Curry._1(self.onChangeStatus.emit, /* Busy */0);
              return runTasksInQueues(undefined);
            }
            
          }));
    return self;
  };
  var destroy = function (self) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var destroy$prime = function (param) {
      Curry._1(self.onChangeStatus.destroy, undefined);
      Curry._1(self.onAddCommand.destroy, undefined);
      return Curry._1(resolve, undefined);
    };
    var match$1 = self.status;
    if (match$1) {
      destroy$prime(undefined);
    } else {
      Curry._1(self.onChangeStatus.on, (function (param) {
              if (param) {
                return destroy$prime(undefined);
              }
              
            }));
    }
    return match[0];
  };
  return {
          ErrorHandler: ErrorHandler,
          ViewHandler: ViewHandler,
          TaskCommand: TaskCommand,
          ResponseHandler: ResponseHandler,
          Task: Task,
          State: State,
          dispatchCommand: dispatchCommand,
          runTask: runTask,
          make: make,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
