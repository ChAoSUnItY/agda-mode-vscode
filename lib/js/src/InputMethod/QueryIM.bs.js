// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");

function Impl(Editor) {
  var $$Buffer = Buffer$AgdaModeVscode.Impl(Editor);
  var make = function (param) {
    return {
            activated: false,
            start: 0,
            buffer: Curry._1($$Buffer.make, undefined)
          };
  };
  var activate = function (self, text) {
    self.activated = true;
    self.start = text.length;
    
  };
  var update = function (self, input) {
    var inputLength = input.length;
    var before = input.substring(0, self.start);
    var expected = before + Curry._1($$Buffer.toSurface, self.buffer);
    var actual = input.substring(0, inputLength - 1 | 0);
    var isInsertion = actual === expected;
    var isBackspace = input === before;
    if (isInsertion) {
      var insertedText = input.substring(inputLength - 1 | 0);
      var change_offset = inputLength - 1 | 0;
      var change = {
        offset: change_offset,
        insertText: insertedText,
        replaceLength: 0
      };
      var match = Curry._3($$Buffer.reflectEditorChange, self.buffer, self.start, change);
      var buffer = match[0];
      self.buffer = buffer;
      if (buffer.translation.further) {
        return /* tuple */[
                before + Curry._1($$Buffer.toSurface, buffer),
                /* Update */Caml_chrome_debugger.variant("Update", 1, [
                    Curry._1($$Buffer.toSequence, buffer),
                    buffer.translation,
                    buffer.candidateIndex
                  ])
              ];
      } else {
        self.buffer = Curry._1($$Buffer.make, undefined);
        self.activated = false;
        if (match[1] !== undefined) {
          return /* tuple */[
                  before + Curry._1($$Buffer.toSurface, buffer),
                  /* Deactivate */1
                ];
        } else {
          return /* tuple */[
                  input,
                  /* Deactivate */1
                ];
        }
      }
    }
    if (isBackspace) {
      var change$1 = {
        offset: inputLength,
        insertText: "",
        replaceLength: 1
      };
      var match$1 = Curry._3($$Buffer.reflectEditorChange, self.buffer, self.start, change$1);
      var buffer$1 = match$1[0];
      self.buffer = buffer$1;
      if (buffer$1.translation.further) {
        return /* tuple */[
                before + Curry._1($$Buffer.toSurface, buffer$1),
                /* Update */Caml_chrome_debugger.variant("Update", 1, [
                    Curry._1($$Buffer.toSequence, buffer$1),
                    buffer$1.translation,
                    buffer$1.candidateIndex
                  ])
              ];
      } else {
        self.buffer = Curry._1($$Buffer.make, undefined);
        self.activated = false;
        return /* tuple */[
                before + Curry._1($$Buffer.toSurface, buffer$1),
                /* Deactivate */1
              ];
      }
    }
    self.buffer = Curry._1($$Buffer.make, undefined);
    self.activated = false;
    
  };
  return {
          $$Buffer: $$Buffer,
          make: make,
          activate: activate,
          update: update
        };
}

exports.Impl = Impl;
/* Buffer-AgdaModeVscode Not a pure module */
