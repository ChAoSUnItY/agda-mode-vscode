// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var EditorIM$AgdaModeVscode = require("../InputMethod/EditorIM.bs.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var TaskQueue$AgdaModeVscode = require("./TaskQueue.bs.js");
var Connection$AgdaModeVscode = require("../Connection.bs.js");
var Decoration$AgdaModeVscode = require("../Decoration.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");
var Handle__Decoration$AgdaModeVscode = require("./Handle__Decoration.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var DecorationHandler = Handle__Decoration$AgdaModeVscode.Impl(Editor);
  var EditorIM = EditorIM$AgdaModeVscode.Impl(Editor);
  var TaskQueue = TaskQueue$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var sendAgdaRequest = function (addToAgdaQueue, addToDeferredQueue, state, request) {
    var match_000 = function (param) {
      
    };
    var match_001 = function (param, param$1) {
      
    };
    var log2 = match_001;
    var log = match_000;
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(addToAgdaQueue, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(addToAgdaQueue, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        if (!response.tag) {
          return Curry._1(addToAgdaQueue, Curry._1(ResponseHandler.handle, response[0]));
        }
        var response$1 = response[1];
        var priority = response[0];
        Curry._1(log, ">>> " + (String(priority) + (" " + Response$AgdaModeVscode.toString(response$1))));
        var tasks = Curry._1(ResponseHandler.handle, response$1);
        return Curry._2(addToDeferredQueue, priority, tasks);
      }
      Curry._1(log, ">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap($$Promise.mapOk(Curry._1(Task.State.connect, state), (function (connection) {
                          var version = connection.metadata.version;
                          var filepath = Belt_Option.getWithDefault(Curry._1(Editor.getFileName, state.editor), "");
                          var libraryPath = Curry._1(Editor.Config.getLibraryPath, undefined);
                          var highlightingMethod = Curry._1(Editor.Config.getHighlightingMethod, undefined);
                          var backend = Curry._1(Editor.Config.getBackend, undefined);
                          var encoded = Curry._7(Task.$$Request.encode, state.editor, version, filepath, backend, libraryPath, highlightingMethod, request);
                          Curry._2(log2, "<<<", encoded);
                          Connection$AgdaModeVscode.send(encoded, connection);
                          return connection;
                        })), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(addToAgdaQueue, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var executeTask = function (state, queue, task) {
    var keepRunning;
    if (typeof task === "number") {
      Curry._1(Task.State.emitRemoveFromRegistry, state);
      keepRunning = $$Promise.resolved(false);
    } else {
      switch (task.tag | 0) {
        case /* DispatchCommand */0 :
            var tasks = Curry._1(CommandHandler.handle, task[0]);
            Curry._2(TaskQueue.addToTheFront, queue, tasks);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* AgdaRequest */1 :
            if (Curry._1(TaskQueue.Agda.isOccupied, queue)) {
              console.log("[ panic ] There can only be 1 Agda request at a time!");
              console.log(Curry._2(TaskQueue.toString, Task.toString, queue));
              keepRunning = $$Promise.resolved(false);
            } else {
              var deferredTasks = [];
              console.time("$$$ Agda Request/Response");
              keepRunning = $$Promise.map($$Promise.flatMap(sendAgdaRequest((function (tasks) {
                              return Curry._2(TaskQueue.Agda.addToTheBack, queue, tasks);
                            }), (function (priority, tasks) {
                              deferredTasks.push(/* tuple */[
                                    priority,
                                    tasks
                                  ]);
                              
                            }), state, task[0]), (function (param) {
                          return Curry._1(TaskQueue.Agda.close, queue);
                        })), (function (param) {
                      console.timeEnd("$$$ Agda Request/Response");
                      var deferredTasks$1 = Belt_List.concatMany(Belt_Array.map(deferredTasks.sort((function (x, y) {
                                      return Caml_primitive.caml_int_compare(x[0], y[0]);
                                    })), (function (prim) {
                                  return prim[1];
                                })));
                      var deferredTasks_000 = /* Decoration */Caml_chrome_debugger.variant("Decoration", 4, [/* Apply */1]);
                      var deferredTasks$2 = /* :: */Caml_chrome_debugger.simpleVariant("::", [
                          deferredTasks_000,
                          deferredTasks$1
                        ]);
                      Curry._2(TaskQueue.addToTheFront, queue, deferredTasks$2);
                      return true;
                    }));
            }
            break;
        case /* ViewEvent */2 :
            keepRunning = $$Promise.map(Curry._2(Task.State.sendEventToView, state, task[0]), (function (param) {
                    return true;
                  }));
            break;
        case /* ViewRequest */3 :
            var callback = task[1];
            if (Curry._1(TaskQueue.View.isOccupied, queue)) {
              keepRunning = $$Promise.resolved(false);
            } else {
              $$Promise.map($$Promise.flatMap(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                          if (response !== undefined) {
                            Curry._2(TaskQueue.View.addToTheBack, queue, Curry._1(callback, response));
                            return Curry._1(TaskQueue.View.close, queue);
                          } else {
                            return $$Promise.resolved(undefined);
                          }
                        })), (function (param) {
                      return true;
                    }));
              keepRunning = $$Promise.resolved(true);
            }
            break;
        case /* Decoration */4 :
            var tasks$1 = Curry._1(DecorationHandler.handle, task[0]);
            Curry._2(TaskQueue.addToTheFront, queue, tasks$1);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* Error */5 :
            var tasks$2 = Curry._1(ErrorHandler.handle, task[0]);
            Curry._2(TaskQueue.addToTheFront, queue, tasks$2);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* Goal */6 :
            var tasks$3 = Curry._1(GoalHandler.handle, task[0]);
            Curry._2(TaskQueue.addToTheFront, queue, tasks$3);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* WithState */7 :
            Curry._1(task[0], state);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* WithStateP */8 :
            keepRunning = $$Promise.map($$Promise.map(Curry._1(task[0], state), Curry._1(TaskQueue.addToTheFront, queue)), (function (param) {
                    return true;
                  }));
            break;
        case /* BenchStart */9 :
            console.time(task[0]);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* BenchEnd */10 :
            console.timeEnd(task[0]);
            keepRunning = $$Promise.resolved(true);
            break;
        case /* Debug */11 :
            console.log("DEBUG " + task[0]);
            keepRunning = $$Promise.resolved(true);
            break;
        
      }
    }
    return keepRunning;
  };
  var addToTheBackCritical = function (self, tasks) {
    Curry._2(TaskQueue.addToTheBack, self.critical, tasks);
    return Curry._1(TaskQueue.onEmptied, self.critical);
  };
  var addToTheBackBlocking = function (self, tasks) {
    Curry._2(TaskQueue.addToTheBack, self.blocking, tasks);
    return Curry._1(TaskQueue.onEmptied, self.blocking);
  };
  var dispatchCommand = function (self, command) {
    var nonBlocking = function (param) {
      if (typeof param === "number") {
        switch (param) {
          case /* NextGoal */8 :
          case /* PreviousGoal */9 :
          case /* Escape */15 :
              return true;
          default:
            return false;
        }
      } else {
        switch (param.tag | 0) {
          case /* EventFromView */8 :
          case /* InputMethod */13 :
              return true;
          default:
            return false;
        }
      }
    };
    if (nonBlocking(command)) {
      return addToTheBackCritical(self, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                    /* [] */0
                  ]));
    } else {
      return addToTheBackBlocking(self, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                    /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* SaveCursor */3]),
                    /* :: */Caml_chrome_debugger.simpleVariant("::", [
                        /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                        /* :: */Caml_chrome_debugger.simpleVariant("::", [
                            /* Goal */Caml_chrome_debugger.variant("Goal", 6, [/* RestoreCursor */4]),
                            /* [] */0
                          ])
                      ])
                  ]));
    }
  };
  var make = function (extentionPath, editor, removeFromRegistry, eventEmitter) {
    var state = Curry._3(Task.State.make, extentionPath, eventEmitter, editor);
    var dispatcher_blocking = Curry._1(TaskQueue.make, (function (param, param$1) {
            return executeTask(state, param, param$1);
          }));
    var dispatcher_critical = Curry._1(TaskQueue.make, (function (param, param$1) {
            return executeTask(state, param, param$1);
          }));
    var dispatcher = {
      state: state,
      blocking: dispatcher_blocking,
      critical: dispatcher_critical
    };
    state.subscriptions.push(Curry._2(Editor.View.onEvent, state.view, (function ($$event) {
                dispatchCommand(dispatcher, /* EventFromView */Caml_chrome_debugger.variant("EventFromView", 8, [$$event]));
                
              })));
    state.subscriptions.push(Curry._1(Editor.Disposable.make, Curry._1(state.editorIM.eventEmitter.on, (function (action) {
                    dispatchCommand(dispatcher, /* InputMethod */Caml_chrome_debugger.variant("InputMethod", 13, [action]));
                    
                  }))));
    $$Promise.get(Curry._1(Task.State.onRemoveFromRegistry, state), removeFromRegistry);
    return dispatcher;
  };
  var destroy = function (self) {
    return $$Promise.flatMap($$Promise.flatMap(Curry._1(TaskQueue.onEmptied, self.critical), (function (param) {
                      return Curry._1(TaskQueue.onEmptied, self.blocking);
                    })), (function (param) {
                  return Curry._1(Task.State.destroy, self.state);
                }));
  };
  var forceDestroy = function (self) {
    return $$Promise.flatMap($$Promise.flatMap(Curry._1(TaskQueue.forceDestroy, self.critical), (function (param) {
                      return Curry._1(TaskQueue.forceDestroy, self.blocking);
                    })), (function (param) {
                  return Curry._1(Task.State.destroy, self.state);
                }));
  };
  return {
          Decoration: Decoration,
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          DecorationHandler: DecorationHandler,
          EditorIM: EditorIM,
          TaskQueue: TaskQueue,
          Task: Task,
          sendAgdaRequest: sendAgdaRequest,
          executeTask: executeTask,
          addToTheBackCritical: addToTheBackCritical,
          addToTheBackBlocking: addToTheBackBlocking,
          dispatchCommand: dispatchCommand,
          make: make,
          destroy: destroy,
          forceDestroy: forceDestroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
