// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function Impl(Editor) {
  var decorateHole = function (editor, param, index) {
    var end_ = param[1];
    var start = param[0];
    var backgroundRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, start), Curry._2(Editor.pointAtOffset, editor, end_));
    var background = Curry._3(Editor.Decoration.highlightBackground, editor, "editor.selectionHighlightBackground", backgroundRange);
    var indexText = String(index);
    var indexRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, start), Curry._2(Editor.pointAtOffset, editor, end_ - 2 | 0));
    var index$1 = Curry._4(Editor.Decoration.overlayText, editor, "editorLightBulb.foreground", indexText, indexRange);
    return /* tuple */[
            background,
            index$1
          ];
  };
  var decorateAspect = function (editor, range, aspect) {
    var style = Highlighting$AgdaModeVscode.Aspect.toStyle(aspect);
    var decorate = function (color) {
      if (color.tag) {
        return Curry._3(Editor.Decoration.decorateTextWithColor, editor, color[0], range);
      } else {
        return Curry._3(Editor.Decoration.highlightBackgroundWithColor, editor, color[0], range);
      }
    };
    if (style) {
      if (Curry._1(Editor.colorThemeIsDark, undefined)) {
        return [/* tuple */[
                  decorate(style[1]),
                  range
                ]];
      } else {
        return [/* tuple */[
                  decorate(style[0]),
                  range
                ]];
      }
    } else {
      return [];
    }
  };
  var decorateHighlighting = function (editor, highlighting) {
    var start = Curry._3(Editor.fromUTF8Offset, editor, undefined, highlighting.start);
    var end_ = Curry._3(Editor.fromUTF8Offset, editor, undefined, highlighting.end_);
    var start$1 = Curry._2(Editor.pointAtOffset, editor, start);
    var end_$1 = Curry._2(Editor.pointAtOffset, editor, end_);
    var normalize = function (point) {
      var useCRLF = Curry._1(Editor.lineEndingIsCRLF, editor);
      if (!useCRLF) {
        return point;
      }
      var skippedCRLF = Curry._1(Editor.Point.line, point);
      return Curry._3(Editor.Point.translate, point, 0, skippedCRLF);
    };
    var range = Curry._2(Editor.$$Range.make, normalize(start$1), normalize(end_$1));
    return Belt_Array.concatMany(Belt_Array.map(highlighting.aspects, (function (param) {
                      return decorateAspect(editor, range, param);
                    })));
  };
  var computeUTF16SurrogatePairIndices = function (text) {
    var surrogatePairs = [];
    var lengthInCodeUnits = text.length;
    var i = 0;
    while(i < lengthInCodeUnits) {
      var charCode = text.charCodeAt(i) | 0;
      var notFinal = (i + 1 | 0) < lengthInCodeUnits;
      if (charCode >= 55296 && charCode <= 56319 && notFinal) {
        var nextCharCode = text.charCodeAt(i + 1 | 0) | 0;
        if (nextCharCode >= 56320 && charCode <= 57343) {
          surrogatePairs.push(i);
        }
        i = i + 2 | 0;
      } else {
        i = i + 1 | 0;
      }
    };
    return surrogatePairs;
  };
  var decorateHighlightings = function (editor, highlightings) {
    var text = Curry._1(Editor.getText, editor);
    var indicesUTF16 = computeUTF16SurrogatePairIndices(text);
    var indicesUTF8 = Belt_Array.mapWithIndex(indicesUTF16, (function (i, x) {
            return x - i | 0;
          }));
    var intervals = Belt_Array.mapWithIndex(indicesUTF8, (function (i, rightEndpoint) {
            var x = Belt_Array.get(indicesUTF8, i - 1 | 0);
            var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
            return /* tuple */[
                    leftEndpoint,
                    rightEndpoint
                  ];
          }));
    var lastEndpoint = text.length - indicesUTF16.length | 0;
    var match = Belt_Array.get(intervals, intervals.length - 1 | 0);
    var intervalsUTF8 = match !== undefined ? Belt_Array.concat(intervals, [/* tuple */[
              match[1] + 1 | 0,
              lastEndpoint
            ]]) : [/* tuple */[
          0,
          lastEndpoint
        ]];
    var cursor = {
      contents: 0
    };
    var fromUTF8Offset = function (index) {
      while(true) {
        var match = Belt_Array.get(intervalsUTF8, cursor.contents);
        if (match === undefined) {
          return index;
        }
        if (index < match[0]) {
          cursor.contents = 0;
          continue ;
        }
        if (index <= match[1]) {
          return index + cursor.contents | 0;
        }
        cursor.contents = cursor.contents + 1 | 0;
        continue ;
      };
    };
    return Belt_Array.concatMany(Belt_Array.map(highlightings, (function (highlighting) {
                      var start = fromUTF8Offset(highlighting.start);
                      var end_ = fromUTF8Offset(highlighting.end_);
                      var start$1 = Curry._2(Editor.pointAtOffset, editor, start);
                      var end_$1 = Curry._2(Editor.pointAtOffset, editor, end_);
                      var normalize = function (point) {
                        var useCRLF = Curry._1(Editor.lineEndingIsCRLF, editor);
                        if (!useCRLF) {
                          return point;
                        }
                        var skippedCRLF = Curry._1(Editor.Point.line, point);
                        return Curry._3(Editor.Point.translate, point, 0, skippedCRLF);
                      };
                      var range = Curry._2(Editor.$$Range.make, normalize(start$1), normalize(end_$1));
                      return Belt_Array.concatMany(Belt_Array.map(highlighting.aspects, (function (param) {
                                        return decorateAspect(editor, range, param);
                                      })));
                    })));
  };
  var make = function (param) {
    return {
            tempFilePaths: [],
            highlightings: [],
            decorations: []
          };
  };
  var destroy = function (self) {
    Belt_Array.forEach(self.tempFilePaths, (function (filepath) {
            Fs.unlink(filepath, (function (param) {
                    
                  }));
            
          }));
    self.tempFilePaths = [];
    self.highlightings = [];
    Belt_Array.forEach(self.decorations, (function (param) {
            return Curry._1(Editor.Decoration.destroy, param[0]);
          }));
    self.decorations = [];
    
  };
  var refresh = function (editor, self) {
    return Belt_Array.forEach(self.decorations, (function (param) {
                  return Curry._3(Editor.Decoration.decorate, editor, param[0], [param[1]]);
                }));
  };
  var addDirectly = function (self, highlightings) {
    self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
    
  };
  var addIndirectly = function (self, filepath) {
    self.tempFilePaths.push(filepath);
    
  };
  var readFile = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          
        }));
  var readAndParse = function (filepath) {
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (content) {
                  if (content.tag) {
                    return [];
                  }
                  var expressions = Parser$AgdaModeVscode.SExpression.parse(content[0].toString());
                  Belt_Array.keepMap(expressions, (function (error) {
                          if (error.tag) {
                            return error[0];
                          }
                          
                        }));
                  return Belt_Array.concatMany(Belt_Array.keepMap(expressions, (function (param) {
                                    if (param.tag) {
                                      return ;
                                    }
                                    var xs = param[0];
                                    if (xs.tag) {
                                      return Highlighting$AgdaModeVscode.parseIndirectHighlightings(xs[0]);
                                    } else {
                                      return [];
                                    }
                                  })));
                }));
  };
  var readTempFiles = function (self) {
    return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), Belt_Array.concatMany), (function (highlightings) {
                  self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
                  self.tempFilePaths = [];
                  
                }));
  };
  var applyHighlightings = function (self, editor) {
    var decorations = decorateHighlightings(editor, self.highlightings);
    self.highlightings = [];
    self.decorations = Belt_Array.concat(self.decorations, decorations);
    
  };
  return {
          decorateHole: decorateHole,
          decorateAspect: decorateAspect,
          decorateHighlighting: decorateHighlighting,
          computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
          decorateHighlightings: decorateHighlightings,
          make: make,
          destroy: destroy,
          refresh: refresh,
          addDirectly: addDirectly,
          addIndirectly: addIndirectly,
          readFile: readFile,
          readAndParse: readAndParse,
          readTempFiles: readTempFiles,
          applyHighlightings: applyHighlightings
        };
}

exports.Impl = Impl;
/* fs Not a pure module */
