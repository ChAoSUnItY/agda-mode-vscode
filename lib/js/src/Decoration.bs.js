// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function decorateHighlightings(editor, highlightings) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  var highlightings$1 = Belt_Array.map(highlightings, (function (highlighting) {
          var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.start);
          var end_ = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.end_);
          var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, [
                start,
                end_
              ]);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings$1, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  var srcLocs = Belt_Array.keepMap(highlightings$1, (function (param) {
          var range = param[0];
          return Belt_Option.map(param[2], (function (param) {
                        return {
                                range: range,
                                filepath: param[0],
                                offset: param[1]
                              };
                      }));
        }));
  var backgroundColorDict = {};
  var foregroundColorDict = {};
  var addFaceToDict = function (face, range) {
    if (face.TAG === /* Background */0) {
      var color = face._0;
      var ranges = Js_dict.get(backgroundColorDict, color);
      if (ranges !== undefined) {
        ranges.push(range);
      } else {
        backgroundColorDict[color] = [range];
      }
      return ;
    }
    var color$1 = face._0;
    var ranges$1 = Js_dict.get(foregroundColorDict, color$1);
    if (ranges$1 !== undefined) {
      ranges$1.push(range);
    } else {
      foregroundColorDict[color$1] = [range];
    }
    
  };
  Belt_Array.forEach(aspects, (function (param) {
          var range = param[1];
          var style = Highlighting$AgdaModeVscode.Aspect.toStyle(param[0]);
          if (!style) {
            return ;
          }
          var theme = VSCode.ColorTheme.kind(Vscode.window.activeColorTheme);
          if (theme === /* Dark */1) {
            return addFaceToDict(style._1, range);
          } else {
            return addFaceToDict(style._0, range);
          }
        }));
  var backgroundDecorations = Belt_Array.map(Js_dict.entries(backgroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.highlightBackgroundWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  var foregroundDecorations = Belt_Array.map(Js_dict.entries(foregroundColorDict), (function (param) {
          var ranges = param[1];
          return [
                  Editor$AgdaModeVscode.Decoration.decorateTextWithColor(editor, param[0], ranges),
                  ranges
                ];
        }));
  return [
          foregroundDecorations.concat(backgroundDecorations),
          srcLocs
        ];
}

function lines(doc, range) {
  var startingLine = range.start.line;
  var endingLine = range.end.line;
  var ranges = [];
  for(var i = startingLine; i <= endingLine; ++i){
    var startingPoint = i === startingLine ? range.start : new Vscode.Position(i, 0);
    var endingPoint;
    if (i === endingLine) {
      endingPoint = range.end;
    } else {
      var offset = doc.offsetAt(new Vscode.Position(i + 1 | 0, 0)) - 1 | 0;
      endingPoint = doc.positionAt(offset);
    }
    ranges.push(new Vscode.Range(startingPoint, endingPoint));
  }
  return ranges;
}

function make(param) {
  return {
          tempFilePaths: [],
          highlightings: [],
          decorations: [],
          srcLocs: []
        };
}

function clear(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Belt_Array.forEach(self.tempFilePaths, (function (format) {
          Fs.unlink(format._0, (function (param) {
                  
                }));
          
        }));
  self.tempFilePaths = [];
  self.highlightings = [];
  return clear(self);
}

function redecorate(self, editor) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addViaPipe(self, highlightings) {
  self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
  
}

function addViaFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 0,
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
  
}

function addViaJSONFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 1,
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
  
}

var readFile = Util.promisify(function (prim, prim$1) {
      Fs.readFile(prim, prim$1);
      
    });

function readAndParse(format) {
  if (format.TAG === /* Emacs */0) {
    var filepath = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var match = Belt_Array.get(Parser$AgdaModeVscode.SExpression.parse(x._0.toString()), 0);
                  var tokens;
                  if (match !== undefined) {
                    if (match.TAG === /* Ok */0) {
                      var xs = match._0;
                      tokens = xs.TAG === /* A */0 ? [] : xs._0;
                    } else {
                      tokens = [];
                    }
                  } else {
                    tokens = [];
                  }
                  var match$1 = Belt_Array.get(tokens, 0);
                  var keepHighlighting = match$1 !== undefined && match$1.TAG === /* A */0 && match$1._0 === "remove" ? false : true;
                  var infos = Belt_Array.keepMap(tokens.slice(1), Highlighting$AgdaModeVscode.parse);
                  return {
                          _0: keepHighlighting,
                          _1: infos,
                          [Symbol.for("name")]: "Infos"
                        };
                }));
  } else {
    var filepath$1 = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath$1))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var raw = x._0.toString();
                  var json;
                  try {
                    json = JSON.parse(raw);
                  }
                  catch (_e){
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  return Highlighting$AgdaModeVscode.Infos.decode(json);
                }));
  }
}

function readTempFiles(self) {
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), (function (xs) {
                    return Belt_Array.concatMany(Belt_Array.map(xs, Highlighting$AgdaModeVscode.Infos.toInfos));
                  })), (function (highlightings) {
                self.highlightings = Belt_Array.concat(self.highlightings, highlightings);
                self.tempFilePaths = [];
                
              }));
}

function apply(self, editor) {
  return $$Promise.map(readTempFiles(self), (function (param) {
                if (Config$AgdaModeVscode.Highlighting.getSemanticHighlighting(undefined)) {
                  return ;
                } else {
                  var match = decorateHighlightings(editor, self.highlightings);
                  self.highlightings = [];
                  self.srcLocs = match[1];
                  self.decorations = Belt_Array.concat(self.decorations, match[0]);
                  return ;
                }
              }));
}

function lookupSrcLoc(self, point) {
  return Belt_Option.map(Caml_option.undefined_to_opt(self.srcLocs.find(function (srcLoc) {
                      return srcLoc.range.contains(point);
                    })), (function (srcLoc) {
                return $$Promise.map(Vscode.workspace.openTextDocument(srcLoc.filepath), (function ($$document) {
                              var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                              var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                              var offset = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, srcLoc.offset - 1 | 0);
                              var position = Editor$AgdaModeVscode.Position.fromOffset($$document, offset);
                              return [[
                                        srcLoc.range,
                                        srcLoc.filepath,
                                        position
                                      ]];
                            }));
              }));
}

function generateSemanticTokens(self, editor, pushToken) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  var highlightings = Belt_Array.map(self.highlightings, (function (highlighting) {
          var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.start);
          var end_ = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, highlighting.end_);
          var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, [
                start,
                end_
              ]);
          return [
                  range,
                  highlighting.aspects,
                  highlighting.source
                ];
        }));
  var aspects = Belt_Array.concatMany(Belt_Array.map(highlightings, (function (param) {
              var range = param[0];
              return Belt_Array.map(param[1], (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  Belt_Array.forEach(aspects, (function (param) {
          var ranges = lines(editor.document, param[1]);
          var match = Highlighting$AgdaModeVscode.Aspect.toTokenTypeAndModifiers(param[0]);
          var tokenModifiers = match[1];
          var tokenType = match[0];
          return Belt_Array.forEach(ranges, (function (range) {
                        return Curry._3(pushToken, range, tokenType, tokenModifiers);
                      }));
        }));
  return $$Promise.resolved(undefined);
}

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  addViaPipe: addViaPipe,
  addViaFile: addViaFile,
  addViaJSONFile: addViaJSONFile,
  apply: apply,
  clear: clear,
  redecorate: redecorate,
  lookupSrcLoc: lookupSrcLoc,
  generateSemanticTokens: generateSemanticTokens
};

exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.addViaPipe = addViaPipe;
exports.addViaFile = addViaFile;
exports.addViaJSONFile = addViaJSONFile;
exports.apply = apply;
exports.clear = clear;
exports.redecorate = redecorate;
exports.lookupSrcLoc = lookupSrcLoc;
exports.generateSemanticTokens = generateSemanticTokens;
/* readFile Not a pure module */
