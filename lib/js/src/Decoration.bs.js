// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Util = require("util");
var Curry = require("rescript/lib/js/curry.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var IntervalTree = require("@flatten-js/interval-tree").default;
var IntervalTree$AgdaModeVscode = require("./Util/IntervalTree.bs.js");
var Highlighting__Agda$AgdaModeVscode = require("./Highlighting/Highlighting__Agda.bs.js");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Editor$AgdaModeVscode.$$Range.fromInterval($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function tagWithRange(editor, infos) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  return infos.map(function (info, param) {
              var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.start);
              var end_ = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.end_);
              var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, [
                    start,
                    end_
                  ]);
              return [
                      info,
                      range
                    ];
            });
}

function fromInfostoDecorations(infosWithRanges, editor) {
  var aspects = Belt_Array.concatMany(Belt_Array.map(IntervalTree$AgdaModeVscode.elems(infosWithRanges), (function (param) {
              var range = param[1];
              return Belt_Array.map(param[0].aspects, (function (aspect) {
                            return [
                                    aspect,
                                    range
                                  ];
                          }));
            })));
  console.log("aspects: ", Belt_Array.map(aspects, (function (param) {
              return Highlighting__Agda$AgdaModeVscode.Aspect.toString(param[0]);
            })));
  return Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.keepMap(aspects, (function (param) {
                    var range = param[1];
                    return Belt_Option.map(Highlighting__Decoration$AgdaModeVscode.fromAspect(param[0]), (function (x) {
                                  return [
                                          x,
                                          range
                                        ];
                                }));
                  })), editor);
}

function make(param) {
  var match = $$Promise.pending(undefined);
  return {
          tempFilePaths: [],
          infos: new IntervalTree(),
          infosWithRanges: new IntervalTree(),
          decorations: [],
          semanticTokens: match[0],
          resolveSemanticTokens: match[1]
        };
}

function clear(self) {
  Belt_Array.forEach(self.decorations, (function (param) {
          return Editor$AgdaModeVscode.Decoration.destroy(param[0]);
        }));
  self.decorations = [];
  
}

function destroy(self) {
  Belt_Array.forEach(self.tempFilePaths, (function (format) {
          Fs.unlink(format._0, (function (param) {
                  
                }));
          
        }));
  self.tempFilePaths = [];
  self.infos = new IntervalTree();
  return clear(self);
}

function redecorate(self, editor) {
  return Belt_Array.forEach(self.decorations, (function (param) {
                return Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
              }));
}

function addViaPipe(self, infos) {
  return Belt_Array.forEach(infos, (function (info) {
                var alreadyExists = self.infos.intersect_any([
                      info.start,
                      info.end_ - 1 | 0
                    ]);
                if (alreadyExists) {
                  console.log(info, Belt_Array.map(info.aspects, Highlighting__Agda$AgdaModeVscode.Aspect.toString));
                } else {
                  self.infos.insert([
                        info.start,
                        info.end_ - 1 | 0
                      ], info);
                }
                
              }));
}

function addViaFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 0,
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
  
}

function addViaJSONFile(self, filepath) {
  self.tempFilePaths.push({
        TAG: 1,
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
  
}

var readFile = Util.promisify(function (prim0, prim1) {
      Fs.readFile(prim0, prim1);
      
    });

function readAndParse(format) {
  if (format.TAG === /* Emacs */0) {
    var filepath = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var match = Belt_Array.get(Parser$AgdaModeVscode.SExpression.parse(x._0.toString()), 0);
                  var tokens;
                  if (match !== undefined) {
                    if (match.TAG === /* Ok */0) {
                      var xs = match._0;
                      tokens = xs.TAG === /* A */0 ? [] : xs._0;
                    } else {
                      tokens = [];
                    }
                  } else {
                    tokens = [];
                  }
                  var match$1 = Belt_Array.get(tokens, 0);
                  var keepHighlighting = match$1 !== undefined && match$1.TAG === /* A */0 && match$1._0 === "remove" ? false : true;
                  var infos = Belt_Array.keepMap(tokens.slice(1), Highlighting__Agda$AgdaModeVscode.Info.parse);
                  return {
                          _0: keepHighlighting,
                          _1: infos,
                          [Symbol.for("name")]: "Infos"
                        };
                }));
  } else {
    var filepath$1 = format._0;
    return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath$1))), (function (x) {
                  if (x.TAG !== /* Ok */0) {
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  var raw = x._0.toString();
                  var json;
                  try {
                    json = JSON.parse(raw);
                  }
                  catch (_e){
                    return {
                            _0: true,
                            _1: [],
                            [Symbol.for("name")]: "Infos"
                          };
                  }
                  return Highlighting__Agda$AgdaModeVscode.Infos.decode(json);
                }));
  }
}

function readTempFiles(self) {
  return $$Promise.map($$Promise.map($$Promise.allArray(Belt_Array.map(self.tempFilePaths, readAndParse)), (function (xs) {
                    return Belt_Array.concatMany(Belt_Array.map(xs, Highlighting__Agda$AgdaModeVscode.Infos.toInfos));
                  })), (function (infos) {
                addViaPipe(self, infos);
                self.tempFilePaths = [];
                
              }));
}

function lookupSrcLoc(self, offset) {
  var matched = self.infosWithRanges.search([
        offset - 1 | 0,
        offset
      ]);
  return Belt_Option.map(Belt_Option.flatMap(Belt_Array.get(matched, 0), (function (param) {
                    var range = param[1];
                    return Belt_Option.map(param[0].source, (function (param) {
                                  return [
                                          range,
                                          param[0],
                                          param[1]
                                        ];
                                }));
                  })), (function (param) {
                var offset = param[2];
                var filepath = param[1];
                var range = param[0];
                return $$Promise.map(Vscode.workspace.openTextDocument(filepath), (function ($$document) {
                              var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                              var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                              var offset$1 = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, offset - 1 | 0);
                              var position = Editor$AgdaModeVscode.Position.fromOffset($$document, offset$1);
                              return [[
                                        range,
                                        filepath,
                                        position
                                      ]];
                            }));
              }));
}

function classify(change, token) {
  var removedRange = change.range;
  var regex = /\r\n|\r|\n/;
  var lines = change.text.split(regex);
  var lineDetalOfRemovedRange = removedRange.end.line - removedRange.start.line | 0;
  var lineDelta = (lines.length - 1 | 0) - lineDetalOfRemovedRange | 0;
  var match;
  if (lineDelta > 0) {
    match = [
      lineDelta,
      -removedRange.end.character | 0
    ];
  } else if (lineDelta < 0) {
    var columnDelta = removedRange.end.character - removedRange.start.character | 0;
    match = [
      lineDelta,
      -columnDelta | 0
    ];
  } else {
    var columnDeltaOfRemovedRange = removedRange.end.character - removedRange.start.character | 0;
    var match$1 = Belt_Array.get(lines, lineDelta);
    var columnDelta$1;
    if (match$1 !== undefined) {
      var line = Caml_option.valFromOption(match$1);
      columnDelta$1 = line !== undefined ? line.length - columnDeltaOfRemovedRange | 0 : 0;
    } else {
      columnDelta$1 = 0;
    }
    match = [
      0,
      columnDelta$1
    ];
  }
  var lineDelta$1 = match[0];
  var tokenRange = Curry._1(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange, token.range);
  if (tokenRange.end.isBeforeOrEqual(removedRange.start)) {
    return /* NoOp */0;
  } else if (removedRange.contains(tokenRange) || tokenRange.start.isBefore(removedRange.start) && tokenRange.end.isAfter(removedRange.end)) {
    return /* Remove */1;
  } else if (token.range.line === removedRange.end.line) {
    return {
            TAG: 0,
            _0: lineDelta$1,
            _1: match[1],
            [Symbol.for("name")]: "Move"
          };
  } else {
    return {
            TAG: 1,
            _0: lineDelta$1,
            [Symbol.for("name")]: "MoveLinesOnly"
          };
  }
}

function update(self, $$event) {
  var changes = $$event.contentChanges;
  var applyChange = function (tokens, change) {
    return Belt_Array.concatMany(Belt_Array.map(tokens, (function (token) {
                      var action = classify(change, token);
                      if (typeof action === "number") {
                        if (action === /* NoOp */0) {
                          return [token];
                        } else {
                          return [];
                        }
                      }
                      if (action.TAG !== /* Move */0) {
                        return [{
                                  range: {
                                    line: token.range.line + action._0 | 0,
                                    column: token.range.column
                                  },
                                  type_: token.type_,
                                  modifiers: token.modifiers
                                }];
                      }
                      var columnDelta = action._1;
                      return [{
                                range: {
                                  line: token.range.line + action._0 | 0,
                                  column: [
                                    token.range.column[0] + columnDelta | 0,
                                    token.range.column[1] + columnDelta | 0
                                  ]
                                },
                                type_: token.type_,
                                modifiers: token.modifiers
                              }];
                    })));
  };
  return $$Promise.get(self.semanticTokens, (function (semanticTokensRef) {
                Belt_Array.forEach(changes, (function (change) {
                        semanticTokensRef.contents = applyChange(semanticTokensRef.contents, change);
                        
                      }));
                return Curry._1(self.resolveSemanticTokens, semanticTokensRef);
              }));
}

function get(self) {
  return self.semanticTokens;
}

function toSemanticTokensAndDecorations(self, editor) {
  var match = Belt_Array.unzip(Belt_Array.keepMap(Belt_Array.concatMany(Belt_Array.map(IntervalTree$AgdaModeVscode.elems(self.infosWithRanges), (function (param) {
                      var info = param[0];
                      var ranges = Curry._2(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange, editor.document, param[1]);
                      return Belt_Array.map(ranges, (function (range) {
                                    return [
                                            info.aspects,
                                            range
                                          ];
                                  }));
                    }))), (function (param) {
              var range = param[1];
              var match = Belt_Array.unzip(Belt_Array.map(param[0], Highlighting__SemanticToken$AgdaModeVscode.fromAspect));
              var match$1 = Belt_Array.unzip(match[0]);
              var tokenTypes = Belt_Array.keepMap(match$1[0], (function (x) {
                      return x;
                    }));
              var tokenModifiers = Belt_Array.concatMany(match$1[1]);
              var backgrounds = Belt_Array.keepMap(match[1], (function (x) {
                      return Belt_Option.map(x, (function (x) {
                                    return [
                                            x,
                                            Curry._1(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange, range)
                                          ];
                                  }));
                    }));
              var token = Belt_Option.map(Belt_Array.get(tokenTypes, 0), (function (tokenType) {
                      return {
                              range: range,
                              type_: tokenType,
                              modifiers: tokenModifiers
                            };
                    }));
              return [
                      token,
                      backgrounds
                    ];
            })));
  var tokens = Belt_Array.keepMap(match[0], (function (x) {
          return x;
        }));
  var backgrounds = Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Belt_Array.concatMany(match[1]), editor);
  return [
          tokens,
          backgrounds
        ];
}

function applyAndClear(self, editor) {
  return $$Promise.map(readTempFiles(self), (function (param) {
                self.infosWithRanges = tagWithRange(editor, self.infos);
                if (Config$AgdaModeVscode.Highlighting.getSemanticHighlighting(undefined)) {
                  var match = toSemanticTokensAndDecorations(self, editor);
                  var tokens = match[0];
                  self.decorations = Belt_Array.concat(self.decorations, match[1]);
                  if (tokens.length === 0) {
                    var match$1 = $$Promise.pending(undefined);
                    self.semanticTokens = match$1[0];
                    self.resolveSemanticTokens = match$1[1];
                  } else {
                    Curry._1(self.resolveSemanticTokens, {
                          contents: tokens
                        });
                    $$Promise.get(self.semanticTokens, (function (semanticTokensRef) {
                            semanticTokensRef.contents = tokens;
                            
                          }));
                  }
                } else {
                  var decorations = fromInfostoDecorations(self.infosWithRanges, editor);
                  self.decorations = Belt_Array.concat(self.decorations, decorations);
                }
                self.infos = new IntervalTree();
                
              }));
}

var Module_SemanticHighlighting = {
  update: update,
  get: get,
  toSemanticTokensAndDecorations: toSemanticTokensAndDecorations
};

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  addViaPipe: addViaPipe,
  addViaFile: addViaFile,
  addViaJSONFile: addViaJSONFile,
  applyAndClear: applyAndClear,
  clear: clear,
  redecorate: redecorate,
  lookupSrcLoc: lookupSrcLoc,
  SemanticHighlighting: Module_SemanticHighlighting
};

var SemanticHighlighting = Module_SemanticHighlighting;

exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.addViaPipe = addViaPipe;
exports.addViaFile = addViaFile;
exports.addViaJSONFile = addViaJSONFile;
exports.applyAndClear = applyAndClear;
exports.clear = clear;
exports.redecorate = redecorate;
exports.lookupSrcLoc = lookupSrcLoc;
exports.SemanticHighlighting = SemanticHighlighting;
/* readFile Not a pure module */
