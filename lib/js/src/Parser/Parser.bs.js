// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Path = require("path");
var Curry = require("rescript/lib/js/curry.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function split(s) {
  return Belt_Array.keepMap(Belt_Array.map(Js_string.splitByRe(/\\r\\n|\\n/, s), (function (x) {
                    if (x !== undefined && x !== "") {
                      return x;
                    }
                    
                  })), (function (x) {
                return x;
              }));
}

function map(f, x) {
  if (x) {
    return {
            _0: Curry._1(f, x._0),
            [Symbol.for("name")]: "Yield"
          };
  } else {
    return /* Stop */0;
  }
}

function tap(f, x) {
  if (!x) {
    return /* Stop */0;
  }
  var x$1 = x._0;
  Curry._1(f, x$1);
  return {
          _0: x$1,
          [Symbol.for("name")]: "Yield"
        };
}

function flatMap(f, x) {
  if (x) {
    return Curry._1(f, x._0);
  } else {
    return /* Stop */0;
  }
}

var Gen = {
  map: map,
  tap: tap,
  flatMap: flatMap
};

function make(initialContinuation, callback) {
  return {
          initialContinuation: initialContinuation,
          continuation: {
            contents: undefined
          },
          callback: callback
        };
}

function feed(self, input) {
  var $$continue = Belt_Option.getWithDefault(self.continuation.contents, self.initialContinuation);
  var err = Curry._1($$continue, input);
  switch (err.TAG | 0) {
    case /* Error */0 :
        return Curry._1(self.callback, {
                    _0: {
                      TAG: 1,
                      _0: err._0,
                      [Symbol.for("name")]: "Error"
                    },
                    [Symbol.for("name")]: "Yield"
                  });
    case /* Continue */1 :
        self.continuation.contents = err._0;
        return ;
    case /* Done */2 :
        Curry._1(self.callback, {
              _0: {
                TAG: 0,
                _0: err._0,
                [Symbol.for("name")]: "Ok"
              },
              [Symbol.for("name")]: "Yield"
            });
        self.continuation.contents = undefined;
        return ;
    
  }
}

function stop(self) {
  Curry._1(self.callback, /* Stop */0);
}

var Incr = {
  Gen: Gen,
  make: make,
  feed: feed,
  stop: stop
};

function toString(x) {
  if (x.TAG === /* A */0) {
    return "\"" + (x._0 + "\"");
  } else {
    return "[" + (Js_array.joinWith(", ", Belt_Array.map(x._0, toString)) + "]");
  }
}

function preprocess(string) {
  if (Js_string.substring(0, 13, string) === "cannot read: ") {
    return {
            TAG: 1,
            _0: Js_string.sliceToEnd(12, string),
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: string,
            [Symbol.for("name")]: "Ok"
          };
  }
}

function flatten(x) {
  if (x.TAG === /* A */0) {
    return [x._0];
  } else {
    return Belt_Array.concatMany(Belt_Array.map(x._0, flatten));
  }
}

function parseWithContinuation(string) {
  var parseSExpression = function (state, string) {
    var in_str = state.in_str;
    var escaped = state.escaped;
    var word = state.word;
    var stack = state.stack;
    var pushToTheTop = function (elem) {
      var index = stack.length - 1 | 0;
      var expr = Belt_Array.get(stack, index);
      if (expr === undefined) {
        return ;
      }
      var xs = expr.contents;
      if (xs.TAG === /* A */0) {
        expr.contents = {
          TAG: 1,
          _0: [
            expr.contents,
            elem
          ],
          [Symbol.for("name")]: "L"
        };
        return ;
      }
      Js_array.push(elem, xs._0);
    };
    var totalLength = string.length;
    for(var i = 0; i < totalLength; ++i){
      var $$char = Js_string.charAt(i, string);
      if (escaped.contents) {
        if ($$char === "n") {
          word.contents = word.contents + "\\";
        }
        word.contents = word.contents + $$char;
        escaped.contents = false;
      } else if (!($$char === "\'" && !in_str.contents)) {
        if ($$char === "(" && !in_str.contents) {
          Js_array.push({
                contents: {
                  TAG: 1,
                  _0: [],
                  [Symbol.for("name")]: "L"
                }
              }, stack);
        } else if ($$char === ")" && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop({
                  TAG: 0,
                  _0: word.contents,
                  [Symbol.for("name")]: "A"
                });
            word.contents = "";
          }
          var expr = stack.pop();
          if (expr !== undefined) {
            pushToTheTop(expr.contents);
          }
          
        } else if ($$char === " " && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop({
                  TAG: 0,
                  _0: word.contents,
                  [Symbol.for("name")]: "A"
                });
            word.contents = "";
          }
          
        } else if ($$char === "\"") {
          in_str.contents = !in_str.contents;
        } else if ($$char === "\\" && in_str.contents) {
          escaped.contents = true;
        } else {
          word.contents = word.contents + $$char;
        }
      }
      
    }
    var match = stack.length;
    if (match === 0) {
      return {
              TAG: 0,
              _0: [
                0,
                string
              ],
              [Symbol.for("name")]: "Error"
            };
    }
    if (match !== 1) {
      return {
              TAG: 1,
              _0: (function (param) {
                  return parseSExpression(state, param);
                }),
              [Symbol.for("name")]: "Continue"
            };
    }
    var v = Belt_Array.get(stack, 0);
    if (v === undefined) {
      return {
              TAG: 0,
              _0: [
                1,
                string
              ],
              [Symbol.for("name")]: "Error"
            };
    }
    var xs = v.contents;
    if (xs.TAG === /* A */0) {
      return {
              TAG: 0,
              _0: [
                3,
                string
              ],
              [Symbol.for("name")]: "Error"
            };
    }
    var w = Belt_Array.get(xs._0, 0);
    if (w !== undefined) {
      return {
              TAG: 2,
              _0: w,
              [Symbol.for("name")]: "Done"
            };
    } else {
      return {
              TAG: 1,
              _0: (function (param) {
                  return parseSExpression(state, param);
                }),
              [Symbol.for("name")]: "Continue"
            };
    }
  };
  var initialState = function (param) {
    return {
            stack: [{
                contents: {
                  TAG: 1,
                  _0: [],
                  [Symbol.for("name")]: "L"
                }
              }],
            word: {
              contents: ""
            },
            escaped: {
              contents: false
            },
            in_str: {
              contents: false
            }
          };
  };
  var processed = preprocess(string);
  if (processed.TAG === /* Ok */0) {
    return parseSExpression(initialState(undefined), processed._0);
  } else {
    return {
            TAG: 0,
            _0: [
              4,
              string
            ],
            [Symbol.for("name")]: "Error"
          };
  }
}

function parse(input) {
  var resultAccum = {
    contents: []
  };
  var continuation = {
    contents: undefined
  };
  Belt_Array.forEach(split(input), (function (line) {
          var $$continue = Belt_Option.getWithDefault(continuation.contents, parseWithContinuation);
          var err = Curry._1($$continue, line);
          switch (err.TAG | 0) {
            case /* Error */0 :
                Js_array.push({
                      TAG: 1,
                      _0: err._0,
                      [Symbol.for("name")]: "Error"
                    }, resultAccum.contents);
                return ;
            case /* Continue */1 :
                continuation.contents = err._0;
                return ;
            case /* Done */2 :
                Js_array.push({
                      TAG: 0,
                      _0: err._0,
                      [Symbol.for("name")]: "Ok"
                    }, resultAccum.contents);
                continuation.contents = undefined;
                return ;
            
          }
        }));
  return resultAccum.contents;
}

function makeIncr(callback) {
  return make(parseWithContinuation, callback);
}

var SExpression = {
  toString: toString,
  preprocess: preprocess,
  flatten: flatten,
  parseWithContinuation: parseWithContinuation,
  parse: parse,
  makeIncr: makeIncr
};

function toString$1(x) {
  if (x.TAG === /* SExpression */0) {
    return "Something went wrong when parsing S-expressions. Error code: S" + (String(x._0) + (" \"" + (x._1 + "\"")));
  } else {
    return "Perhaps the underlying protocol used by Agda for communicating with agda-mode has changed.\nPlease report which version of Agda you are using.\nError code: R" + (String(x._0) + (" \"" + (toString(x._1) + "\"")));
  }
}

var $$Error = {
  toString: toString$1
};

function userInput(s) {
  return Js_string.replaceByRe(/\\n/g, "\\n", Js_string.replaceByRe(/\\\"/g, "\\\"", Js_string.replaceByRe(/\\\\/g, "\\\\", s))).trim();
}

function filepath(s) {
  var removedBidi = Js_string.charCodeAt(0, s) === 8234.0 ? Js_string.sliceToEnd(1, s) : s;
  var normalized = Path.normalize(removedBidi);
  return Js_string.replaceByRe(/\\\\/g, "/", normalized);
}

var partial_arg = /\\\\n/g;

function agdaOutput(param) {
  return Js_string.replaceByRe(partial_arg, "\n", param);
}

function commandLineArgs(s) {
  return Js_string.split(" ", Js_string.replaceByRe(/\\s+/g, " ", s));
}

exports.split = split;
exports.Incr = Incr;
exports.SExpression = SExpression;
exports.$$Error = $$Error;
exports.userInput = userInput;
exports.filepath = filepath;
exports.agdaOutput = agdaOutput;
exports.commandLineArgs = commandLineArgs;
/* path Not a pure module */
