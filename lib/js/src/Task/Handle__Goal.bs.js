// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");

function getOffsets(state) {
  return Belt_Array.map(state.goals, (function (goal) {
                return goal.range[0] + 3 | 0;
              }));
}

function pointingAt(cursor, state) {
  var cursor$1 = cursor !== undefined ? Caml_option.valFromOption(cursor) : Editor$AgdaModeVscode.Cursor.get(state.editor);
  var cursorOffset = state.editor.document.offsetAt(cursor$1);
  var pointedGoals = Belt_Array.keep(state.goals, (function (goal) {
          if (goal.range[0] <= cursorOffset) {
            return cursorOffset <= goal.range[1];
          } else {
            return false;
          }
        }));
  return Belt_Array.get(pointedGoals, 0);
}

function caseSplitAux($$document, goal) {
  var start = $$document.positionAt(0);
  var end_ = $$document.positionAt(goal.range[0]);
  var range = new Vscode.Range(start, end_);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var nextWordBoundary = function (start, string) {
    var $$break = false;
    var n = 0;
    var i = start;
    while(i < string.length && !$$break) {
      var $$char = string.charAt(i);
      switch ($$char) {
        case "\t" :
        case "\f" :
        case " " :
            n = n + 1 | 0;
            break;
        default:
          $$break = true;
      }
      i = i + 1 | 0;
    };
    return start + n | 0;
  };
  var bracketCount = 0;
  var i = goal.range[0] - 1 | 0;
  while(i >= 0 && bracketCount >= 0) {
    var i$prime = i;
    if (i$prime !== 0) {
      var match = textBeforeGoal.charAt(i$prime - 1 | 0);
      switch (match) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var lastOpenCurlyBracketOffset = i + 1 | 0;
  var n = textBeforeGoal.lastIndexOf(";");
  var lastSemicolonOffset = (
    n !== -1 ? n : 0
  ) + 1 | 0;
  var n$1 = textBeforeGoal.lastIndexOf("where");
  var lastWhereTokenOffset = (
    n$1 !== -1 ? n$1 : 0
  ) + 5 | 0;
  var lastLineBreakOffset = Caml_primitive.caml_int_max(0, Caml_primitive.caml_int_max(textBeforeGoal.lastIndexOf("\r"), textBeforeGoal.lastIndexOf("\n"))) + 1 | 0;
  var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
  var offset = Caml_primitive.caml_int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
  var caseStart = nextWordBoundary(offset, textBeforeGoal);
  var caseEnd = goal.range[1];
  var range$1 = [
    caseStart,
    caseEnd
  ];
  return [
          inWhereClause,
          caseStart - lastLineBreakOffset | 0,
          range$1
        ];
}

function indentationWidth($$document, goal) {
  var goalStart = $$document.positionAt(goal.range[0]);
  var lineNo = goalStart.line;
  var range = new Vscode.Range(new Vscode.Position(lineNo, 0), goalStart);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var indentedBy = function (s) {
    var n = 0;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = s.charAt(i);
      var exit = 0;
      switch (match) {
        case "\t" :
        case "\n" :
        case "\f" :
        case " " :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1 && i === n) {
        n = n + 1 | 0;
      }
      
    }
    return n;
  };
  return [
          indentedBy(textBeforeGoal),
          textBeforeGoal,
          range
        ];
}

function jumpToOffset(state, offset) {
  var $$document = state.editor.document;
  var point = $$document.positionAt(offset);
  var range = new Vscode.Range(point, point);
  return Editor$AgdaModeVscode.reveal(state.editor, range);
}

function setCursor(state, offset) {
  var point = state.editor.document.positionAt(offset - 1 | 0);
  return Editor$AgdaModeVscode.Cursor.set(state.editor, point);
}

function updateRanges(state) {
  return Goal$AgdaModeVscode.updateRanges(state.goals, state.editor.document);
}

function modify(state, goal, f) {
  updateRanges(state);
  var $$document = state.editor.document;
  var content = Goal$AgdaModeVscode.getContent(goal, $$document);
  return $$Promise.flatMap(Goal$AgdaModeVscode.setContent(goal, $$document, Curry._1(f, content)), (function (x) {
                if (x) {
                  return $$Promise.resolved(undefined);
                } else {
                  return Task$AgdaModeVscode.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, {
                              TAG: 0,
                              _0: "Failed to modify the content of goal #" + String(goal.index),
                              [Symbol.for("name")]: "Plain"
                            });
                }
              }));
}

function next(state) {
  updateRanges(state);
  var $$document = state.editor.document;
  var nextGoal = {
    contents: undefined
  };
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  Belt_Array.forEach(offsets, (function (offset) {
          if (cursorOffset < offset && nextGoal.contents === undefined) {
            nextGoal.contents = offset;
            return ;
          }
          
        }));
  if (nextGoal.contents === undefined) {
    nextGoal.contents = Belt_Array.get(offsets, 0);
  }
  var offset = nextGoal.contents;
  if (offset === undefined) {
    return $$Promise.resolved(undefined);
  }
  var point = $$document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
  return $$Promise.resolved(undefined);
}

function previous(state) {
  updateRanges(state);
  var $$document = state.editor.document;
  var previousGoal = {
    contents: undefined
  };
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  Belt_Array.forEach(offsets, (function (offset) {
          if (cursorOffset > offset) {
            previousGoal.contents = offset;
            return ;
          }
          
        }));
  if (previousGoal.contents === undefined) {
    previousGoal.contents = Belt_Array.get(offsets, offsets.length - 1 | 0);
  }
  var offset = previousGoal.contents;
  if (offset === undefined) {
    return $$Promise.resolved(undefined);
  }
  var point = $$document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
  return $$Promise.resolved(undefined);
}

function instantiate(state, indices) {
  Belt_Array.forEach(state.goals, Goal$AgdaModeVscode.destroy);
  return $$Promise.map(Goal$AgdaModeVscode.makeMany(state.editor, indices), (function (goals) {
                state.goals = goals;
                
              }));
}

function $$case(state, localWithContent, localEmpty, $$global) {
  updateRanges(state);
  var $$document = state.editor.document;
  var goal = pointingAt(undefined, state);
  if (goal === undefined) {
    return $$global;
  }
  var content = Goal$AgdaModeVscode.getContent(goal, $$document);
  if (content === "") {
    return Curry._1(localEmpty, goal);
  } else {
    return Curry._2(localWithContent, goal, content);
  }
}

function caseSimple(state, local, $$global) {
  updateRanges(state);
  var goal = pointingAt(undefined, state);
  if (goal !== undefined) {
    return Curry._1(local, goal);
  } else {
    return $$global;
  }
}

function replaceWithLambda(state, goal, lines) {
  var $$document = state.editor.document;
  var match = caseSplitAux($$document, goal);
  var rewriteRange = match[2];
  var indentWidth = match[1];
  var rewriteText = match[0] ? lines.join("\n" + " ".repeat(indentWidth)) : lines.join("\n" + (" ".repeat(indentWidth - 2 | 0) + "; "));
  var rewriteRange$1 = new Vscode.Range($$document.positionAt(rewriteRange[0]), $$document.positionAt(rewriteRange[1]));
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace($$document, rewriteRange$1, rewriteText), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  return $$Promise.resolved(undefined);
                } else {
                  return Task$AgdaModeVscode.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, {
                              TAG: 0,
                              _0: "Unable to replace the lines of goal #" + String(goal.index),
                              [Symbol.for("name")]: "Plain"
                            });
                }
              }));
}

function replaceWithLines(state, goal, lines) {
  var $$document = state.editor.document;
  var match = indentationWidth($$document, goal);
  var indentation = " ".repeat(match[0]);
  var indentedLines = indentation + lines.join("\n" + indentation);
  var start = $$document.positionAt(goal.range[0]);
  var startLineNo = start.line;
  var startLineRange = $$document.lineAt(startLineNo).range;
  var start$1 = startLineRange.start;
  var end_ = $$document.positionAt(goal.range[1]);
  var rangeToBeReplaced = new Vscode.Range(start$1, end_);
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace($$document, rangeToBeReplaced, indentedLines), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  return $$Promise.resolved(undefined);
                } else {
                  return Task$AgdaModeVscode.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, {
                              TAG: 0,
                              _0: "Unable to replace the lines of goal #" + String(goal.index),
                              [Symbol.for("name")]: "Plain"
                            });
                }
              }));
}

function removeBoundaryAndDestroy(state, goal) {
  updateRanges(state);
  var $$document = state.editor.document;
  var innerRange = Goal$AgdaModeVscode.getInnerRange(goal, $$document);
  var outerRange = new Vscode.Range($$document.positionAt(goal.range[0]), $$document.positionAt(goal.range[1]));
  var content = $$String.trim(Editor$AgdaModeVscode.$$Text.get($$document, innerRange));
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace($$document, outerRange, content), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  return $$Promise.resolved(undefined);
                } else {
                  return Task$AgdaModeVscode.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, {
                              TAG: 0,
                              _0: "Unable to remove the boundary of goal #" + String(goal.index),
                              [Symbol.for("name")]: "Plain"
                            });
                }
              }));
}

var VSRange;

exports.VSRange = VSRange;
exports.getOffsets = getOffsets;
exports.pointingAt = pointingAt;
exports.caseSplitAux = caseSplitAux;
exports.indentationWidth = indentationWidth;
exports.jumpToOffset = jumpToOffset;
exports.setCursor = setCursor;
exports.updateRanges = updateRanges;
exports.modify = modify;
exports.next = next;
exports.previous = previous;
exports.instantiate = instantiate;
exports.$$case = $$case;
exports.caseSimple = caseSimple;
exports.replaceWithLambda = replaceWithLambda;
exports.replaceWithLines = replaceWithLines;
exports.removeBoundaryAndDestroy = removeBoundaryAndDestroy;
/* vscode Not a pure module */
