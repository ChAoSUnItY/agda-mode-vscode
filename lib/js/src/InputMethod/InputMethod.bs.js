// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var Buffer2$AgdaModeVscode = require("./Buffer2.bs.js");

function Impl(Editor) {
  var Buffer2 = Buffer2$AgdaModeVscode.Impl(Editor);
  var log = function (param) {
    
  };
  var make = function (editor, offset) {
    var point = Curry._2(Editor.pointAtOffset, editor, offset);
    return {
            range: /* tuple */[
              offset,
              offset
            ],
            decoration: Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, point, point)),
            buffer: Curry._1(Buffer2.make, undefined)
          };
  };
  var withIn = function (instance, offset) {
    var match = instance.range;
    if (match[0] <= offset) {
      return offset <= match[1];
    } else {
      return false;
    }
  };
  var redocorate = function (instance, editor) {
    Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
    var match = instance.range;
    var start = Curry._2(Editor.pointAtOffset, editor, match[0]);
    var end_ = Curry._2(Editor.pointAtOffset, editor, match[1]);
    instance.decoration = Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, start, end_));
    
  };
  var destroy = function (instance) {
    Curry._1(log, "KILLED");
    return Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
  };
  var Instance = {
    make: make,
    withIn: withIn,
    redocorate: redocorate,
    destroy: destroy
  };
  var insertBackslash = function (editor) {
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, editor, point, "\\");
                  
                }));
  };
  var activate = function (self, editor, offsets) {
    self.instances = Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (param) {
            return make(editor, param);
          }));
    var editorChangeHandle = {
      contents: undefined
    };
    var cursorChangeHandle = {
      contents: undefined
    };
    var validate = function (points) {
      var offsets = Belt_Array.map(points, Curry._1(Editor.offsetAtPoint, editor));
      Curry._1(log, "\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                        return String(prim);
                      }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, (function (i) {
                          return "(" + (String(i.range[0]) + (", " + (String(i.range[1]) + ")")));
                        }))))));
      self.instances = Belt_Array.keep(self.instances, (function (instance) {
              var survived = Belt_Array.some(offsets, (function (param) {
                      return withIn(instance, param);
                    }));
              if (!survived) {
                destroy(instance);
              }
              return survived;
            }));
      self.cursorsToBeChecked = undefined;
      if (self.instances.length === 0) {
        Curry._1(log, "ALL DEAD");
        Curry._1(self.onAction.emit, /* Deactivate */1);
        Belt_Option.forEach(editorChangeHandle.contents, Editor.Disposable.dispose);
        return Belt_Option.forEach(cursorChangeHandle.contents, Editor.Disposable.dispose);
      }
      
    };
    var applyRewrite = function (rewrites) {
      var go = function (accum, param) {
        if (!param) {
          return $$Promise.resolved(undefined);
        }
        var rewrites = param[1];
        var match = param[0];
        var instance = match.instance;
        var rewriteWith = match.rewriteWith;
        var end_ = match.end_;
        var start = match.start;
        var range = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, start + accum | 0), Curry._2(Editor.pointAtOffset, editor, end_ + accum | 0));
        var delta = rewriteWith.length - (end_ - start | 0) | 0;
        Curry._1(log, "!!! " + (rewriteWith + (" (" + (String(accum + start | 0) + ("," + (String(accum + end_ | 0) + (") => (" + (String(accum + start | 0) + ("," + (String((accum + end_ | 0) + delta | 0) + (") " + String(accum))))))))))));
        instance.range = /* tuple */[
          accum + start | 0,
          (accum + end_ | 0) + delta | 0
        ];
        var accum$1 = accum + delta | 0;
        return $$Promise.flatMap($$Promise.flatMap(Curry._2(Editor.deleteText, editor, range), (function (param) {
                          return Curry._3(Editor.insertText, editor, Curry._1(Editor.$$Range.start, range), rewriteWith);
                        })), (function (param) {
                      redocorate(instance, editor);
                      return go(accum$1, rewrites);
                    }));
      };
      return go(0, Belt_List.fromArray(rewrites));
    };
    cursorChangeHandle.contents = Caml_option.some(Curry._1(Editor.onChangeCursorPosition, (function (points) {
                if (self.busy) {
                  self.cursorsToBeChecked = points;
                  return ;
                } else {
                  return validate(points);
                }
              })));
    editorChangeHandle.contents = Caml_option.some(Curry._1(Editor.onChange, (function (changes) {
                if (!self.busy && changes.length !== 0) {
                  self.busy = true;
                  var changes$1 = changes.sort((function (x, y) {
                          return Caml_primitive.caml_int_compare(x.offset, y.offset);
                        }));
                  var rewrites = [];
                  var go = function (_accum, _param) {
                    while(true) {
                      var param = _param;
                      var accum = _accum;
                      var match = param[0];
                      if (match) {
                        var match$1 = param[1];
                        if (!match$1) {
                          return /* [] */0;
                        }
                        var is = match$1[1];
                        var instance = match$1[0];
                        var cs = match[1];
                        var change = match[0];
                        var match$2 = instance.range;
                        var end_ = match$2[1];
                        var start = match$2[0];
                        var delta = change.insertText.length - change.replaceLength | 0;
                        if (withIn(instance, change.offset)) {
                          var next = Curry._3(Buffer2.update, instance.range[0], instance.buffer, change);
                          if (typeof next === "number") {
                            if (next === /* Noop */0) {
                              instance.range = /* tuple */[
                                accum + start | 0,
                                (accum + end_ | 0) + delta | 0
                              ];
                              return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                        instance,
                                        go(accum + delta | 0, /* tuple */[
                                              cs,
                                              is
                                            ])
                                      ]);
                            }
                            destroy(instance);
                            _param = /* tuple */[
                              cs,
                              is
                            ];
                            _accum = accum + delta | 0;
                            continue ;
                          } else {
                            if (next.tag) {
                              rewrites.push({
                                    start: accum + start | 0,
                                    end_: (accum + end_ | 0) + delta | 0,
                                    rewriteWith: next[1],
                                    instance: instance
                                  });
                              instance.buffer = next[0];
                              instance.range = /* tuple */[
                                accum + start | 0,
                                (accum + end_ | 0) + delta | 0
                              ];
                              return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                        instance,
                                        go(accum + delta | 0, /* tuple */[
                                              cs,
                                              is
                                            ])
                                      ]);
                            }
                            instance.buffer = next[0];
                            instance.range = /* tuple */[
                              accum + start | 0,
                              (accum + end_ | 0) + delta | 0
                            ];
                            return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                      instance,
                                      go(accum + delta | 0, /* tuple */[
                                            cs,
                                            is
                                          ])
                                    ]);
                          }
                        } else {
                          if (change.offset < instance.range[0]) {
                            _param = /* tuple */[
                              cs,
                              /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                  instance,
                                  is
                                ])
                            ];
                            _accum = accum + delta | 0;
                            continue ;
                          }
                          instance.range = /* tuple */[
                            accum + start | 0,
                            accum + end_ | 0
                          ];
                          return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                    instance,
                                    go(accum, /* tuple */[
                                          /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                              change,
                                              cs
                                            ]),
                                          is
                                        ])
                                  ]);
                        }
                      } else {
                        var match$3 = param[1];
                        if (match$3) {
                          return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                    match$3[0],
                                    match$3[1]
                                  ]);
                        } else {
                          return /* [] */0;
                        }
                      }
                    };
                  };
                  self.instances = Belt_List.toArray(go(0, /* tuple */[
                            Belt_List.fromArray(changes$1),
                            Belt_List.fromArray(self.instances)
                          ]));
                  return $$Promise.get(rewrites.length !== 0 ? applyRewrite(rewrites) : $$Promise.resolved(undefined), (function (param) {
                                self.busy = false;
                                var points = self.cursorsToBeChecked;
                                if (points !== undefined) {
                                  return validate(points);
                                }
                                
                              }));
                }
                
              })));
    
  };
  var make$1 = function (param) {
    return {
            onAction: Event$AgdaModeVscode.make(undefined),
            instances: [],
            activated: false,
            cursorsToBeChecked: undefined,
            busy: false
          };
  };
  return {
          Buffer2: Buffer2,
          printLog: false,
          log: log,
          Instance: Instance,
          insertBackslash: insertBackslash,
          activate: activate,
          make: make$1
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
