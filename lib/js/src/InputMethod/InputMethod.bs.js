// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var Buffer2$AgdaModeVscode = require("./Buffer2.bs.js");

function Impl(Editor) {
  var Buffer2 = Buffer2$AgdaModeVscode.Impl(Editor);
  var make = function (editor, offset) {
    var point = Curry._2(Editor.pointAtOffset, editor, offset);
    return {
            range: /* tuple */[
              offset,
              offset
            ],
            decoration: Curry._2(Editor.Decoration.underlineText, editor, Curry._2(Editor.$$Range.make, point, point)),
            buffer: Curry._1(Buffer2.make, undefined)
          };
  };
  var withIn = function (instance, offset) {
    var match = instance.range;
    if (match[0] <= offset) {
      return offset <= match[1];
    } else {
      return false;
    }
  };
  var destroy = function (instance) {
    console.log("KILLED");
    return Belt_Array.forEach(instance.decoration, Editor.Decoration.destroy);
  };
  var Instance = {
    make: make,
    withIn: withIn,
    destroy: destroy
  };
  var insertBackslash = function (editor) {
    return Belt_Array.forEach(Curry._1(Editor.getCursorPositions, editor), (function (point) {
                  Curry._3(Editor.insertText, editor, point, "\\");
                  
                }));
  };
  var activate = function (self, editor, offsets) {
    console.log("locked: " + Pervasives.string_of_bool(self.lock));
    self.instances = Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (param) {
            return make(editor, param);
          }));
    var editorChangeHandle = {
      contents: undefined
    };
    var cursorChangeHandle = {
      contents: undefined
    };
    var checkIfEveryoneIsStillAlive = function (param) {
      if (self.instances.length === 0) {
        console.log("ALL DEAD");
        Curry._1(self.onAction.emit, /* Deactivate */1);
        Belt_Option.forEach(editorChangeHandle.contents, Editor.Disposable.dispose);
        return Belt_Option.forEach(cursorChangeHandle.contents, Editor.Disposable.dispose);
      }
      
    };
    var cursorChangelistener = function (points) {
      var offsets = Belt_Array.map(points, Curry._1(Editor.offsetAtPoint, editor));
      console.log("\n### Cursors  : " + (Util$AgdaModeVscode.Pretty.array(Belt_Array.map(offsets.sort(Caml_primitive.caml_int_compare), (function (prim) {
                        return String(prim);
                      }))) + ("\n### Instances: " + Util$AgdaModeVscode.Pretty.array(Belt_Array.map(self.instances, (function (i) {
                          return "(" + (String(i.range[0]) + (", " + (String(i.range[1]) + ")")));
                        }))))));
      self.instances = Belt_Array.keep(self.instances, (function (instance) {
              var survived = Belt_Array.some(offsets, (function (param) {
                      return withIn(instance, param);
                    }));
              if (!survived) {
                destroy(instance);
              }
              return survived;
            }));
      self.cursorsToBeChecked = undefined;
      return checkIfEveryoneIsStillAlive(undefined);
    };
    var iterateThroughUpdates = function (updates) {
      var go = function (accum, param) {
        if (!param) {
          return $$Promise.resolved(undefined);
        }
        var updates = param[1];
        var match = param[0];
        var text = match[2];
        var end_ = match[1];
        var start = match[0];
        var range = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, editor, start + accum | 0), Curry._2(Editor.pointAtOffset, editor, end_ + accum | 0));
        var delta = text.length - (end_ - start | 0) | 0;
        console.log("!!! " + (text + (" (" + (String(accum + start | 0) + ("," + (String(accum + end_ | 0) + (") => (" + (String(accum + start | 0) + ("," + (String((accum + end_ | 0) + delta | 0) + (") " + String(accum))))))))))));
        match[3].range = /* tuple */[
          accum + start | 0,
          (accum + end_ | 0) + delta | 0
        ];
        var accum$1 = accum + delta | 0;
        return $$Promise.flatMap(Curry._3(Editor.setText, editor, range, text), (function (param) {
                      return go(accum$1, updates);
                    }));
      };
      console.log("!!! UPDATES start " + String(updates.length));
      return $$Promise.tap(go(0, Belt_List.fromArray(updates)), (function (param) {
                    console.log("!!! UPDATES finish " + String(updates.length));
                    
                  }));
    };
    cursorChangeHandle.contents = Caml_option.some(Curry._1(Editor.onChangeCursorPosition, (function (points) {
                self.cursorsToBeChecked = points;
                console.log("locked2: " + Pervasives.string_of_bool(self.lock));
                if (self.lock) {
                  console.log("### wait");
                  return ;
                } else {
                  return cursorChangelistener(points);
                }
              })));
    editorChangeHandle.contents = Caml_option.some(Curry._1(Editor.onChange, (function (changes) {
                if (!self.lock && changes.length !== 0) {
                  self.lock = true;
                  checkIfEveryoneIsStillAlive(undefined);
                  console.log(">>>>>>>>>>>>>>>>> LOCK");
                  console.log("~~~ offset start");
                  var changes$1 = changes.sort((function (x, y) {
                          return Caml_primitive.caml_int_compare(x.offset, y.offset);
                        }));
                  var updates = [];
                  var scanAndUpdate = function (_accum, _param) {
                    while(true) {
                      var param = _param;
                      var accum = _accum;
                      var match = param[0];
                      if (match) {
                        var match$1 = param[1];
                        if (!match$1) {
                          return /* [] */0;
                        }
                        var is = match$1[1];
                        var instance = match$1[0];
                        var cs = match[1];
                        var change = match[0];
                        var match$2 = instance.range;
                        var end_ = match$2[1];
                        var start = match$2[0];
                        var delta = change.insertText.length - change.replaceLength | 0;
                        if (withIn(instance, change.offset)) {
                          var next = Curry._3(Buffer2.update, instance.range[0], instance.buffer, change);
                          if (next) {
                            updates.push(/* tuple */[
                                  accum + start | 0,
                                  (accum + end_ | 0) + delta | 0,
                                  next[1],
                                  instance
                                ]);
                            instance.buffer = next[0];
                          }
                          instance.range = /* tuple */[
                            accum + start | 0,
                            (accum + end_ | 0) + delta | 0
                          ];
                          return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                    instance,
                                    scanAndUpdate(accum + delta | 0, /* tuple */[
                                          cs,
                                          is
                                        ])
                                  ]);
                        }
                        if (change.offset < instance.range[0]) {
                          _param = /* tuple */[
                            cs,
                            /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                instance,
                                is
                              ])
                          ];
                          _accum = accum + delta | 0;
                          continue ;
                        }
                        instance.range = /* tuple */[
                          accum + start | 0,
                          accum + end_ | 0
                        ];
                        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                  instance,
                                  scanAndUpdate(accum, /* tuple */[
                                        /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                            change,
                                            cs
                                          ]),
                                        is
                                      ])
                                ]);
                      }
                      var match$3 = param[1];
                      if (match$3) {
                        return /* :: */Caml_chrome_debugger.simpleVariant("::", [
                                  match$3[0],
                                  match$3[1]
                                ]);
                      } else {
                        return /* [] */0;
                      }
                    };
                  };
                  self.instances = Belt_List.toArray(scanAndUpdate(0, /* tuple */[
                            Belt_List.fromArray(changes$1),
                            Belt_List.fromArray(self.instances)
                          ]));
                  console.log("~~~ offset finish");
                  return $$Promise.get(updates.length !== 0 ? iterateThroughUpdates(updates) : $$Promise.resolved(undefined), (function (param) {
                                self.lock = false;
                                console.log(">>>>>>>>>>>>>>>>> UNLOCK");
                                var points = self.cursorsToBeChecked;
                                if (points !== undefined) {
                                  self.cursorsToBeChecked = undefined;
                                  return cursorChangelistener(points);
                                }
                                
                              }));
                }
                
              })));
    
  };
  var make$1 = function (param) {
    return {
            onAction: Event$AgdaModeVscode.make(undefined),
            instances: [],
            activated: false,
            cursorsToBeChecked: undefined,
            lock: false
          };
  };
  return {
          Buffer2: Buffer2,
          Instance: Instance,
          insertBackslash: insertBackslash,
          activate: activate,
          make: make$1
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
