// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(param) {
  var match = $$Promise.pending(undefined);
  return {
          externalQueue: [],
          internalQueue: [],
          status: /* Idle */1,
          execute: undefined,
          terminationPromise: match[0],
          terminate: match[1],
          shouldTerminate: false
        };
}

function setup(self, execute) {
  self.execute = execute;
  
}

function pushInternal(self, xs) {
  var xs$1 = Belt_List.toArray(Belt_List.map(xs, (function (x) {
              return /* Wrapped */Caml_chrome_debugger.variant("Wrapped", 0, [x]);
            })));
  self.internalQueue = self.internalQueue.concat(xs$1);
  
}

function run(self) {
  var getNext = function (self) {
    var x = self.internalQueue.shift();
    if (x !== undefined) {
      return x;
    } else {
      return Caml_option.undefined_to_opt(self.externalQueue.shift());
    }
  };
  var match = self.status;
  if (match) {
    var packet = getNext(self);
    if (packet !== undefined) {
      self.status = /* Busy */0;
      var execute = self.execute;
      if (execute !== undefined) {
        if (packet.tag) {
          Curry._1(packet[0], undefined);
          self.status = /* Idle */1;
          run(self);
        } else {
          $$Promise.get(Curry._1(execute, packet[0]), (function (derivedTasks) {
                  pushInternal(self, derivedTasks);
                  self.status = /* Idle */1;
                  return run(self);
                }));
        }
      } else {
        self.status = /* Idle */1;
        run(self);
      }
    }
    
  }
  if (self.shouldTerminate) {
    return Curry._1(self.terminate, undefined);
  }
  
}

function pushAndRun(self, xs) {
  var xs$1 = Belt_List.toArray(Belt_List.map(xs, (function (x) {
              return /* Wrapped */Caml_chrome_debugger.variant("Wrapped", 0, [x]);
            })));
  var match = $$Promise.pending(undefined);
  xs$1.push(/* Pending */Caml_chrome_debugger.variant("Pending", 1, [match[1]]));
  self.externalQueue = xs$1.concat(self.externalQueue);
  run(self);
  return match[0];
}

function terminate(self) {
  var match = self.status;
  if (match) {
    return Curry._1(self.terminate, undefined);
  } else {
    self.shouldTerminate = true;
    return ;
  }
}

exports.make = make;
exports.setup = setup;
exports.pushInternal = pushInternal;
exports.run = run;
exports.pushAndRun = pushAndRun;
exports.terminate = terminate;
/* Promise Not a pure module */
