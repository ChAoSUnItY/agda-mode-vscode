// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Runner3$AgdaModeVscode = require("./Runner3.bs.js");
var Dispatcher$AgdaModeVscode = require("./Dispatcher.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Dispatcher = Dispatcher$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var dispatchCommand = function (self, state, command) {
    var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
    var tasks = Curry._1(CommandHandler.handle, command);
    return Runner3$AgdaModeVscode.pushAndRun(self.runner, tasks);
  };
  var make = function (state) {
    var blockedQueues = {
      contents: []
    };
    var agdaIsOccupied = function (queues) {
      return Belt_Array.some(queues, (function (param) {
                    if (param.tag) {
                      return false;
                    } else {
                      return true;
                    }
                  }));
    };
    var runner = Runner3$AgdaModeVscode.make(undefined);
    var classifyTask = function (task) {
      console.log("Task: " + Curry._1(Task.toString, task));
      if (typeof task === "number") {
        return $$Promise.resolved(undefined);
      }
      if (task.tag !== /* SendRequest */1) {
        return $$Promise.resolved(undefined);
      }
      if (agdaIsOccupied(blockedQueues.contents)) {
        console.log("Agda blocked");
        return $$Promise.resolved(undefined);
      }
      console.log("Agda not blocked");
      var queue = Runner3$AgdaModeVscode.empty(runner);
      blockedQueues.contents.unshift(/* BlockedByAgda */Caml_chrome_debugger.variant("BlockedByAgda", 0, [queue]));
      return $$Promise.resolved(undefined);
    };
    Runner3$AgdaModeVscode.setup(runner, classifyTask);
    return {
            runner: runner,
            blockedQueues: []
          };
  };
  var interrupt = function (self, command) {
    return $$Promise.resolved(undefined);
  };
  var destroy = function (param) {
    
  };
  return {
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Dispatcher: Dispatcher,
          Task: Task,
          dispatchCommand: dispatchCommand,
          make: make,
          interrupt: interrupt,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
