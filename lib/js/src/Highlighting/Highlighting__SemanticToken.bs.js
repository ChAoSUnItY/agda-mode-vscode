// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");

function toString(x) {
  switch (x) {
    case /* Namespace */0 :
        return "namespace";
    case /* Type */1 :
        return "type";
    case /* Class */2 :
        return "class";
    case /* Enum */3 :
        return "enum";
    case /* Interface */4 :
        return "interface";
    case /* Struct */5 :
        return "struct";
    case /* TypeParameter */6 :
        return "typeParameter";
    case /* Parameter */7 :
        return "parameter";
    case /* Variable */8 :
        return "variable";
    case /* Property */9 :
        return "property";
    case /* EnumMember */10 :
        return "enumMember";
    case /* Event */11 :
        return "event";
    case /* Function */12 :
        return "function";
    case /* Member */13 :
        return "member";
    case /* Macro */14 :
        return "macro";
    case /* Label */15 :
        return "label";
    case /* Comment */16 :
        return "comment";
    case /* String */17 :
        return "string";
    case /* Keyword */18 :
        return "keyword";
    case /* Number */19 :
        return "number";
    case /* Regexp */20 :
        return "regexp";
    case /* Operator */21 :
        return "operator";
    
  }
}

var enumurate = [
  "namespace",
  "type",
  "class",
  "enum",
  "interface",
  "struct",
  "typeParameter",
  "parameter",
  "variable",
  "property",
  "enumMember",
  "event",
  "function",
  "member",
  "macro",
  "label",
  "comment",
  "string",
  "keyword",
  "number",
  "regexp",
  "operator"
];

var TokenType = {
  toString: toString,
  enumurate: enumurate
};

function toString$1(x) {
  switch (x) {
    case /* Declaration */0 :
        return "declaration";
    case /* Readonly */1 :
        return "readonly";
    case /* Static */2 :
        return "static";
    case /* Deprecated */3 :
        return "deprecated";
    case /* Abstract */4 :
        return "abstract";
    case /* Async */5 :
        return "async";
    case /* Modification */6 :
        return "modification";
    case /* Documentation */7 :
        return "documentation";
    case /* DefaultLibrary */8 :
        return "defaultLibrary";
    
  }
}

var enumurate$1 = [
  "declaration",
  "readonly",
  "static",
  "deprecated",
  "abstract",
  "async",
  "modification",
  "documentation",
  "defaultLibrary"
];

var TokenModifier = {
  toString: toString$1,
  enumurate: enumurate$1
};

function fromAspect2(x) {
  var nothing_1 = [];
  var nothing = [
    undefined,
    nothing_1,
    undefined
  ];
  switch (x) {
    case /* Comment */0 :
        return [
                /* Comment */16,
                [],
                undefined
              ];
    case /* Keyword */1 :
        return [
                /* Keyword */18,
                [],
                undefined
              ];
    case /* Number */3 :
        return [
                /* Number */19,
                [],
                undefined
              ];
    case /* Error */9 :
        return [
                undefined,
                [/* Deprecated */3],
                undefined
              ];
    case /* UnsolvedMeta */11 :
        return [
                undefined,
                [],
                [
                  "#FFFF00",
                  "#806B00"
                ]
              ];
    case /* UnsolvedConstraint */12 :
    case /* TerminationProblem */13 :
        return [
                undefined,
                [],
                [
                  "#FFA07A",
                  "#802400"
                ]
              ];
    case /* PositivityProblem */14 :
        return [
                undefined,
                [],
                [
                  "#CD853F",
                  "#803F00"
                ]
              ];
    case /* Deadcode */15 :
        return [
                undefined,
                [],
                [
                  "#A9A9A9",
                  "#808080"
                ]
              ];
    case /* CoverageProblem */16 :
        return [
                undefined,
                [],
                [
                  "#F5DEB3",
                  "#805300"
                ]
              ];
    case /* IncompletePattern */17 :
        return [
                undefined,
                [],
                [
                  "#800080",
                  "#800080"
                ]
              ];
    case /* Symbol */4 :
    case /* Pragma */6 :
    case /* Background */7 :
    case /* Markup */8 :
    case /* DottedPattern */10 :
    case /* TypeChecks */18 :
        return nothing;
    case /* CatchallClause */19 :
        return [
                undefined,
                [],
                [
                  "#F5F5F5",
                  "#404040"
                ]
              ];
    case /* ConfluenceProblem */20 :
        return [
                undefined,
                [],
                [
                  "#FFC0CB",
                  "#800080"
                ]
              ];
    case /* Bound */21 :
    case /* Generalizable */22 :
        return [
                /* Variable */8,
                [],
                undefined
              ];
    case /* ConstructorInductive */23 :
    case /* ConstructorCoInductive */24 :
        return [
                /* EnumMember */10,
                [],
                undefined
              ];
    case /* PrimitiveType */5 :
    case /* Datatype */25 :
        return [
                /* Type */1,
                [],
                undefined
              ];
    case /* Field */26 :
        return [
                /* Member */13,
                [],
                undefined
              ];
    case /* Module */28 :
        return [
                /* Namespace */0,
                [],
                undefined
              ];
    case /* Function */27 :
    case /* Postulate */29 :
        return [
                /* Function */12,
                [],
                undefined
              ];
    case /* String */2 :
    case /* Primitive */30 :
        return [
                /* String */17,
                [],
                undefined
              ];
    case /* Record */31 :
        return [
                /* Struct */5,
                [],
                undefined
              ];
    case /* Argument */32 :
        return [
                /* Parameter */7,
                [],
                undefined
              ];
    case /* Macro */33 :
        return [
                /* Macro */14,
                [],
                undefined
              ];
    case /* Operator */34 :
        return [
                /* Operator */21,
                [],
                undefined
              ];
    
  }
}

function fromAspect(x) {
  switch (x) {
    case /* Comment */0 :
        return [
                /* Comment */16,
                []
              ];
    case /* Keyword */1 :
        return [
                /* Keyword */18,
                []
              ];
    case /* Number */3 :
        return [
                /* Number */19,
                []
              ];
    case /* Markup */8 :
        return [
                /* Label */15,
                []
              ];
    case /* Symbol */4 :
    case /* Background */7 :
    case /* Error */9 :
    case /* DottedPattern */10 :
    case /* UnsolvedMeta */11 :
    case /* UnsolvedConstraint */12 :
    case /* TerminationProblem */13 :
    case /* PositivityProblem */14 :
    case /* Deadcode */15 :
    case /* CoverageProblem */16 :
    case /* IncompletePattern */17 :
    case /* TypeChecks */18 :
    case /* CatchallClause */19 :
    case /* ConfluenceProblem */20 :
        return ;
    case /* Bound */21 :
    case /* Generalizable */22 :
        return [
                /* Variable */8,
                []
              ];
    case /* ConstructorInductive */23 :
    case /* ConstructorCoInductive */24 :
        return [
                /* EnumMember */10,
                []
              ];
    case /* PrimitiveType */5 :
    case /* Datatype */25 :
        return [
                /* Type */1,
                []
              ];
    case /* Field */26 :
        return [
                /* Member */13,
                []
              ];
    case /* Module */28 :
        return [
                /* Namespace */0,
                []
              ];
    case /* Function */27 :
    case /* Postulate */29 :
        return [
                /* Function */12,
                []
              ];
    case /* String */2 :
    case /* Primitive */30 :
        return [
                /* String */17,
                []
              ];
    case /* Record */31 :
        return [
                /* Struct */5,
                []
              ];
    case /* Argument */32 :
        return [
                /* Parameter */7,
                []
              ];
    case /* Pragma */6 :
    case /* Macro */33 :
        return [
                /* Macro */14,
                []
              ];
    case /* Operator */34 :
        return [
                /* Operator */21,
                []
              ];
    
  }
}

function toString$2(param) {
  var column = param.column;
  return String(param.line) + ":" + String(column[0]) + "-" + String(column[1]);
}

function toVsCodeRange(param) {
  var column = param.column;
  var line = param.line;
  return new Vscode.Range(new Vscode.Position(line, column[0]), new Vscode.Position(line, column[1]));
}

function splitRange(doc, range) {
  var startingLine = range.start.line;
  var endingLine = range.end.line;
  var ranges = [];
  for(var i = startingLine; i <= endingLine; ++i){
    var startingPoint = i === startingLine ? range.start : new Vscode.Position(i, 0);
    var endingPoint;
    if (i === endingLine) {
      endingPoint = range.end;
    } else {
      var offset = doc.offsetAt(new Vscode.Position(i + 1 | 0, 0)) - 1 | 0;
      endingPoint = doc.positionAt(offset);
    }
    ranges.push({
          line: startingPoint.line,
          column: [
            startingPoint.character,
            endingPoint.character
          ]
        });
  }
  return ranges;
}

var SingleLineRange = {
  toString: toString$2,
  toVsCodeRange: toVsCodeRange,
  splitRange: splitRange
};

function toString$3(token) {
  var tokenType = toString(token.type_);
  var modifiers = Util$AgdaModeVscode.Pretty.array(Belt_Option.mapWithDefault(token.modifiers, [], (function (xs) {
              return Belt_Array.map(xs, toString$1);
            })));
  return "(" + toString$2(token.range) + ") " + tokenType + " " + modifiers;
}

var Module = {
  SingleLineRange: SingleLineRange,
  toString: toString$3
};

exports.TokenType = TokenType;
exports.TokenModifier = TokenModifier;
exports.fromAspect2 = fromAspect2;
exports.fromAspect = fromAspect;
exports.Module = Module;
exports.SingleLineRange = SingleLineRange;
exports.toString = toString$3;
/* vscode Not a pure module */
