// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("../Util/Event.bs.js");
var State$AgdaModeVscode = require("../State.bs.js");
var Command$AgdaModeVscode = require("../Command.bs.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Task__View$AgdaModeVscode = require("./Task__View.bs.js");
var Task__Error$AgdaModeVscode = require("./Task__Error.bs.js");
var Task__Command$AgdaModeVscode = require("./Task__Command.bs.js");
var Task__Response$AgdaModeVscode = require("./Task__Response.bs.js");

function Impl(Editor) {
  var ErrorHandler = Task__Error$AgdaModeVscode.Impl(Editor);
  var ViewHandler = Task__View$AgdaModeVscode.Impl(Editor);
  var TaskCommand = Task__Command$AgdaModeVscode.Impl(Editor);
  var TaskResponse = Task__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var State = State$AgdaModeVscode.Impl(Editor);
  var addTask = function (self, task) {
    return Curry._1(self.taskEmitter.emit, task);
  };
  var addTasks = function (self, tasks) {
    return Belt_List.forEach(tasks, (function (param) {
                  return Curry._1(self.taskEmitter.emit, param);
                }));
  };
  var runTask = function (self, state, task) {
    if (typeof task === "number") {
      if (task === /* Terminate */0) {
        console.log("[ task ][ terminate ] ");
        Curry._1(State.destroy, state);
        return $$Promise.resolved(undefined);
      }
      console.log("[ task ][ connect ]");
      return $$Promise.map($$Promise.tapError($$Promise.tapOk(Curry._1(State.connect, state), (function (param) {
                            console.log("OK", param);
                            
                          })), (function (param) {
                        console.log("Error", param);
                        
                      })), (function (param) {
                    
                  }));
    } else {
      switch (task.tag | 0) {
        case /* WithState */0 :
            return $$Promise.map(Curry._1(task[0], state), (function (param) {
                          return addTasks(self, param);
                        }));
        case /* DispatchCommand */1 :
            var command = task[0];
            console.log("[ task ][ command ] " + Command$AgdaModeVscode.toString(command));
            var tasks = Curry._1(TaskCommand.dispatch, command);
            return $$Promise.resolved(Belt_List.forEach(tasks, (function (param) {
                              return Curry._1(self.taskEmitter.emit, param);
                            })));
        case /* SendRequest */2 :
            console.log("[ task ][ send request ]");
            var match = $$Promise.pending(undefined);
            var resolve = match[1];
            var promise = match[0];
            var onResponse = function (error) {
              if (error.tag) {
                var tasks = Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]]));
                Belt_List.forEach(tasks, (function (param) {
                        return Curry._1(self.taskEmitter.emit, param);
                      }));
                return Curry._1(resolve, undefined);
              }
              var match = error[0];
              if (!match) {
                return Curry._1(resolve, undefined);
              }
              var error$1 = match[0];
              if (error$1.tag) {
                var tasks$1 = Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]]));
                Belt_List.forEach(tasks$1, (function (param) {
                        return Curry._1(self.taskEmitter.emit, param);
                      }));
                return Curry._1(resolve, undefined);
              }
              var response = error$1[0];
              console.log(Response$AgdaModeVscode.toString(response));
              var tasks$2 = Curry._1(TaskResponse.handle, response);
              return Belt_List.forEach(tasks$2, (function (param) {
                            return Curry._1(self.taskEmitter.emit, param);
                          }));
            };
            return $$Promise.flatMap(Curry._2(State.sendRequest, state, task[0]), (function (connection) {
                          if (connection.tag) {
                            var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                            Belt_List.forEach(tasks, (function (param) {
                                    return Curry._1(self.taskEmitter.emit, param);
                                  }));
                            Curry._1(resolve, undefined);
                            return promise;
                          }
                          var destructor = Curry._1(connection[0].emitter.on, onResponse);
                          return $$Promise.map(promise, destructor);
                        }));
        case /* ViewReq */3 :
            return Curry._2(State.sendRequestToView, state, task[0]);
        case /* ViewRes */4 :
            var tasks$1 = Curry._1(ViewHandler.handle, task[0]);
            Belt_List.forEach(tasks$1, (function (param) {
                    return Curry._1(self.taskEmitter.emit, param);
                  }));
            return $$Promise.resolved(undefined);
        
      }
    }
  };
  var make = function (state) {
    var taskQueue = [];
    var commandQueue = [];
    var taskEmitter = Event$AgdaModeVscode.make(undefined);
    var statusEmitter = Event$AgdaModeVscode.make(undefined);
    var self = {
      taskEmitter: taskEmitter,
      statusEmitter: statusEmitter,
      status: /* Idle */1
    };
    var getNextTask = function (param) {
      var nextTask = taskQueue.shift();
      if (nextTask !== undefined) {
        return nextTask;
      } else {
        return Belt_Option.map(Caml_option.undefined_to_opt(commandQueue.shift()), (function (command) {
                      return /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 1, [command]);
                    }));
      }
    };
    var runTasksInQueues = function (param) {
      var nextTask = getNextTask(undefined);
      if (nextTask !== undefined) {
        return $$Promise.get(runTask(self, state, nextTask), runTasksInQueues);
      } else {
        self.status = /* Idle */1;
        return Curry._1(self.statusEmitter.emit, /* Idle */1);
      }
    };
    Curry._1(taskEmitter.on, (function (task) {
            if (typeof task === "number" || task.tag !== /* DispatchCommand */1) {
              taskQueue.push(task);
            } else {
              commandQueue.push(task[0]);
            }
            if (self.status === /* Idle */1) {
              self.status = /* Busy */0;
              Curry._1(self.statusEmitter.emit, /* Busy */0);
              return runTasksInQueues(undefined);
            }
            
          }));
    return self;
  };
  var destroy = function (self) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var destroy$prime = function (param) {
      Curry._1(self.statusEmitter.destroy, undefined);
      Curry._1(self.taskEmitter.destroy, undefined);
      return Curry._1(resolve, undefined);
    };
    var match$1 = self.status;
    if (match$1) {
      destroy$prime(undefined);
    } else {
      Curry._1(self.statusEmitter.on, (function (param) {
              if (param) {
                return destroy$prime(undefined);
              }
              
            }));
    }
    return match[0];
  };
  return {
          ErrorHandler: ErrorHandler,
          ViewHandler: ViewHandler,
          TaskCommand: TaskCommand,
          TaskResponse: TaskResponse,
          Task: Task,
          State: State,
          addTask: addTask,
          addTasks: addTasks,
          runTask: runTask,
          make: make,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
