open Belt;

type source =
  | Agda
  | View
  | Command
  | Misc;

//  This module represents a list of Task queues, tagged by some `source`,
//  which is responsible for generating and pushing Tasks into its Task queue
//
//  For example, the initial queues should look something like this,
//  with `Command` as the only source of Tasks
//
//    [ Command : [ Task0, Task1 ]
//    ]
//
//  More Tasks will be added to this queue as the user gives more commands
//
//    [ Command : [ Task0, Task1, Task2, Task3 ]
//    ]
//
//  On the other hand, Tasks are comsumed from the other end (that's how queue works, right?)
//
//    [ Command : [ Task1, Task2, Task3 ]
//    ]
//
//  However, some Tasks are special, they block other Tasks coming after them,
//  and even generates Tasks on their own!
//  `SendRequest(..)` (to Agda) is among one of these Tasks:
//
//    [ Agda    : [ Task4, Task5, Task6, .... ]
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  Tasks of Reponses from Agda will be added to this new "Agda" queue.
//  Tasks in the "Agda" queue have higher priority than those of the "Command" queue.
//
//    [ Agda    : [ Task5, Task6, Task7, ... ]
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  Often, tasks in the "Agda" queue are consumed faster than they are generated by Agda.
//  And this would cause the "Agda" queue to be empty.
//  However, this doesn't mean that we can continue to consume Tasks in the "Command" queue,
//  as more Tasks may will be added to the "Agda" queue.
//
//    [ Agda    : [ ]
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  The "Agda" queue can only be removed after the request-response cycle is completed.
//  Tasks in the "Command" queue can then continue to be executed afterwards.
//
//    [ Command : [ Task1, Task2, Task3 ]
//    ]
//
//  If there are any remaining Tasks in the "Agda" queue after the cycle is completed:
//
//    [ Agda    : [ Task5, Task6, Task7 ]
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  The remaining Tasks should be prepended to the next queue with lower priority
//  (in this case, the "Command" queue)
//
//    [ Command : [ Task5, Task6, Task7, Task1, Task2, Task3 ]
//    ]
//
//  Note that other Tasks in the "Agda" queue may also behave like `SendRequest(..)`.
//  For example, it may prompt an input box and wait until the user to reply.
//  In this case, the "Agda" queue is now blocked by the "View" queue.
//
//    [ View    : [ Task8 ]
//    , Agda    : [ Task5, Task6, Task7, ... ]
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  Interestingly, the Tasks in the "Agda" queue may just be `SendRequest(..)`.
//  Since there can only be one request to Agda at a time, the resouce is now occupied,
//  The whole queues should be blocked, and wait until the current
//  request-response cycle is completed.
//
//    [ Agda    : [ SendRequest(..), Task4 ]       (assume completed)
//    , Command : [ Task1, Task2, Task3 ]
//    ]
//
//  Then, the "Agda" queue should be removed while
//  the remaining Tasks get concatenated to the next queue
//
//    [ Command : [ SendRequest(..), Task4, Task1, Task2, Task3 ]
//    ]
//
//  And `SendRequest(..)` should be able to be executed and spawn a new "Agda" queue
//
//    [ Agda    : [ Task5, Task6, Task7, ... ]
//    , Command : [ Task4, Task1, Task2, Task3 ]
//    ]
//
type t('task) = list((source, list('task)));

let make = () => [(Command, [])];

let spawn = (queues, source) => {
  [(source, []), ...queues];
};

let remove = (queues, target) => {
  // walk through and remove the first matched queue (while leaving the rest)
  let lastQueueMatched = ref(None);
  queues->List.keepMap(((source, queue)) =>
    if (source == target && Option.isNone(lastQueueMatched^)) {
      lastQueueMatched := Some(queue);
      None; // this queue is to be removed
    } else {
      switch (lastQueueMatched^) {
      | Some(queue') =>
        // the previous queue was removed
        // should prepend to this queue
        lastQueueMatched := None;
        Some((source, List.concat(queue', queue)));
      | None => Some((source, queue)) // the boring case
      };
    }
  );
};

let addTasks = (queues, target, tasks) => {
  // walk through and concatenate the Tasks to the first matching queue
  let concatenated = ref(false);
  queues->List.keepMap(((source, queue)) =>
    if (source == target && ! concatenated^) {
      concatenated := true;
      Some((source, List.concat(queue, tasks)));
    } else {
      Some((source, queue));
    }
  );
};

let countBySource = (queues, target) =>
  queues->List.reduce(0, (accum, (source, _queue)) =>
    if (source == target) {
      accum + 1;
    } else {
      accum;
    }
  );

let toString = (taskToString, queues) => {
  let strings =
    queues
    ->List.map(
        fun
        | (Agda, queue) =>
          "Agda " ++ Util.Pretty.list(List.map(queue, taskToString))
        | (View, queue) =>
          "View " ++ Util.Pretty.list(List.map(queue, taskToString))
        | (Command, queue) =>
          "Comm " ++ Util.Pretty.list(List.map(queue, taskToString))
        | (Misc, queue) =>
          "Misc " ++ Util.Pretty.list(List.map(queue, taskToString)),
      )
    ->List.toArray;
  Js.Array.joinWith("\n", strings);
};

let rec getNextTask = (blocking, queues) =>
  switch (queues) {
  | [] => None // should not happen, the "Command" queue is gone
  | [(_source, []), ...queues] =>
    if (blocking) {
      None; // stuck waiting for the `_source`
    } else {
      getNextTask(blocking, queues)
      ->Option.map(((task, queues)) =>
          (task, [(_source, []), ...queues])
        );
    }
  | [(source, [task, ...queue]), ...queues] =>
    Some((task, [(source, queue), ...queues]))
  };